{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/LICENSE","hash":"4c3927c82d0aa4fac5cdf945e07afe5e24335891","modified":1517882480948},{"_id":"themes/BlueLake/README.en.md","hash":"6cc6e346635bf26dd71030b9c3c6443507cd4108","modified":1517882480948},{"_id":"themes/BlueLake/README.md","hash":"66c3ef7a779b6d65bad90daa2e03bcb7a1bb742f","modified":1517882480949},{"_id":"themes/BlueLake/_config.yml","hash":"5baf7e3dcf77588223fcbe662b07ad62023b43bf","modified":1517886451414},{"_id":"themes/BlueLake/package.json","hash":"cdef382c442618b24305fd3e38ac7a3accf87aa9","modified":1517882480956},{"_id":"themes/BlueLake/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1517882480940},{"_id":"themes/BlueLake/.git/config","hash":"05165d804714e9c1a0e5d4a99a95a77f34d4fac6","modified":1517882480943},{"_id":"themes/BlueLake/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1517882477479},{"_id":"themes/BlueLake/.git/index","hash":"fe3d8040723435f9b49be2f5605e66ddce03c3e7","modified":1517886833431},{"_id":"themes/BlueLake/.git/packed-refs","hash":"842a64dcd40e108353d1da6314a0c447e35b921d","modified":1517882480937},{"_id":"source/_posts/Android自动化测试.md","hash":"a1cbe08b4af305f75221e43ba491d1a7170b9fa2","modified":1517888476280},{"_id":"source/_posts/Dagger2.md","hash":"c7ce231d70d019afd691445dba25b3dac15b5d5e","modified":1517887494935},{"_id":"source/_posts/compileSdkVersion, minSdkVersion， targetSdkVersion这三兄弟.md","hash":"cff72d77399b0c1756f7ed3bd9055bdeb09bb049","modified":1517888360580},{"_id":"source/_posts/python抓妹子.md","hash":"691943b1095d55ae70aa801497dbe6e64b3178cb","modified":1517907247083},{"_id":"source/_posts/python爬虫scrapy的使用.md","hash":"5e926b0d531501c746022ea2325415229c2766aa","modified":1517993844299},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"d7f5842295509746f878e627c4c7e298f3f1613a","modified":1517884275631},{"_id":"themes/BlueLake/languages/en.yml","hash":"95bac2c366505d016b5defc47370679b9f5f3c4b","modified":1517882480949},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"baa68725feeec6643f875a532a9d55ba8aacdb2c","modified":1517882480950},{"_id":"themes/BlueLake/languages/ko.yml","hash":"fc8826724f570136d9a2d3ec2705b7b7000e0f14","modified":1517882480950},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"bd97d5e4b39d30da1644b90256dfc4e6b1d76988","modified":1517882480950},{"_id":"themes/BlueLake/languages/tr.yml","hash":"5f13d55fdd5bdd1115075736e3e26a1ea1dd1dea","modified":1517882480950},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"d7f5842295509746f878e627c4c7e298f3f1613a","modified":1517882480950},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"d4d587ba81864910715c0c3879605cc6a9362e09","modified":1517882480951},{"_id":"themes/BlueLake/layout/archive.jade","hash":"98d9fb812edbc180878fdadb65bc38499eef2cc4","modified":1517882480955},{"_id":"themes/BlueLake/layout/base.jade","hash":"ee19d63543f898336dee846ed45d932239c40fe0","modified":1517882480955},{"_id":"themes/BlueLake/layout/category.jade","hash":"9f3a9f1d6f0bbad258b308ad8d49128c05b422cf","modified":1517882480955},{"_id":"themes/BlueLake/layout/index.jade","hash":"dd81d9f7a6b388de2ab731b17b3ba55f70df4a5f","modified":1517882480955},{"_id":"themes/BlueLake/layout/page.jade","hash":"415404398931d98db28bff723886b07dcb8bbbc3","modified":1517882480955},{"_id":"themes/BlueLake/layout/post.jade","hash":"0305258c33e4d02f977ee1aaf7f2429b993fda17","modified":1517882480956},{"_id":"themes/BlueLake/layout/tag.jade","hash":"50c7af7565751db5d7672beb434768885fb224cb","modified":1517882480956},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1517882480956},{"_id":"themes/BlueLake/source/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1517882480957},{"_id":"themes/BlueLake/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1517882477480},{"_id":"themes/BlueLake/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1517882477480},{"_id":"themes/BlueLake/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1517882477481},{"_id":"themes/BlueLake/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1517882477481},{"_id":"themes/BlueLake/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1517882477482},{"_id":"themes/BlueLake/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1517882477482},{"_id":"themes/BlueLake/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1517882477482},{"_id":"themes/BlueLake/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1517882477483},{"_id":"themes/BlueLake/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1517882477483},{"_id":"themes/BlueLake/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1517882477484},{"_id":"themes/BlueLake/.git/logs/HEAD","hash":"2f7a0fbd99e0608fd3683ee2a67d30c4c23e234e","modified":1517882480941},{"_id":"themes/BlueLake/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1517882477484},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"3f11d2b5a4c647bf2b37c4d00bdc250cda80b770","modified":1517882480951},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"21d05990aa5a19632f9ed51085ef7727adeea17a","modified":1517882480951},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"c1f1955d12aee22a931a3f4ad9d0e9a408e80f3c","modified":1517882480951},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"d970c81b5cdbd7c0348ee28e93bcbb006d613b6d","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"e0aa5d7adc1218a324a484abe3513e9545f89067","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/mathjax.jade","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/mathjax2.jade","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1517882480953},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"4f2fba7fcb39a6bf70ff04dad9a3dab2563b21e7","modified":1517882480953},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"ba0839518db2cb9dafee67ca5e471219bfba2e90","modified":1517882480953},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1517882480953},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"c632919f04194dcf6e0e8ccc572554a859aa922b","modified":1517882480953},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"6e587b7d254d0d92b959ba58262f5e81b618eba2","modified":1517882480953},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"0107affa0c6b22e09546fcf82a6f71ba2dd1e315","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"9af40206a525db1cb9761fa6facb36332057acf3","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"164a83faaf92ec19d268fd303bf6e30348ddef5c","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"c6f778d5d2f13bacbd83a56a9e9faaeac0dda0ed","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"c75308c2b72456cfb98cb80f280c66e58f171705","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"4e90378aa88c5694126dc8ea5bed3bb2f8642e53","modified":1517882480954},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"92b5c306f276f8ea6a134e303b1b63612d25ecfe","modified":1517882480957},{"_id":"themes/BlueLake/source/css/style.styl","hash":"45776bc176bc8ed0d664e953e23d6a0a9a030929","modified":1517882480957},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1517882480958},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1517882480958},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1517882480959},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1517882480959},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"7ce826f7b678ff3c524fce8bbd480c188e50c7ee","modified":1517882480960},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"9e68d688f2f12ec193ce9496beb0fd42e1de2288","modified":1517882480960},{"_id":"themes/BlueLake/source/js/totop.js","hash":"d9367c6fa3e973bc5f32ce38d951858455726a02","modified":1517882480961},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1517882480960},{"_id":"themes/BlueLake/.git/refs/heads/master","hash":"c292cfc66fa6a171bcb9e25157b4ee8f09da6755","modified":1517882480941},{"_id":"themes/BlueLake/.git/objects/pack/pack-3960201a6b68eb8fa7ccb74fce2c388277a0b0ef.idx","hash":"72b864447dcf0acf0212056587453d6cbed114af","modified":1517882480900},{"_id":"themes/BlueLake/.git/logs/refs/heads/master","hash":"2f7a0fbd99e0608fd3683ee2a67d30c4c23e234e","modified":1517882480942},{"_id":"themes/BlueLake/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1517882480939},{"_id":"themes/BlueLake/.git/logs/refs/remotes/origin/HEAD","hash":"2f7a0fbd99e0608fd3683ee2a67d30c4c23e234e","modified":1517882480939},{"_id":"themes/BlueLake/.git/objects/pack/pack-3960201a6b68eb8fa7ccb74fce2c388277a0b0ef.pack","hash":"dba040ba1c38e38283e16f9ff438852ac811a55a","modified":1517882480903},{"_id":"public/categories/Android基础学习/index.html","hash":"7c1594ea3706a464820440bbf73ae2ba165d07a5","modified":1519617944250},{"_id":"public/categories/python/index.html","hash":"3cff49caa4ad46728d6ff0ef2ab114f505a5adef","modified":1519617944251},{"_id":"public/index.html","hash":"b9612bb7fcba93ff4208ffe25322c83d5d383376","modified":1519617944251},{"_id":"public/archives/index.html","hash":"40b19b88e0b0581fbbe13761f02487f470a17315","modified":1519617944252},{"_id":"public/archives/2016/index.html","hash":"ccbdea3b377d2df0c6e1cb837e536c4699972ca2","modified":1519617944252},{"_id":"public/archives/2016/06/index.html","hash":"ccbdea3b377d2df0c6e1cb837e536c4699972ca2","modified":1519617944252},{"_id":"public/archives/2018/index.html","hash":"39277e3e134efafd0863ae6957502d1bd7007ab4","modified":1519617944252},{"_id":"public/archives/2018/02/index.html","hash":"39277e3e134efafd0863ae6957502d1bd7007ab4","modified":1519617944252},{"_id":"public/tags/Android/index.html","hash":"f171805fe984371415f60e43aa23c7d19c397fc8","modified":1519617944251},{"_id":"public/tags/测试/index.html","hash":"68a685830451c855c8779638f71ad7eb1a3fb383","modified":1519617944251},{"_id":"public/tags/技术/index.html","hash":"4f3dc8f3644c7227f6b4d3996ae94743f3754131","modified":1519617944251},{"_id":"public/tags/python/index.html","hash":"f6571509548683a586f55358eb7060dea999a396","modified":1519617944252},{"_id":"public/tags/爬虫/index.html","hash":"afb97397aeedc3136e038a8acd3d08a870e4ee32","modified":1519617944252},{"_id":"public/tags/三方框架/index.html","hash":"d43828f41c255723954178af33d3b0722b3d956c","modified":1519617944252},{"_id":"public/2018/02/06/python爬虫scrapy的使用/index.html","hash":"ba487198a372787436e2b5c25d5b66efba210ed7","modified":1519617944252},{"_id":"public/2018/02/06/python抓妹子/index.html","hash":"6d09b25b9700c3a6819ffd6c9af4958cfe9ee719","modified":1519617944252},{"_id":"public/2016/06/01/Android自动化测试/index.html","hash":"cdae5580c6774486522bfa5f8033152509cc6f68","modified":1519617944252},{"_id":"public/2016/06/01/compileSdkVersion, minSdkVersion， targetSdkVersion这三兄弟/index.html","hash":"d93244fcba6b3a7fc806eee3f17f6bec23101afa","modified":1519617944252},{"_id":"public/2016/06/01/Dagger2/index.html","hash":"b5ec80e62552d1fa5d9c305b93f0e01e547e99b2","modified":1519617944253},{"_id":"public/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1518164268051},{"_id":"public/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1518164268051},{"_id":"public/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1518164268051},{"_id":"public/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1518164268051},{"_id":"public/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1518164268051},{"_id":"public/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1518164268051},{"_id":"public/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1518164268296},{"_id":"public/css/highlight.css","hash":"fb0403feb34cc8bb8b1f28f238540d36588b86df","modified":1518164268300},{"_id":"public/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1518164268300},{"_id":"public/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1518164268300},{"_id":"public/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1518164268300},{"_id":"public/css/style.css","hash":"0b87f0674cad37ed4006f989cca7e1cd9f9568a3","modified":1518164268300},{"_id":"source/_posts/点击图标启动activity的过程.md","hash":"1c189d3cfccc97c1f02feef2e636f03610bd7fcb","modified":1519616262807},{"_id":"public/2018/02/26/点击图标启动activity的过程/index.html","hash":"9f03332e7993834d7b389cd0ef02b44fd3793e05","modified":1519617944253}],"Category":[{"name":"Android基础学习","_id":"cjdfnt20o0002j0iemoocupfx"},{"name":"python","_id":"cjdfnt20x000aj0iegwqpzbd7"},{"name":"android","_id":"cje3pd2np000010iemojpx6mn"}],"Data":[],"Page":[],"Post":[{"title":"Android自动化测试","date":"2016-06-01T15:47:44.000Z","_content":"\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg)\n\n\n\n-----------------\n\n    \n\n### 摘要\n    Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n\n### Monkey测试\n\n#### 简介\n\tMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n\n#### 使用方式\n\t（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n\t（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n\t（3）Monkey 命令启动方式：  \n\t  \n\t    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n\t    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n\t    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n\t\n#### 效果展示\n部分输出数据如下所示：\n![输出数据](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png)\n\n#### 更多参数介绍\n[点击查看](http://blog.csdn.net/linghu_java/article/details/6732895)\n\t\t\n#### 可能会遇到的问题\n\t（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n[点击查看解决方案](http://www.cnblogs.com/dwf07223/p/3228047.html)\n\n\n### 单元测试\n\t\n#### 简介\n\t单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n\n#### 使用方式\n\t首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\t\n\tdependencies {\n\t    testCompile 'junit:junit:4.12'\n    }\n\n而后在test文件下写单元测试类\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png)\n\n被测试类如下\n\n\tpublic class Calculator {\n\t    public static int add(int a, int b) {\n\t        return a + b;\n\t    }\n\t}\n\n单元测试类如下\n\n\tpublic class ExampleUnitTest {\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        assertEquals(4, Calculator.add(2,2));\n\t    }\n\t}\n\n最后运行单元测试类，结果如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png)\n\t\n#### Junit标签解析\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n\t@Test： 将方法（函数）标记为测试用例\n\t@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n\t@After： 每一个使用@Test标记的方法运行之后都要运行一次\n\t@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n\t@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n\n以如下代码为例：\n\t\n\tpublic class ExampleUnitTest {\n\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t\n\t    @Test\n\t    public void addition_isErr() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t    @Before\n\t    public void before() throws Exception {\n\t        System.out.println(\"@Before\");\n\t    }\n\t\n\t    @After\n\t    public void after() throws Exception {\n\t        System.out.println(\"@After\");\n\t    }\n\t\n\t\n\t    @AfterClass\n\t    public static void afterClass() throws Exception {\n\t        System.out.println(\"@AfterClass\");\n\t    }\n\t\n\t    @BeforeClass\n\t    public static void beforeClass() throws Exception {\n\t        System.out.println(\"@BeforeClass\");\n\t    }\n\t}\n\t\n相应的执行顺序如下：\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png)\n\n#### Mockito使用方式\n\n简介：\n\t\t\n\tMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n\n**先体验以下Mockito的使用：**\n\n1.添加依赖\n\n\ttestCompile 'org.mockito:mockito-core:2.8.47'\n\n2.被依赖类\n\t\n\tpublic interface IMathUtils {\n\t    public int abs(int num); // 求绝对值\n\t}\n\t\n3.依赖类\n\n\t@RunWith(MockitoJUnitRunner.class)\n\tpublic class MockTest {\n\t    @Mock\n\t    IMathUtils mathUtils;\n\t\n\t    @Test\n\t    public void mockTest() {\n\t\n\t        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n\t    }\n\t}\n\n可以发现**IMathUtils**是一个接口，根本就没有实现，用**Mockito**框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！**Mockito代理了IMathUtils.abs(num)的行为**，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法**when...thenReturn...**相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\n\tpublic class MockTest {\n\n        @Mock\n        IMathUtils iMathUtils ; \n\n        @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n        @Test\n        public void mockTest()  {\n            when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n        }\n\t}\n\n其中**@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();** 用于初始化Mock对象，效果与在类前添加**@RunWith(MockitoJUnitRunner.class)**标签类似\n\n**Mock配置**\n\nMock有多种配置方式，如下所示：\n\t\t\n\t@Test\n\tpublic void test1()  {\n\t        //  创建 mock\n\t        MyClass test = Mockito.mock(MyClass.class);\n\n        // 自定义 getUniqueId() 的返回值\n        when(test.getUniqueId()).thenReturn(43);\n\n        // 在测试中使用mock对象\n        assertEquals(test.getUniqueId(), 43);\n\t}\n\t\n\t// 返回多个值\n\t@Test\n\tpublic void testMoreThanOneReturnValue()  {\n\t        Iterator i= mock(Iterator.class);\n\t        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n\t        String result=i.next()+\" \"+i.next();\n\t        // 断言\n\t        assertEquals(\"Mockito rocks\", result);\n\t}\n\t\n\t// 如何根据输入来返回值\n\t@Test\n\tpublic void testReturnValueDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(\"Mockito\")).thenReturn(1);\n\t        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n\t        // 断言\n\t        assertEquals(1,c.compareTo(\"Mockito\"));\n\t}\n\t\n\t// 如何让返回值不依赖于输入\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(anyInt())).thenReturn(-1);\n\t        // 断言\n\t        assertEquals(-1 ,c.compareTo(9));\n\t}\n\t\n\t// 根据参数类型来返回值\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n\t        // 断言\n\t        Todo todo = new Todo(5);\n\t        assertEquals(todo ,c.compareTo(new Todo(1)));\n\t}\n\t\n更多配置可以看下这个网站  [点击链接](http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html)\n\n\n### UI测试\n\n#### 简介\n\tUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n\n#### 使用方式\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\n\ttestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\n\ttestCompile 'com.android.support.test:runner:0.4.1'\n\n2.在androidTest目录下创建测试类\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png)\n\n3.被测试类（即activity之类的展示界面）\nMainActivity.class\n\t\n\tpublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n\t    private EditText mEt;\n\t    private TextView mTv;\n\t    private Button mBtn;\n\t\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t\n\t        mEt = (EditText) findViewById(R.id.et);\n\t        mTv = (TextView) findViewById(R.id.tv);\n\t        mBtn = (Button) findViewById(R.id.btn);\n\t\n\t        mBtn.setOnClickListener(this);\n\t    }\n\t\n\t    @Override\n\t    public void onClick(View v) {\n\t        mTv.setText(mEt.getText().toString());\n\t    }\n\t}\n\nactivity_main.xml\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n\t    xmlns:tools=\"http://schemas.android.com/tools\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n    <TextView\n        android:id=\"@+id/tv\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"15dp\"\n        android:padding=\"10dp\"\n        android:text=\"helo\" />\n\n    <EditText\n        android:id=\"@+id/et\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"40dp\"\n        android:layout_alignParentLeft=\"true\"\n        android:layout_alignParentStart=\"true\"\n        android:layout_alignParentTop=\"true\"\n        android:layout_marginTop=\"75dp\" />\n\n    <Button\n        android:id=\"@+id/btn\"\n        android:layout_width=\"80dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/et\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginTop=\"49dp\"\n        android:text=\"sure\" />\n\t</RelativeLayout>\n\n测试类\nExampleInstrumentedTest.class\n\n\t@RunWith(AndroidJUnit4.class)\n\tpublic class ExampleInstrumentedTest {\n\t    @Rule\n\t    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n\t            MainActivity.class);\n\n\t    @Test\n\t    public void useAppContext() throws Exception {\n\t        // Context of the app under test.\n\t        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n\t                closeSoftKeyboard());\n\t        onView(withId(R.id.btn)).perform(click());\n\t    }\n\t}\n其中**onView(withId(R.id.et)).perform(typeText(\"helo world\"), closeSoftKeyboard());**选择界面中的输入框，并输入“helo world”，**onView(withId(R.id.btn)).perform(click());**选择界面中的按钮并点击。\n\n[更多操作方式-1](https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md)        \n[更多操作方式-2](http://blog.csdn.net/eclipsexys/article/details/45622813)\n\n#### 标签解析\n\n\t@Rule: 应用于成员变量\n\t@ClassRule: 应用于测试类中的静态变量\n\t两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\t\t\n\t@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n\n\n### 总结\n\t总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\nAndroid自动化测试\n\nenter image description here\n\nAndroid自动化测试\n摘要\nMonkey测试\n简介\n使用方式\n效果展示\n更多参数介绍\n可能会遇到的问题\n单元测试\n简介\n使用方式\nJunit标签解析\nMockito使用方式\nUI测试\n简介\n使用方式\n标签解析\n总结\n摘要\n\nAndroid自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\nMonkey测试\n\n简介\n\nMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n使用方式\n\n（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n效果展示\n\n部分输出数据如下所示：\n\n输出数据\n\n更多参数介绍\n\n点击查看\n\n可能会遇到的问题\n\n（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n点击查看解决方案\n\n单元测试\n\n简介\n\n单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n使用方式\n\n首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile 'junit:junit:4.12'\n}\n而后在test文件下写单元测试类\n\nenter image description here\n\n被测试类如下\n\npublic class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n单元测试类如下\n\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n最后运行单元测试类，结果如下：\n\nenter image description here\n\nJunit标签解析\n\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n以如下代码为例：\n\npublic class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(\"@Before\");\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(\"@After\");\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(\"@AfterClass\");\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(\"@BeforeClass\");\n    }\n}\n相应的执行顺序如下：\n\nenter image description here\n\nMockito使用方式\n\n简介：\n\nMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n先体验以下Mockito的使用：\n\n1.添加依赖\n\ntestCompile 'org.mockito:mockito-core:2.8.47'\n2.被依赖类\n\npublic interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n3.依赖类\n\n@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\npublic class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似\n\nMock配置\n\nMock有多种配置方式，如下所示：\n\n@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n        String result=i.next()+\" \"+i.next();\n        // 断言\n        assertEquals(\"Mockito rocks\", result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(\"Mockito\")).thenReturn(1);\n        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(\"Mockito\"));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n更多配置可以看下这个网站 点击链接\n\nUI测试\n\n简介\n\nUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n使用方式\n\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\ntestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\ntestCompile 'com.android.support.test:runner:0.4.1'\n2.在androidTest目录下创建测试类\n\nenter image description here\n\n3.被测试类（即activity之类的展示界面） \nMainActivity.class\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\nactivity_main.xml\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<TextView\n    android:id=\"@+id/tv\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_marginTop=\"15dp\"\n    android:padding=\"10dp\"\n    android:text=\"helo\" />\n\n<EditText\n    android:id=\"@+id/et\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"40dp\"\n    android:layout_alignParentLeft=\"true\"\n    android:layout_alignParentStart=\"true\"\n    android:layout_alignParentTop=\"true\"\n    android:layout_marginTop=\"75dp\" />\n\n<Button\n    android:id=\"@+id/btn\"\n    android:layout_width=\"80dp\"\n    android:layout_height=\"wrap_content\"\n    android:layout_below=\"@+id/et\"\n    android:layout_centerHorizontal=\"true\"\n    android:layout_marginTop=\"49dp\"\n    android:text=\"sure\" />\n</RelativeLayout>\n测试类 \nExampleInstrumentedTest.class\n\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。\n\n更多操作方式-1 \n更多操作方式-2\n\n标签解析\n\n@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n总结\n\n总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n     7539 \nqqq2830\n 退出账号\n当前文档\n 恢复至上次同步状态\n 删除文档\n 导出...\n 预览文档\n 分享链接\n系统\n 设置\n 使用说明\n 快捷帮助\n 常见问题\n 关于\n\n搜索文件\n杂物 Android自动化测试 \n杂物 SwipeToLoadLayout \n检查Evernote中的笔记版本\n\n","source":"_posts/Android自动化测试.md","raw":"---\ntitle: Android自动化测试\ndate: 2016-06-01 23:47:44\ncategories: \"Android基础学习\"\ntags:\n     - Android\n     - 测试\n     - 技术\n---\n\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg)\n\n\n\n-----------------\n\n    \n\n### 摘要\n    Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n\n### Monkey测试\n\n#### 简介\n\tMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n\n#### 使用方式\n\t（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n\t（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n\t（3）Monkey 命令启动方式：  \n\t  \n\t    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n\t    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n\t    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n\t\n#### 效果展示\n部分输出数据如下所示：\n![输出数据](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png)\n\n#### 更多参数介绍\n[点击查看](http://blog.csdn.net/linghu_java/article/details/6732895)\n\t\t\n#### 可能会遇到的问题\n\t（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n[点击查看解决方案](http://www.cnblogs.com/dwf07223/p/3228047.html)\n\n\n### 单元测试\n\t\n#### 简介\n\t单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n\n#### 使用方式\n\t首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\t\n\tdependencies {\n\t    testCompile 'junit:junit:4.12'\n    }\n\n而后在test文件下写单元测试类\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png)\n\n被测试类如下\n\n\tpublic class Calculator {\n\t    public static int add(int a, int b) {\n\t        return a + b;\n\t    }\n\t}\n\n单元测试类如下\n\n\tpublic class ExampleUnitTest {\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        assertEquals(4, Calculator.add(2,2));\n\t    }\n\t}\n\n最后运行单元测试类，结果如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png)\n\t\n#### Junit标签解析\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n\t@Test： 将方法（函数）标记为测试用例\n\t@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n\t@After： 每一个使用@Test标记的方法运行之后都要运行一次\n\t@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n\t@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n\n以如下代码为例：\n\t\n\tpublic class ExampleUnitTest {\n\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t\n\t    @Test\n\t    public void addition_isErr() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t    @Before\n\t    public void before() throws Exception {\n\t        System.out.println(\"@Before\");\n\t    }\n\t\n\t    @After\n\t    public void after() throws Exception {\n\t        System.out.println(\"@After\");\n\t    }\n\t\n\t\n\t    @AfterClass\n\t    public static void afterClass() throws Exception {\n\t        System.out.println(\"@AfterClass\");\n\t    }\n\t\n\t    @BeforeClass\n\t    public static void beforeClass() throws Exception {\n\t        System.out.println(\"@BeforeClass\");\n\t    }\n\t}\n\t\n相应的执行顺序如下：\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png)\n\n#### Mockito使用方式\n\n简介：\n\t\t\n\tMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n\n**先体验以下Mockito的使用：**\n\n1.添加依赖\n\n\ttestCompile 'org.mockito:mockito-core:2.8.47'\n\n2.被依赖类\n\t\n\tpublic interface IMathUtils {\n\t    public int abs(int num); // 求绝对值\n\t}\n\t\n3.依赖类\n\n\t@RunWith(MockitoJUnitRunner.class)\n\tpublic class MockTest {\n\t    @Mock\n\t    IMathUtils mathUtils;\n\t\n\t    @Test\n\t    public void mockTest() {\n\t\n\t        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n\t    }\n\t}\n\n可以发现**IMathUtils**是一个接口，根本就没有实现，用**Mockito**框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！**Mockito代理了IMathUtils.abs(num)的行为**，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法**when...thenReturn...**相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\n\tpublic class MockTest {\n\n        @Mock\n        IMathUtils iMathUtils ; \n\n        @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n        @Test\n        public void mockTest()  {\n            when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n        }\n\t}\n\n其中**@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();** 用于初始化Mock对象，效果与在类前添加**@RunWith(MockitoJUnitRunner.class)**标签类似\n\n**Mock配置**\n\nMock有多种配置方式，如下所示：\n\t\t\n\t@Test\n\tpublic void test1()  {\n\t        //  创建 mock\n\t        MyClass test = Mockito.mock(MyClass.class);\n\n        // 自定义 getUniqueId() 的返回值\n        when(test.getUniqueId()).thenReturn(43);\n\n        // 在测试中使用mock对象\n        assertEquals(test.getUniqueId(), 43);\n\t}\n\t\n\t// 返回多个值\n\t@Test\n\tpublic void testMoreThanOneReturnValue()  {\n\t        Iterator i= mock(Iterator.class);\n\t        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n\t        String result=i.next()+\" \"+i.next();\n\t        // 断言\n\t        assertEquals(\"Mockito rocks\", result);\n\t}\n\t\n\t// 如何根据输入来返回值\n\t@Test\n\tpublic void testReturnValueDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(\"Mockito\")).thenReturn(1);\n\t        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n\t        // 断言\n\t        assertEquals(1,c.compareTo(\"Mockito\"));\n\t}\n\t\n\t// 如何让返回值不依赖于输入\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(anyInt())).thenReturn(-1);\n\t        // 断言\n\t        assertEquals(-1 ,c.compareTo(9));\n\t}\n\t\n\t// 根据参数类型来返回值\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n\t        // 断言\n\t        Todo todo = new Todo(5);\n\t        assertEquals(todo ,c.compareTo(new Todo(1)));\n\t}\n\t\n更多配置可以看下这个网站  [点击链接](http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html)\n\n\n### UI测试\n\n#### 简介\n\tUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n\n#### 使用方式\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\n\ttestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\n\ttestCompile 'com.android.support.test:runner:0.4.1'\n\n2.在androidTest目录下创建测试类\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png)\n\n3.被测试类（即activity之类的展示界面）\nMainActivity.class\n\t\n\tpublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n\t    private EditText mEt;\n\t    private TextView mTv;\n\t    private Button mBtn;\n\t\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t\n\t        mEt = (EditText) findViewById(R.id.et);\n\t        mTv = (TextView) findViewById(R.id.tv);\n\t        mBtn = (Button) findViewById(R.id.btn);\n\t\n\t        mBtn.setOnClickListener(this);\n\t    }\n\t\n\t    @Override\n\t    public void onClick(View v) {\n\t        mTv.setText(mEt.getText().toString());\n\t    }\n\t}\n\nactivity_main.xml\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n\t    xmlns:tools=\"http://schemas.android.com/tools\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n    <TextView\n        android:id=\"@+id/tv\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"15dp\"\n        android:padding=\"10dp\"\n        android:text=\"helo\" />\n\n    <EditText\n        android:id=\"@+id/et\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"40dp\"\n        android:layout_alignParentLeft=\"true\"\n        android:layout_alignParentStart=\"true\"\n        android:layout_alignParentTop=\"true\"\n        android:layout_marginTop=\"75dp\" />\n\n    <Button\n        android:id=\"@+id/btn\"\n        android:layout_width=\"80dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/et\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginTop=\"49dp\"\n        android:text=\"sure\" />\n\t</RelativeLayout>\n\n测试类\nExampleInstrumentedTest.class\n\n\t@RunWith(AndroidJUnit4.class)\n\tpublic class ExampleInstrumentedTest {\n\t    @Rule\n\t    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n\t            MainActivity.class);\n\n\t    @Test\n\t    public void useAppContext() throws Exception {\n\t        // Context of the app under test.\n\t        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n\t                closeSoftKeyboard());\n\t        onView(withId(R.id.btn)).perform(click());\n\t    }\n\t}\n其中**onView(withId(R.id.et)).perform(typeText(\"helo world\"), closeSoftKeyboard());**选择界面中的输入框，并输入“helo world”，**onView(withId(R.id.btn)).perform(click());**选择界面中的按钮并点击。\n\n[更多操作方式-1](https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md)        \n[更多操作方式-2](http://blog.csdn.net/eclipsexys/article/details/45622813)\n\n#### 标签解析\n\n\t@Rule: 应用于成员变量\n\t@ClassRule: 应用于测试类中的静态变量\n\t两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\t\t\n\t@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n\n\n### 总结\n\t总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\nAndroid自动化测试\n\nenter image description here\n\nAndroid自动化测试\n摘要\nMonkey测试\n简介\n使用方式\n效果展示\n更多参数介绍\n可能会遇到的问题\n单元测试\n简介\n使用方式\nJunit标签解析\nMockito使用方式\nUI测试\n简介\n使用方式\n标签解析\n总结\n摘要\n\nAndroid自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\nMonkey测试\n\n简介\n\nMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n使用方式\n\n（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n效果展示\n\n部分输出数据如下所示：\n\n输出数据\n\n更多参数介绍\n\n点击查看\n\n可能会遇到的问题\n\n（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n点击查看解决方案\n\n单元测试\n\n简介\n\n单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n使用方式\n\n首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile 'junit:junit:4.12'\n}\n而后在test文件下写单元测试类\n\nenter image description here\n\n被测试类如下\n\npublic class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n单元测试类如下\n\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n最后运行单元测试类，结果如下：\n\nenter image description here\n\nJunit标签解析\n\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n以如下代码为例：\n\npublic class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(\"@Before\");\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(\"@After\");\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(\"@AfterClass\");\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(\"@BeforeClass\");\n    }\n}\n相应的执行顺序如下：\n\nenter image description here\n\nMockito使用方式\n\n简介：\n\nMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n先体验以下Mockito的使用：\n\n1.添加依赖\n\ntestCompile 'org.mockito:mockito-core:2.8.47'\n2.被依赖类\n\npublic interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n3.依赖类\n\n@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\npublic class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似\n\nMock配置\n\nMock有多种配置方式，如下所示：\n\n@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n        String result=i.next()+\" \"+i.next();\n        // 断言\n        assertEquals(\"Mockito rocks\", result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(\"Mockito\")).thenReturn(1);\n        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(\"Mockito\"));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n更多配置可以看下这个网站 点击链接\n\nUI测试\n\n简介\n\nUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n使用方式\n\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\ntestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\ntestCompile 'com.android.support.test:runner:0.4.1'\n2.在androidTest目录下创建测试类\n\nenter image description here\n\n3.被测试类（即activity之类的展示界面） \nMainActivity.class\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\nactivity_main.xml\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<TextView\n    android:id=\"@+id/tv\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_marginTop=\"15dp\"\n    android:padding=\"10dp\"\n    android:text=\"helo\" />\n\n<EditText\n    android:id=\"@+id/et\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"40dp\"\n    android:layout_alignParentLeft=\"true\"\n    android:layout_alignParentStart=\"true\"\n    android:layout_alignParentTop=\"true\"\n    android:layout_marginTop=\"75dp\" />\n\n<Button\n    android:id=\"@+id/btn\"\n    android:layout_width=\"80dp\"\n    android:layout_height=\"wrap_content\"\n    android:layout_below=\"@+id/et\"\n    android:layout_centerHorizontal=\"true\"\n    android:layout_marginTop=\"49dp\"\n    android:text=\"sure\" />\n</RelativeLayout>\n测试类 \nExampleInstrumentedTest.class\n\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。\n\n更多操作方式-1 \n更多操作方式-2\n\n标签解析\n\n@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n总结\n\n总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n     7539 \nqqq2830\n 退出账号\n当前文档\n 恢复至上次同步状态\n 删除文档\n 导出...\n 预览文档\n 分享链接\n系统\n 设置\n 使用说明\n 快捷帮助\n 常见问题\n 关于\n\n搜索文件\n杂物 Android自动化测试 \n杂物 SwipeToLoadLayout \n检查Evernote中的笔记版本\n\n","slug":"Android自动化测试","published":1,"updated":"2018-02-06T03:41:16.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdfnt20g0000j0ie68obd3cl","content":"<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg\" alt=\"enter image description here\"></p>\n<hr>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><pre><code>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n</code></pre><h3 id=\"Monkey测试\"><a href=\"#Monkey测试\" class=\"headerlink\" title=\"Monkey测试\"></a>Monkey测试</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n</code></pre><h4 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><h4 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h4><p>部分输出数据如下所示：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png\" alt=\"输出数据\"></p>\n<h4 id=\"更多参数介绍\"><a href=\"#更多参数介绍\" class=\"headerlink\" title=\"更多参数介绍\"></a>更多参数介绍</h4><p><a href=\"http://blog.csdn.net/linghu_java/article/details/6732895\" target=\"_blank\" rel=\"noopener\">点击查看</a></p>\n<h4 id=\"可能会遇到的问题\"><a href=\"#可能会遇到的问题\" class=\"headerlink\" title=\"可能会遇到的问题\"></a>可能会遇到的问题</h4><pre><code>（1）“&apos;adb&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n</code></pre><p><a href=\"http://www.cnblogs.com/dwf07223/p/3228047.html\" target=\"_blank\" rel=\"noopener\">点击查看解决方案</a></p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n</code></pre><h4 id=\"使用方式-1\"><a href=\"#使用方式-1\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile &apos;junit:junit:4.12&apos;\n}\n</code></pre><p>而后在test文件下写单元测试类<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png\" alt=\"enter image description here\"></p>\n<p>被测试类如下</p>\n<pre><code>public class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n</code></pre><p>单元测试类如下</p>\n<pre><code>public class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n</code></pre><p>最后运行单元测试类，结果如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Junit标签解析\"><a href=\"#Junit标签解析\" class=\"headerlink\" title=\"Junit标签解析\"></a>Junit标签解析</h4><p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<pre><code>@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n</code></pre><p>以如下代码为例：</p>\n<pre><code>public class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(&quot;@Before&quot;);\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(&quot;@After&quot;);\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(&quot;@AfterClass&quot;);\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(&quot;@BeforeClass&quot;);\n    }\n}\n</code></pre><p>相应的执行顺序如下：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Mockito使用方式\"><a href=\"#Mockito使用方式\" class=\"headerlink\" title=\"Mockito使用方式\"></a>Mockito使用方式</h4><p>简介：</p>\n<pre><code>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n</code></pre><p><strong>先体验以下Mockito的使用：</strong></p>\n<p>1.添加依赖</p>\n<pre><code>testCompile &apos;org.mockito:mockito-core:2.8.47&apos;\n</code></pre><p>2.被依赖类</p>\n<pre><code>public interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n</code></pre><p>3.依赖类</p>\n<pre><code>@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>可以发现<strong>IMathUtils</strong>是一个接口，根本就没有实现，用<strong>Mockito</strong>框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！<strong>Mockito代理了IMathUtils.abs(num)的行为</strong>，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法<strong>when…thenReturn…</strong>相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<pre><code>public class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>其中<strong>@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();</strong> 用于初始化Mock对象，效果与在类前添加<strong>@RunWith(MockitoJUnitRunner.class)</strong>标签类似</p>\n<p><strong>Mock配置</strong></p>\n<p>Mock有多种配置方式，如下所示：</p>\n<pre><code>@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);\n        String result=i.next()+&quot; &quot;+i.next();\n        // 断言\n        assertEquals(&quot;Mockito rocks&quot;, result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);\n        when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(&quot;Mockito&quot;));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n</code></pre><p>更多配置可以看下这个网站  <a href=\"http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html\" target=\"_blank\" rel=\"noopener\">点击链接</a></p>\n<h3 id=\"UI测试\"><a href=\"#UI测试\" class=\"headerlink\" title=\"UI测试\"></a>UI测试</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n</code></pre><h4 id=\"使用方式-2\"><a href=\"#使用方式-2\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<pre><code>testCompile &apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;\ntestCompile &apos;com.android.support.test:runner:0.4.1&apos;\n</code></pre><p>2.在androidTest目录下创建测试类</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png\" alt=\"enter image description here\"></p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\n</code></pre><p>activity_main.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    tools:context=&quot;xgn.com.androidautotest.MainActivity&quot;&gt;\n\n&lt;TextView\n    android:id=&quot;@+id/tv&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_marginTop=&quot;15dp&quot;\n    android:padding=&quot;10dp&quot;\n    android:text=&quot;helo&quot; /&gt;\n\n&lt;EditText\n    android:id=&quot;@+id/et&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;40dp&quot;\n    android:layout_alignParentLeft=&quot;true&quot;\n    android:layout_alignParentStart=&quot;true&quot;\n    android:layout_alignParentTop=&quot;true&quot;\n    android:layout_marginTop=&quot;75dp&quot; /&gt;\n\n&lt;Button\n    android:id=&quot;@+id/btn&quot;\n    android:layout_width=&quot;80dp&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_below=&quot;@+id/et&quot;\n    android:layout_centerHorizontal=&quot;true&quot;\n    android:layout_marginTop=&quot;49dp&quot;\n    android:text=&quot;sure&quot; /&gt;\n&lt;/RelativeLayout&gt;\n</code></pre><p>测试类<br>ExampleInstrumentedTest.class</p>\n<pre><code>@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n</code></pre><p>其中<strong>onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());</strong>选择界面中的输入框，并输入“helo world”，<strong>onView(withId(R.id.btn)).perform(click());</strong>选择界面中的按钮并点击。</p>\n<p><a href=\"https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md\" target=\"_blank\" rel=\"noopener\">更多操作方式-1</a><br><a href=\"http://blog.csdn.net/eclipsexys/article/details/45622813\" target=\"_blank\" rel=\"noopener\">更多操作方式-2</a></p>\n<h4 id=\"标签解析\"><a href=\"#标签解析\" class=\"headerlink\" title=\"标签解析\"></a>标签解析</h4><pre><code>@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n</code></pre><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n</code></pre><p>Android自动化测试</p>\n<p>enter image description here</p>\n<p>Android自动化测试<br>摘要<br>Monkey测试<br>简介<br>使用方式<br>效果展示<br>更多参数介绍<br>可能会遇到的问题<br>单元测试<br>简介<br>使用方式<br>Junit标签解析<br>Mockito使用方式<br>UI测试<br>简介<br>使用方式<br>标签解析<br>总结<br>摘要</p>\n<p>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。<br>Monkey测试</p>\n<p>简介</p>\n<p>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。<br>使用方式</p>\n<p>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；<br>（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；<br>（3）Monkey 命令启动方式：  </p>\n<pre><code>- 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n- 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n- 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><p>效果展示</p>\n<p>部分输出数据如下所示：</p>\n<p>输出数据</p>\n<p>更多参数介绍</p>\n<p>点击查看</p>\n<p>可能会遇到的问题</p>\n<p>（1）“’adb’ 不是内部或外部命令，也不是可运行的程序或批处理文件。”<br>点击查看解决方案</p>\n<p>单元测试</p>\n<p>简介</p>\n<p>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。<br>使用方式</p>\n<p>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：</p>\n<p>dependencies {<br>    testCompile ‘junit:junit:4.12’<br>}<br>而后在test文件下写单元测试类</p>\n<p>enter image description here</p>\n<p>被测试类如下</p>\n<p>public class Calculator {<br>    public static int add(int a, int b) {<br>        return a + b;<br>    }<br>}<br>单元测试类如下</p>\n<p>public class ExampleUnitTest {<br>    @Test<br>    public void addition_isCorrect() throws Exception {<br>        assertEquals(4, Calculator.add(2,2));<br>    }<br>}<br>最后运行单元测试类，结果如下：</p>\n<p>enter image description here</p>\n<p>Junit标签解析</p>\n<p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<p>@Test： 将方法（函数）标记为测试用例<br>@Before： 每一个使用@Test标记的方法运行之前都要运行一次<br>@After： 每一个使用@Test标记的方法运行之后都要运行一次<br>@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次<br>@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次<br>以如下代码为例：</p>\n<p>public class ExampleUnitTest {</p>\n<pre><code>@Test\npublic void addition_isCorrect() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n\n@Test\npublic void addition_isErr() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n@Before\npublic void before() throws Exception {\n    System.out.println(&quot;@Before&quot;);\n}\n\n@After\npublic void after() throws Exception {\n    System.out.println(&quot;@After&quot;);\n}\n\n\n@AfterClass\npublic static void afterClass() throws Exception {\n    System.out.println(&quot;@AfterClass&quot;);\n}\n\n@BeforeClass\npublic static void beforeClass() throws Exception {\n    System.out.println(&quot;@BeforeClass&quot;);\n}\n</code></pre><p>}<br>相应的执行顺序如下：</p>\n<p>enter image description here</p>\n<p>Mockito使用方式</p>\n<p>简介：</p>\n<p>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。<br>先体验以下Mockito的使用：</p>\n<p>1.添加依赖</p>\n<p>testCompile ‘org.mockito:mockito-core:2.8.47’<br>2.被依赖类</p>\n<p>public interface IMathUtils {<br>    public int abs(int num); // 求绝对值<br>}<br>3.依赖类</p>\n<p>@RunWith(MockitoJUnitRunner.class)<br>public class MockTest {<br>    @Mock<br>    IMathUtils mathUtils;</p>\n<pre><code>@Test\npublic void mockTest() {\n\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<p>public class MockTest {</p>\n<pre><code>@Mock\nIMathUtils iMathUtils ; \n\n@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n@Test\npublic void mockTest()  {\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似</p>\n<p>Mock配置</p>\n<p>Mock有多种配置方式，如下所示：</p>\n<p>@Test<br>public void test1()  {<br>        //  创建 mock<br>        MyClass test = Mockito.mock(MyClass.class);</p>\n<pre><code>// 自定义 getUniqueId() 的返回值\nwhen(test.getUniqueId()).thenReturn(43);\n\n// 在测试中使用mock对象\nassertEquals(test.getUniqueId(), 43);\n</code></pre><p>}</p>\n<p>// 返回多个值<br>@Test<br>public void testMoreThanOneReturnValue()  {<br>        Iterator i= mock(Iterator.class);<br>        when(i.next()).thenReturn(“Mockito”).thenReturn(“rocks”);<br>        String result=i.next()+” “+i.next();<br>        // 断言<br>        assertEquals(“Mockito rocks”, result);<br>}</p>\n<p>// 如何根据输入来返回值<br>@Test<br>public void testReturnValueDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(“Mockito”)).thenReturn(1);<br>        when(c.compareTo(“Eclipse”)).thenReturn(2);<br>        // 断言<br>        assertEquals(1,c.compareTo(“Mockito”));<br>}</p>\n<p>// 如何让返回值不依赖于输入<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(anyInt())).thenReturn(-1);<br>        // 断言<br>        assertEquals(-1 ,c.compareTo(9));<br>}</p>\n<p>// 根据参数类型来返回值<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(isA(Todo.class))).thenReturn(0);<br>        // 断言<br>        Todo todo = new Todo(5);<br>        assertEquals(todo ,c.compareTo(new Todo(1)));<br>}<br>更多配置可以看下这个网站 点击链接</p>\n<p>UI测试</p>\n<p>简介</p>\n<p>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。<br>使用方式</p>\n<p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<p>testCompile ‘com.android.support.test.espresso:espresso-core:2.2.2’<br>testCompile ‘com.android.support.test:runner:0.4.1’<br>2.在androidTest目录下创建测试类</p>\n<p>enter image description here</p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<p>public class MainActivity extends AppCompatActivity implements View.OnClickListener{</p>\n<pre><code>private EditText mEt;\nprivate TextView mTv;\nprivate Button mBtn;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    mEt = (EditText) findViewById(R.id.et);\n    mTv = (TextView) findViewById(R.id.tv);\n    mBtn = (Button) findViewById(R.id.btn);\n\n    mBtn.setOnClickListener(this);\n}\n\n@Override\npublic void onClick(View v) {\n    mTv.setText(mEt.getText().toString());\n}\n</code></pre><p>}<br>activity_main.xml</p>\n<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>\n<relativelayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<textview android:id=\"@+id/tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margintop=\"15dp\" android:padding=\"10dp\" android:text=\"helo\">\n\n<edittext android:id=\"@+id/et\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:layout_alignparentleft=\"true\" android:layout_alignparentstart=\"true\" android:layout_alignparenttop=\"true\" android:layout_margintop=\"75dp\">\n\n<p><button android:id=\"@+id/btn\" android:layout_width=\"80dp\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/et\" android:layout_centerhorizontal=\"true\" android:layout_margintop=\"49dp\" android:text=\"sure\"><br></button></p></edittext></textview></relativelayout><br>测试类<br>ExampleInstrumentedTest.class<p></p>\n<p>@RunWith(AndroidJUnit4.class)<br>public class ExampleInstrumentedTest {<br>    @Rule<br>    public ActivityTestRule<mainactivity> mActivityRule = new ActivityTestRule&lt;&gt;(<br>            MainActivity.class);</mainactivity></p>\n<pre><code>@Test\npublic void useAppContext() throws Exception {\n    // Context of the app under test.\n    onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n            closeSoftKeyboard());\n    onView(withId(R.id.btn)).perform(click());\n}\n</code></pre><p>}<br>其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。</p>\n<p>更多操作方式-1<br>更多操作方式-2</p>\n<p>标签解析</p>\n<p>@Rule: 应用于成员变量<br>@ClassRule: 应用于测试类中的静态变量<br>两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。</p>\n<p>@RunWith（AndroidJUnit4.class）：  用于修改测试运行器<br>总结</p>\n<p>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。<br>     7539<br>qqq2830<br> 退出账号<br>当前文档<br> 恢复至上次同步状态<br> 删除文档<br> 导出…<br> 预览文档<br> 分享链接<br>系统<br> 设置<br> 使用说明<br> 快捷帮助<br> 常见问题<br> 关于</p>\n<p>搜索文件<br>杂物 Android自动化测试<br>杂物 SwipeToLoadLayout<br>检查Evernote中的笔记版本</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg\" alt=\"enter image description here\"></p>\n<hr>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><pre><code>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n</code></pre><h3 id=\"Monkey测试\"><a href=\"#Monkey测试\" class=\"headerlink\" title=\"Monkey测试\"></a>Monkey测试</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n</code></pre><h4 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><h4 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h4><p>部分输出数据如下所示：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png\" alt=\"输出数据\"></p>\n<h4 id=\"更多参数介绍\"><a href=\"#更多参数介绍\" class=\"headerlink\" title=\"更多参数介绍\"></a>更多参数介绍</h4><p><a href=\"http://blog.csdn.net/linghu_java/article/details/6732895\" target=\"_blank\" rel=\"noopener\">点击查看</a></p>\n<h4 id=\"可能会遇到的问题\"><a href=\"#可能会遇到的问题\" class=\"headerlink\" title=\"可能会遇到的问题\"></a>可能会遇到的问题</h4><pre><code>（1）“&apos;adb&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n</code></pre><p><a href=\"http://www.cnblogs.com/dwf07223/p/3228047.html\" target=\"_blank\" rel=\"noopener\">点击查看解决方案</a></p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n</code></pre><h4 id=\"使用方式-1\"><a href=\"#使用方式-1\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile &apos;junit:junit:4.12&apos;\n}\n</code></pre><p>而后在test文件下写单元测试类<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png\" alt=\"enter image description here\"></p>\n<p>被测试类如下</p>\n<pre><code>public class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n</code></pre><p>单元测试类如下</p>\n<pre><code>public class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n</code></pre><p>最后运行单元测试类，结果如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Junit标签解析\"><a href=\"#Junit标签解析\" class=\"headerlink\" title=\"Junit标签解析\"></a>Junit标签解析</h4><p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<pre><code>@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n</code></pre><p>以如下代码为例：</p>\n<pre><code>public class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(&quot;@Before&quot;);\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(&quot;@After&quot;);\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(&quot;@AfterClass&quot;);\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(&quot;@BeforeClass&quot;);\n    }\n}\n</code></pre><p>相应的执行顺序如下：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Mockito使用方式\"><a href=\"#Mockito使用方式\" class=\"headerlink\" title=\"Mockito使用方式\"></a>Mockito使用方式</h4><p>简介：</p>\n<pre><code>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n</code></pre><p><strong>先体验以下Mockito的使用：</strong></p>\n<p>1.添加依赖</p>\n<pre><code>testCompile &apos;org.mockito:mockito-core:2.8.47&apos;\n</code></pre><p>2.被依赖类</p>\n<pre><code>public interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n</code></pre><p>3.依赖类</p>\n<pre><code>@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>可以发现<strong>IMathUtils</strong>是一个接口，根本就没有实现，用<strong>Mockito</strong>框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！<strong>Mockito代理了IMathUtils.abs(num)的行为</strong>，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法<strong>when…thenReturn…</strong>相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<pre><code>public class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>其中<strong>@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();</strong> 用于初始化Mock对象，效果与在类前添加<strong>@RunWith(MockitoJUnitRunner.class)</strong>标签类似</p>\n<p><strong>Mock配置</strong></p>\n<p>Mock有多种配置方式，如下所示：</p>\n<pre><code>@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);\n        String result=i.next()+&quot; &quot;+i.next();\n        // 断言\n        assertEquals(&quot;Mockito rocks&quot;, result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);\n        when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(&quot;Mockito&quot;));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n</code></pre><p>更多配置可以看下这个网站  <a href=\"http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html\" target=\"_blank\" rel=\"noopener\">点击链接</a></p>\n<h3 id=\"UI测试\"><a href=\"#UI测试\" class=\"headerlink\" title=\"UI测试\"></a>UI测试</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n</code></pre><h4 id=\"使用方式-2\"><a href=\"#使用方式-2\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<pre><code>testCompile &apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;\ntestCompile &apos;com.android.support.test:runner:0.4.1&apos;\n</code></pre><p>2.在androidTest目录下创建测试类</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png\" alt=\"enter image description here\"></p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\n</code></pre><p>activity_main.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    tools:context=&quot;xgn.com.androidautotest.MainActivity&quot;&gt;\n\n&lt;TextView\n    android:id=&quot;@+id/tv&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_marginTop=&quot;15dp&quot;\n    android:padding=&quot;10dp&quot;\n    android:text=&quot;helo&quot; /&gt;\n\n&lt;EditText\n    android:id=&quot;@+id/et&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;40dp&quot;\n    android:layout_alignParentLeft=&quot;true&quot;\n    android:layout_alignParentStart=&quot;true&quot;\n    android:layout_alignParentTop=&quot;true&quot;\n    android:layout_marginTop=&quot;75dp&quot; /&gt;\n\n&lt;Button\n    android:id=&quot;@+id/btn&quot;\n    android:layout_width=&quot;80dp&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_below=&quot;@+id/et&quot;\n    android:layout_centerHorizontal=&quot;true&quot;\n    android:layout_marginTop=&quot;49dp&quot;\n    android:text=&quot;sure&quot; /&gt;\n&lt;/RelativeLayout&gt;\n</code></pre><p>测试类<br>ExampleInstrumentedTest.class</p>\n<pre><code>@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n</code></pre><p>其中<strong>onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());</strong>选择界面中的输入框，并输入“helo world”，<strong>onView(withId(R.id.btn)).perform(click());</strong>选择界面中的按钮并点击。</p>\n<p><a href=\"https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md\" target=\"_blank\" rel=\"noopener\">更多操作方式-1</a><br><a href=\"http://blog.csdn.net/eclipsexys/article/details/45622813\" target=\"_blank\" rel=\"noopener\">更多操作方式-2</a></p>\n<h4 id=\"标签解析\"><a href=\"#标签解析\" class=\"headerlink\" title=\"标签解析\"></a>标签解析</h4><pre><code>@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n</code></pre><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n</code></pre><p>Android自动化测试</p>\n<p>enter image description here</p>\n<p>Android自动化测试<br>摘要<br>Monkey测试<br>简介<br>使用方式<br>效果展示<br>更多参数介绍<br>可能会遇到的问题<br>单元测试<br>简介<br>使用方式<br>Junit标签解析<br>Mockito使用方式<br>UI测试<br>简介<br>使用方式<br>标签解析<br>总结<br>摘要</p>\n<p>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。<br>Monkey测试</p>\n<p>简介</p>\n<p>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。<br>使用方式</p>\n<p>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；<br>（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；<br>（3）Monkey 命令启动方式：  </p>\n<pre><code>- 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n- 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n- 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><p>效果展示</p>\n<p>部分输出数据如下所示：</p>\n<p>输出数据</p>\n<p>更多参数介绍</p>\n<p>点击查看</p>\n<p>可能会遇到的问题</p>\n<p>（1）“’adb’ 不是内部或外部命令，也不是可运行的程序或批处理文件。”<br>点击查看解决方案</p>\n<p>单元测试</p>\n<p>简介</p>\n<p>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。<br>使用方式</p>\n<p>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：</p>\n<p>dependencies {<br>    testCompile ‘junit:junit:4.12’<br>}<br>而后在test文件下写单元测试类</p>\n<p>enter image description here</p>\n<p>被测试类如下</p>\n<p>public class Calculator {<br>    public static int add(int a, int b) {<br>        return a + b;<br>    }<br>}<br>单元测试类如下</p>\n<p>public class ExampleUnitTest {<br>    @Test<br>    public void addition_isCorrect() throws Exception {<br>        assertEquals(4, Calculator.add(2,2));<br>    }<br>}<br>最后运行单元测试类，结果如下：</p>\n<p>enter image description here</p>\n<p>Junit标签解析</p>\n<p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<p>@Test： 将方法（函数）标记为测试用例<br>@Before： 每一个使用@Test标记的方法运行之前都要运行一次<br>@After： 每一个使用@Test标记的方法运行之后都要运行一次<br>@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次<br>@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次<br>以如下代码为例：</p>\n<p>public class ExampleUnitTest {</p>\n<pre><code>@Test\npublic void addition_isCorrect() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n\n@Test\npublic void addition_isErr() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n@Before\npublic void before() throws Exception {\n    System.out.println(&quot;@Before&quot;);\n}\n\n@After\npublic void after() throws Exception {\n    System.out.println(&quot;@After&quot;);\n}\n\n\n@AfterClass\npublic static void afterClass() throws Exception {\n    System.out.println(&quot;@AfterClass&quot;);\n}\n\n@BeforeClass\npublic static void beforeClass() throws Exception {\n    System.out.println(&quot;@BeforeClass&quot;);\n}\n</code></pre><p>}<br>相应的执行顺序如下：</p>\n<p>enter image description here</p>\n<p>Mockito使用方式</p>\n<p>简介：</p>\n<p>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。<br>先体验以下Mockito的使用：</p>\n<p>1.添加依赖</p>\n<p>testCompile ‘org.mockito:mockito-core:2.8.47’<br>2.被依赖类</p>\n<p>public interface IMathUtils {<br>    public int abs(int num); // 求绝对值<br>}<br>3.依赖类</p>\n<p>@RunWith(MockitoJUnitRunner.class)<br>public class MockTest {<br>    @Mock<br>    IMathUtils mathUtils;</p>\n<pre><code>@Test\npublic void mockTest() {\n\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<p>public class MockTest {</p>\n<pre><code>@Mock\nIMathUtils iMathUtils ; \n\n@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n@Test\npublic void mockTest()  {\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似</p>\n<p>Mock配置</p>\n<p>Mock有多种配置方式，如下所示：</p>\n<p>@Test<br>public void test1()  {<br>        //  创建 mock<br>        MyClass test = Mockito.mock(MyClass.class);</p>\n<pre><code>// 自定义 getUniqueId() 的返回值\nwhen(test.getUniqueId()).thenReturn(43);\n\n// 在测试中使用mock对象\nassertEquals(test.getUniqueId(), 43);\n</code></pre><p>}</p>\n<p>// 返回多个值<br>@Test<br>public void testMoreThanOneReturnValue()  {<br>        Iterator i= mock(Iterator.class);<br>        when(i.next()).thenReturn(“Mockito”).thenReturn(“rocks”);<br>        String result=i.next()+” “+i.next();<br>        // 断言<br>        assertEquals(“Mockito rocks”, result);<br>}</p>\n<p>// 如何根据输入来返回值<br>@Test<br>public void testReturnValueDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(“Mockito”)).thenReturn(1);<br>        when(c.compareTo(“Eclipse”)).thenReturn(2);<br>        // 断言<br>        assertEquals(1,c.compareTo(“Mockito”));<br>}</p>\n<p>// 如何让返回值不依赖于输入<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(anyInt())).thenReturn(-1);<br>        // 断言<br>        assertEquals(-1 ,c.compareTo(9));<br>}</p>\n<p>// 根据参数类型来返回值<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(isA(Todo.class))).thenReturn(0);<br>        // 断言<br>        Todo todo = new Todo(5);<br>        assertEquals(todo ,c.compareTo(new Todo(1)));<br>}<br>更多配置可以看下这个网站 点击链接</p>\n<p>UI测试</p>\n<p>简介</p>\n<p>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。<br>使用方式</p>\n<p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<p>testCompile ‘com.android.support.test.espresso:espresso-core:2.2.2’<br>testCompile ‘com.android.support.test:runner:0.4.1’<br>2.在androidTest目录下创建测试类</p>\n<p>enter image description here</p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<p>public class MainActivity extends AppCompatActivity implements View.OnClickListener{</p>\n<pre><code>private EditText mEt;\nprivate TextView mTv;\nprivate Button mBtn;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    mEt = (EditText) findViewById(R.id.et);\n    mTv = (TextView) findViewById(R.id.tv);\n    mBtn = (Button) findViewById(R.id.btn);\n\n    mBtn.setOnClickListener(this);\n}\n\n@Override\npublic void onClick(View v) {\n    mTv.setText(mEt.getText().toString());\n}\n</code></pre><p>}<br>activity_main.xml</p>\n<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>\n<relativelayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<textview android:id=\"@+id/tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margintop=\"15dp\" android:padding=\"10dp\" android:text=\"helo\">\n\n<edittext android:id=\"@+id/et\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:layout_alignparentleft=\"true\" android:layout_alignparentstart=\"true\" android:layout_alignparenttop=\"true\" android:layout_margintop=\"75dp\">\n\n<p><button android:id=\"@+id/btn\" android:layout_width=\"80dp\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/et\" android:layout_centerhorizontal=\"true\" android:layout_margintop=\"49dp\" android:text=\"sure\"><br></button></p></edittext></textview></relativelayout><br>测试类<br>ExampleInstrumentedTest.class<p></p>\n<p>@RunWith(AndroidJUnit4.class)<br>public class ExampleInstrumentedTest {<br>    @Rule<br>    public ActivityTestRule<mainactivity> mActivityRule = new ActivityTestRule&lt;&gt;(<br>            MainActivity.class);</mainactivity></p>\n<pre><code>@Test\npublic void useAppContext() throws Exception {\n    // Context of the app under test.\n    onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n            closeSoftKeyboard());\n    onView(withId(R.id.btn)).perform(click());\n}\n</code></pre><p>}<br>其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。</p>\n<p>更多操作方式-1<br>更多操作方式-2</p>\n<p>标签解析</p>\n<p>@Rule: 应用于成员变量<br>@ClassRule: 应用于测试类中的静态变量<br>两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。</p>\n<p>@RunWith（AndroidJUnit4.class）：  用于修改测试运行器<br>总结</p>\n<p>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。<br>     7539<br>qqq2830<br> 退出账号<br>当前文档<br> 恢复至上次同步状态<br> 删除文档<br> 导出…<br> 预览文档<br> 分享链接<br>系统<br> 设置<br> 使用说明<br> 快捷帮助<br> 常见问题<br> 关于</p>\n<p>搜索文件<br>杂物 Android自动化测试<br>杂物 SwipeToLoadLayout<br>检查Evernote中的笔记版本</p>\n"},{"title":"compileSdkVersion, minSdkVersion， targetSdkVersion的关系","date":"2016-06-01T15:47:44.000Z","_content":"\n\n![这里写图片描述](http://img.blog.csdn.net/20161130141617130)\n\n**选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion**\n-----------------------------------------------------------------------\n\n当你将一个App发布出去之后，也许马上Google又发布了一个新的Android版本。那这是否就意味着你发布的App会出现一些版本上的问题。\n\n当然这并不会困扰我们，因为Android是**向前兼容**的---向前兼容即旧版本能够适应新版本的应用---对Android而言就是在旧版上开发的应用当我们将手机的版本升级之后一样可以使用。这就是**compileSdkVersion**,  **minSdkVersion**,  **targetSdkVersion**这三者的由来，它们分别控制可用API的版本号，需要的API版本号和使用何种兼容模式。\n\n**compileSdkVersion**\n-----------------\n通过compileSdkVersion你可以告诉Gradle使用何种SDK版本来编译你的App。当你在代码中使用了一些新的API时，你就需要使用相应新的Android SDK。\n\n需要重点声明的是，**改变compileSdkVersion并不会改变运行时的行为，也就是说当在手机上跑的时候，使用的还是你手机上的SDK**，也就是你手机的Android版本号。当你改变compileSdkVersion时，会报出一些新的编译错误，但是你的compileSdkVersion并不会被包含在你的APK中：它仅仅用在编译期间。（虽然如此，但是你最好修复这些error---因为事出必定有因）\n\n在此**强烈建议你使用最新的SDK进行编译**。对现有代码进行最新SDK的编译检查时，你可以获得的好处是：避免一些在新版本中不赞成使用的API，并且及时使用最新的API。\n\n需要注意的是，当你使用 **Support Library**（兼容库）时，若要使用最新发布的兼容包，那么就必须使用最新版本的SDK进行编译。例：如果在gradle中添加compile 'com.android.support:design:23.0.1'那么相应的就需要将compileSdkVersion设置为23及以上。一般来讲，新版本的兼容库总是伴随新平台版本的发布，为新的API和特性提供兼容。\n\n**minSdkVersion**\n-------------\n如果说compileSdkVersion是设置你可用的最新API，**那么minSdkVersion就是为你的app设置最低门槛**，低于这个门槛就不要装了。Google Play Store通过这个标记来决定你的机子是否可以安装相应的app。\n\n该属性在开发过程中同样有着很重要的作用：默认情况下当你在开发的过程中，IDE可以通过这个标示来提醒你使用的API是否是在这个版本之后发布的，以此来帮助我们避免在运行时调用一些在手机的SDK中不存在的API。能够实现相同功能的是在代码中添加一些检查标示，来检查系统的版本来确定是否调用相应的API。\n\n需要注意的是：当我们使用也许第三方的库时如: **Support Libraries**或者 **Google Play services**这些类型的库，这些库有他们自己相应的minSdkVersion，我们需要确保我们自己app中使用的minSdkVersion必须要大于等于第三方库的minSdkVersion。**当然也存在一些个别情况**，当我们相应使用一个第三方库，该库的minSdkVersion要高于我们app的minSdkVersion，在我们不改变我们app的minSdkVersion前提下，任然想要使用这个第三方库，那么我们需要做的是使用**tools:overrideLibrary** 标示，但是我们必须要进行彻底的测试。以防止意外的发生。\n\n当我们要设定minSdkVersion时，可以到Google Play Store上查看最近7天的设备访问情况，这些就是你的潜在客户了。这其实最终是一个商业的决定，在于你是想要增加一定百分比的潜在客户量，还是使你的app有更好的用户体验和性能。\n\n当然如果有一个API在你的app中很关键，那么这个决定的过程就变的很简单了。需要知道的是，即使是0.7%的潜在用户量，那也是一个很大的数字了，因为在Google Play Store的设备数是以十亿为单位的。\n\n**targetSdkVersion**\n----------------\n\n这个版本号是这三者本文中最有趣的一个。**targetSdkVersion是Android提供向前兼容最主要的方式**，当targetSdkVersion不改变时，那么就不采取任何行为上的改变。\n\n大多数由于targetSdkVersion改变而造成的行为改变都被记录在 VERSION_CODES中，所有细节都被列在每个发布的版本上，同时在API Levels table中有相应的链接进行说明。\n\n例如，在Android6.0中讨论了如何针对过度到API 23的之后，如何对你的app进行运行时的权限分配模式。\n\n由于一些行为上的改变对用户来说是可视的（取消了menu按钮，运行时权限，等），**更新到最新的SDK对多有的app都是有利的**。这并不以为这你必须使用所有的新特性或者盲目的提高你的targetSdkVersion而将测试抛在一边。----**请注意，在你提高你的targetSdkVersion之前一定要进行相应的测试**，这是提高软件质量所必须的，同时，你的用户会感激你的（也许没有感激，但是至少责骂会少很多）。\n\n**Gradle and SDK versions**\n-----------------------\n\n基于以上内容让我们知道设置正确的 compileSdkVersion, minSdkVersion , targetSdkVersion是相当重要的。也许你会想，如果在Android Studio和Gradle中，这些值都相应的整合进了工具系统中，如在模块的buile.gradle文件中设置好了。如下面这样：\n\n```\nandroid {\n  compileSdkVersion 23\n  buildToolsVersion “23.0.1”\n\n  defaultConfig {\n    applicationId “com.example.checkyourtargetsdk\"\n    minSdkVersion 7\n    targetSdkVersion 23\n    versionCode 1\n    versionName “1.0”\n  }\n}\n```\n\n在外面的两个：compileSdkVersion 和buildToolsVersion 一个是编译时SDK的版本号，一个是编译时编译器的版本号，这个我在我的领一篇文章中有详细介绍[链接地址](http://blog.csdn.net/qqq2830/article/details/53405699)。\n\n在**defaultConfig**中的内容则是项目构建的基础设置。\n\n在这当中 compileSdkVersion是和编译时有关，而minSdkVersion， targetSdkVersion这两者最终会放假APK中。你可以在生成的AndroidManifest.xml文件中看到：\n\n```\n<uses-sdk android:targetSdkVersion=”23\" android:minSdkVersion=”7\" />\n```\n\n你会发现当你手动将这些设置进你的manifest中后，如果你使用Gradle进行build，那么它会忽略你的设置。\n\n**总的来说三者的关系**\n----\n\n```\nminSdkVersion <= targetSdkVersion <= compileSdkVersion\n```\n**理想化来说应该是这样：**\n\n```\nminSdkVersion (lowest possible) <= \n    targetSdkVersion == compileSdkVersion (latest SDK)\n```\n\n通过这样，你就可以获得最多的潜在用户数，同时使app性能更好，同时界面更酷炫。\n\n期待您的加入 [Google+ post](https://plus.google.com/+AndroidDevelopers/posts/4TRW8SztAHv?utm_campaign=adp_series_sdkversion_010616&utm_source=medium&utm_medium=blog) 和[ Android Development Patterns Collection](https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_sdkversion_010616&utm_source=medium&utm_medium=blog)","source":"_posts/compileSdkVersion, minSdkVersion， targetSdkVersion这三兄弟.md","raw":"\n---\ntitle: compileSdkVersion, minSdkVersion， targetSdkVersion的关系\ndate: 2016-06-01 23:47:44\ncategories: \"Android基础学习\"\ntags:\n     - Android\n---\n\n\n![这里写图片描述](http://img.blog.csdn.net/20161130141617130)\n\n**选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion**\n-----------------------------------------------------------------------\n\n当你将一个App发布出去之后，也许马上Google又发布了一个新的Android版本。那这是否就意味着你发布的App会出现一些版本上的问题。\n\n当然这并不会困扰我们，因为Android是**向前兼容**的---向前兼容即旧版本能够适应新版本的应用---对Android而言就是在旧版上开发的应用当我们将手机的版本升级之后一样可以使用。这就是**compileSdkVersion**,  **minSdkVersion**,  **targetSdkVersion**这三者的由来，它们分别控制可用API的版本号，需要的API版本号和使用何种兼容模式。\n\n**compileSdkVersion**\n-----------------\n通过compileSdkVersion你可以告诉Gradle使用何种SDK版本来编译你的App。当你在代码中使用了一些新的API时，你就需要使用相应新的Android SDK。\n\n需要重点声明的是，**改变compileSdkVersion并不会改变运行时的行为，也就是说当在手机上跑的时候，使用的还是你手机上的SDK**，也就是你手机的Android版本号。当你改变compileSdkVersion时，会报出一些新的编译错误，但是你的compileSdkVersion并不会被包含在你的APK中：它仅仅用在编译期间。（虽然如此，但是你最好修复这些error---因为事出必定有因）\n\n在此**强烈建议你使用最新的SDK进行编译**。对现有代码进行最新SDK的编译检查时，你可以获得的好处是：避免一些在新版本中不赞成使用的API，并且及时使用最新的API。\n\n需要注意的是，当你使用 **Support Library**（兼容库）时，若要使用最新发布的兼容包，那么就必须使用最新版本的SDK进行编译。例：如果在gradle中添加compile 'com.android.support:design:23.0.1'那么相应的就需要将compileSdkVersion设置为23及以上。一般来讲，新版本的兼容库总是伴随新平台版本的发布，为新的API和特性提供兼容。\n\n**minSdkVersion**\n-------------\n如果说compileSdkVersion是设置你可用的最新API，**那么minSdkVersion就是为你的app设置最低门槛**，低于这个门槛就不要装了。Google Play Store通过这个标记来决定你的机子是否可以安装相应的app。\n\n该属性在开发过程中同样有着很重要的作用：默认情况下当你在开发的过程中，IDE可以通过这个标示来提醒你使用的API是否是在这个版本之后发布的，以此来帮助我们避免在运行时调用一些在手机的SDK中不存在的API。能够实现相同功能的是在代码中添加一些检查标示，来检查系统的版本来确定是否调用相应的API。\n\n需要注意的是：当我们使用也许第三方的库时如: **Support Libraries**或者 **Google Play services**这些类型的库，这些库有他们自己相应的minSdkVersion，我们需要确保我们自己app中使用的minSdkVersion必须要大于等于第三方库的minSdkVersion。**当然也存在一些个别情况**，当我们相应使用一个第三方库，该库的minSdkVersion要高于我们app的minSdkVersion，在我们不改变我们app的minSdkVersion前提下，任然想要使用这个第三方库，那么我们需要做的是使用**tools:overrideLibrary** 标示，但是我们必须要进行彻底的测试。以防止意外的发生。\n\n当我们要设定minSdkVersion时，可以到Google Play Store上查看最近7天的设备访问情况，这些就是你的潜在客户了。这其实最终是一个商业的决定，在于你是想要增加一定百分比的潜在客户量，还是使你的app有更好的用户体验和性能。\n\n当然如果有一个API在你的app中很关键，那么这个决定的过程就变的很简单了。需要知道的是，即使是0.7%的潜在用户量，那也是一个很大的数字了，因为在Google Play Store的设备数是以十亿为单位的。\n\n**targetSdkVersion**\n----------------\n\n这个版本号是这三者本文中最有趣的一个。**targetSdkVersion是Android提供向前兼容最主要的方式**，当targetSdkVersion不改变时，那么就不采取任何行为上的改变。\n\n大多数由于targetSdkVersion改变而造成的行为改变都被记录在 VERSION_CODES中，所有细节都被列在每个发布的版本上，同时在API Levels table中有相应的链接进行说明。\n\n例如，在Android6.0中讨论了如何针对过度到API 23的之后，如何对你的app进行运行时的权限分配模式。\n\n由于一些行为上的改变对用户来说是可视的（取消了menu按钮，运行时权限，等），**更新到最新的SDK对多有的app都是有利的**。这并不以为这你必须使用所有的新特性或者盲目的提高你的targetSdkVersion而将测试抛在一边。----**请注意，在你提高你的targetSdkVersion之前一定要进行相应的测试**，这是提高软件质量所必须的，同时，你的用户会感激你的（也许没有感激，但是至少责骂会少很多）。\n\n**Gradle and SDK versions**\n-----------------------\n\n基于以上内容让我们知道设置正确的 compileSdkVersion, minSdkVersion , targetSdkVersion是相当重要的。也许你会想，如果在Android Studio和Gradle中，这些值都相应的整合进了工具系统中，如在模块的buile.gradle文件中设置好了。如下面这样：\n\n```\nandroid {\n  compileSdkVersion 23\n  buildToolsVersion “23.0.1”\n\n  defaultConfig {\n    applicationId “com.example.checkyourtargetsdk\"\n    minSdkVersion 7\n    targetSdkVersion 23\n    versionCode 1\n    versionName “1.0”\n  }\n}\n```\n\n在外面的两个：compileSdkVersion 和buildToolsVersion 一个是编译时SDK的版本号，一个是编译时编译器的版本号，这个我在我的领一篇文章中有详细介绍[链接地址](http://blog.csdn.net/qqq2830/article/details/53405699)。\n\n在**defaultConfig**中的内容则是项目构建的基础设置。\n\n在这当中 compileSdkVersion是和编译时有关，而minSdkVersion， targetSdkVersion这两者最终会放假APK中。你可以在生成的AndroidManifest.xml文件中看到：\n\n```\n<uses-sdk android:targetSdkVersion=”23\" android:minSdkVersion=”7\" />\n```\n\n你会发现当你手动将这些设置进你的manifest中后，如果你使用Gradle进行build，那么它会忽略你的设置。\n\n**总的来说三者的关系**\n----\n\n```\nminSdkVersion <= targetSdkVersion <= compileSdkVersion\n```\n**理想化来说应该是这样：**\n\n```\nminSdkVersion (lowest possible) <= \n    targetSdkVersion == compileSdkVersion (latest SDK)\n```\n\n通过这样，你就可以获得最多的潜在用户数，同时使app性能更好，同时界面更酷炫。\n\n期待您的加入 [Google+ post](https://plus.google.com/+AndroidDevelopers/posts/4TRW8SztAHv?utm_campaign=adp_series_sdkversion_010616&utm_source=medium&utm_medium=blog) 和[ Android Development Patterns Collection](https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_sdkversion_010616&utm_source=medium&utm_medium=blog)","slug":"compileSdkVersion, minSdkVersion， targetSdkVersion这三兄弟","published":1,"updated":"2018-02-06T03:39:20.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdfnt20l0001j0ievhbj3vy4","content":"<p><img src=\"http://img.blog.csdn.net/20161130141617130\" alt=\"这里写图片描述\"></p>\n<h2 id=\"选择你自己的-compileSdkVersion-minSdkVersion-and-targetSdkVersion\"><a href=\"#选择你自己的-compileSdkVersion-minSdkVersion-and-targetSdkVersion\" class=\"headerlink\" title=\"选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion\"></a><strong>选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion</strong></h2><p>当你将一个App发布出去之后，也许马上Google又发布了一个新的Android版本。那这是否就意味着你发布的App会出现一些版本上的问题。</p>\n<p>当然这并不会困扰我们，因为Android是<strong>向前兼容</strong>的—向前兼容即旧版本能够适应新版本的应用—对Android而言就是在旧版上开发的应用当我们将手机的版本升级之后一样可以使用。这就是<strong>compileSdkVersion</strong>,  <strong>minSdkVersion</strong>,  <strong>targetSdkVersion</strong>这三者的由来，它们分别控制可用API的版本号，需要的API版本号和使用何种兼容模式。</p>\n<h2 id=\"compileSdkVersion\"><a href=\"#compileSdkVersion\" class=\"headerlink\" title=\"compileSdkVersion\"></a><strong>compileSdkVersion</strong></h2><p>通过compileSdkVersion你可以告诉Gradle使用何种SDK版本来编译你的App。当你在代码中使用了一些新的API时，你就需要使用相应新的Android SDK。</p>\n<p>需要重点声明的是，<strong>改变compileSdkVersion并不会改变运行时的行为，也就是说当在手机上跑的时候，使用的还是你手机上的SDK</strong>，也就是你手机的Android版本号。当你改变compileSdkVersion时，会报出一些新的编译错误，但是你的compileSdkVersion并不会被包含在你的APK中：它仅仅用在编译期间。（虽然如此，但是你最好修复这些error—因为事出必定有因）</p>\n<p>在此<strong>强烈建议你使用最新的SDK进行编译</strong>。对现有代码进行最新SDK的编译检查时，你可以获得的好处是：避免一些在新版本中不赞成使用的API，并且及时使用最新的API。</p>\n<p>需要注意的是，当你使用 <strong>Support Library</strong>（兼容库）时，若要使用最新发布的兼容包，那么就必须使用最新版本的SDK进行编译。例：如果在gradle中添加compile ‘com.android.support:design:23.0.1’那么相应的就需要将compileSdkVersion设置为23及以上。一般来讲，新版本的兼容库总是伴随新平台版本的发布，为新的API和特性提供兼容。</p>\n<h2 id=\"minSdkVersion\"><a href=\"#minSdkVersion\" class=\"headerlink\" title=\"minSdkVersion\"></a><strong>minSdkVersion</strong></h2><p>如果说compileSdkVersion是设置你可用的最新API，<strong>那么minSdkVersion就是为你的app设置最低门槛</strong>，低于这个门槛就不要装了。Google Play Store通过这个标记来决定你的机子是否可以安装相应的app。</p>\n<p>该属性在开发过程中同样有着很重要的作用：默认情况下当你在开发的过程中，IDE可以通过这个标示来提醒你使用的API是否是在这个版本之后发布的，以此来帮助我们避免在运行时调用一些在手机的SDK中不存在的API。能够实现相同功能的是在代码中添加一些检查标示，来检查系统的版本来确定是否调用相应的API。</p>\n<p>需要注意的是：当我们使用也许第三方的库时如: <strong>Support Libraries</strong>或者 <strong>Google Play services</strong>这些类型的库，这些库有他们自己相应的minSdkVersion，我们需要确保我们自己app中使用的minSdkVersion必须要大于等于第三方库的minSdkVersion。<strong>当然也存在一些个别情况</strong>，当我们相应使用一个第三方库，该库的minSdkVersion要高于我们app的minSdkVersion，在我们不改变我们app的minSdkVersion前提下，任然想要使用这个第三方库，那么我们需要做的是使用<strong>tools:overrideLibrary</strong> 标示，但是我们必须要进行彻底的测试。以防止意外的发生。</p>\n<p>当我们要设定minSdkVersion时，可以到Google Play Store上查看最近7天的设备访问情况，这些就是你的潜在客户了。这其实最终是一个商业的决定，在于你是想要增加一定百分比的潜在客户量，还是使你的app有更好的用户体验和性能。</p>\n<p>当然如果有一个API在你的app中很关键，那么这个决定的过程就变的很简单了。需要知道的是，即使是0.7%的潜在用户量，那也是一个很大的数字了，因为在Google Play Store的设备数是以十亿为单位的。</p>\n<h2 id=\"targetSdkVersion\"><a href=\"#targetSdkVersion\" class=\"headerlink\" title=\"targetSdkVersion\"></a><strong>targetSdkVersion</strong></h2><p>这个版本号是这三者本文中最有趣的一个。<strong>targetSdkVersion是Android提供向前兼容最主要的方式</strong>，当targetSdkVersion不改变时，那么就不采取任何行为上的改变。</p>\n<p>大多数由于targetSdkVersion改变而造成的行为改变都被记录在 VERSION_CODES中，所有细节都被列在每个发布的版本上，同时在API Levels table中有相应的链接进行说明。</p>\n<p>例如，在Android6.0中讨论了如何针对过度到API 23的之后，如何对你的app进行运行时的权限分配模式。</p>\n<p>由于一些行为上的改变对用户来说是可视的（取消了menu按钮，运行时权限，等），<strong>更新到最新的SDK对多有的app都是有利的</strong>。这并不以为这你必须使用所有的新特性或者盲目的提高你的targetSdkVersion而将测试抛在一边。—-<strong>请注意，在你提高你的targetSdkVersion之前一定要进行相应的测试</strong>，这是提高软件质量所必须的，同时，你的用户会感激你的（也许没有感激，但是至少责骂会少很多）。</p>\n<h2 id=\"Gradle-and-SDK-versions\"><a href=\"#Gradle-and-SDK-versions\" class=\"headerlink\" title=\"Gradle and SDK versions\"></a><strong>Gradle and SDK versions</strong></h2><p>基于以上内容让我们知道设置正确的 compileSdkVersion, minSdkVersion , targetSdkVersion是相当重要的。也许你会想，如果在Android Studio和Gradle中，这些值都相应的整合进了工具系统中，如在模块的buile.gradle文件中设置好了。如下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  compileSdkVersion 23</span><br><span class=\"line\">  buildToolsVersion “23.0.1”</span><br><span class=\"line\"></span><br><span class=\"line\">  defaultConfig &#123;</span><br><span class=\"line\">    applicationId “com.example.checkyourtargetsdk&quot;</span><br><span class=\"line\">    minSdkVersion 7</span><br><span class=\"line\">    targetSdkVersion 23</span><br><span class=\"line\">    versionCode 1</span><br><span class=\"line\">    versionName “1.0”</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在外面的两个：compileSdkVersion 和buildToolsVersion 一个是编译时SDK的版本号，一个是编译时编译器的版本号，这个我在我的领一篇文章中有详细介绍<a href=\"http://blog.csdn.net/qqq2830/article/details/53405699\" target=\"_blank\" rel=\"noopener\">链接地址</a>。</p>\n<p>在<strong>defaultConfig</strong>中的内容则是项目构建的基础设置。</p>\n<p>在这当中 compileSdkVersion是和编译时有关，而minSdkVersion， targetSdkVersion这两者最终会放假APK中。你可以在生成的AndroidManifest.xml文件中看到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-sdk android:targetSdkVersion=”23&quot; android:minSdkVersion=”7&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>你会发现当你手动将这些设置进你的manifest中后，如果你使用Gradle进行build，那么它会忽略你的设置。</p>\n<h2 id=\"总的来说三者的关系\"><a href=\"#总的来说三者的关系\" class=\"headerlink\" title=\"总的来说三者的关系\"></a><strong>总的来说三者的关系</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</span><br></pre></td></tr></table></figure>\n<p><strong>理想化来说应该是这样：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minSdkVersion (lowest possible) &lt;= </span><br><span class=\"line\">    targetSdkVersion == compileSdkVersion (latest SDK)</span><br></pre></td></tr></table></figure>\n<p>通过这样，你就可以获得最多的潜在用户数，同时使app性能更好，同时界面更酷炫。</p>\n<p>期待您的加入 <a href=\"https://plus.google.com/+AndroidDevelopers/posts/4TRW8SztAHv?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog\" target=\"_blank\" rel=\"noopener\">Google+ post</a> 和<a href=\"https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog\" target=\"_blank\" rel=\"noopener\"> Android Development Patterns Collection</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://img.blog.csdn.net/20161130141617130\" alt=\"这里写图片描述\"></p>\n<h2 id=\"选择你自己的-compileSdkVersion-minSdkVersion-and-targetSdkVersion\"><a href=\"#选择你自己的-compileSdkVersion-minSdkVersion-and-targetSdkVersion\" class=\"headerlink\" title=\"选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion\"></a><strong>选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion</strong></h2><p>当你将一个App发布出去之后，也许马上Google又发布了一个新的Android版本。那这是否就意味着你发布的App会出现一些版本上的问题。</p>\n<p>当然这并不会困扰我们，因为Android是<strong>向前兼容</strong>的—向前兼容即旧版本能够适应新版本的应用—对Android而言就是在旧版上开发的应用当我们将手机的版本升级之后一样可以使用。这就是<strong>compileSdkVersion</strong>,  <strong>minSdkVersion</strong>,  <strong>targetSdkVersion</strong>这三者的由来，它们分别控制可用API的版本号，需要的API版本号和使用何种兼容模式。</p>\n<h2 id=\"compileSdkVersion\"><a href=\"#compileSdkVersion\" class=\"headerlink\" title=\"compileSdkVersion\"></a><strong>compileSdkVersion</strong></h2><p>通过compileSdkVersion你可以告诉Gradle使用何种SDK版本来编译你的App。当你在代码中使用了一些新的API时，你就需要使用相应新的Android SDK。</p>\n<p>需要重点声明的是，<strong>改变compileSdkVersion并不会改变运行时的行为，也就是说当在手机上跑的时候，使用的还是你手机上的SDK</strong>，也就是你手机的Android版本号。当你改变compileSdkVersion时，会报出一些新的编译错误，但是你的compileSdkVersion并不会被包含在你的APK中：它仅仅用在编译期间。（虽然如此，但是你最好修复这些error—因为事出必定有因）</p>\n<p>在此<strong>强烈建议你使用最新的SDK进行编译</strong>。对现有代码进行最新SDK的编译检查时，你可以获得的好处是：避免一些在新版本中不赞成使用的API，并且及时使用最新的API。</p>\n<p>需要注意的是，当你使用 <strong>Support Library</strong>（兼容库）时，若要使用最新发布的兼容包，那么就必须使用最新版本的SDK进行编译。例：如果在gradle中添加compile ‘com.android.support:design:23.0.1’那么相应的就需要将compileSdkVersion设置为23及以上。一般来讲，新版本的兼容库总是伴随新平台版本的发布，为新的API和特性提供兼容。</p>\n<h2 id=\"minSdkVersion\"><a href=\"#minSdkVersion\" class=\"headerlink\" title=\"minSdkVersion\"></a><strong>minSdkVersion</strong></h2><p>如果说compileSdkVersion是设置你可用的最新API，<strong>那么minSdkVersion就是为你的app设置最低门槛</strong>，低于这个门槛就不要装了。Google Play Store通过这个标记来决定你的机子是否可以安装相应的app。</p>\n<p>该属性在开发过程中同样有着很重要的作用：默认情况下当你在开发的过程中，IDE可以通过这个标示来提醒你使用的API是否是在这个版本之后发布的，以此来帮助我们避免在运行时调用一些在手机的SDK中不存在的API。能够实现相同功能的是在代码中添加一些检查标示，来检查系统的版本来确定是否调用相应的API。</p>\n<p>需要注意的是：当我们使用也许第三方的库时如: <strong>Support Libraries</strong>或者 <strong>Google Play services</strong>这些类型的库，这些库有他们自己相应的minSdkVersion，我们需要确保我们自己app中使用的minSdkVersion必须要大于等于第三方库的minSdkVersion。<strong>当然也存在一些个别情况</strong>，当我们相应使用一个第三方库，该库的minSdkVersion要高于我们app的minSdkVersion，在我们不改变我们app的minSdkVersion前提下，任然想要使用这个第三方库，那么我们需要做的是使用<strong>tools:overrideLibrary</strong> 标示，但是我们必须要进行彻底的测试。以防止意外的发生。</p>\n<p>当我们要设定minSdkVersion时，可以到Google Play Store上查看最近7天的设备访问情况，这些就是你的潜在客户了。这其实最终是一个商业的决定，在于你是想要增加一定百分比的潜在客户量，还是使你的app有更好的用户体验和性能。</p>\n<p>当然如果有一个API在你的app中很关键，那么这个决定的过程就变的很简单了。需要知道的是，即使是0.7%的潜在用户量，那也是一个很大的数字了，因为在Google Play Store的设备数是以十亿为单位的。</p>\n<h2 id=\"targetSdkVersion\"><a href=\"#targetSdkVersion\" class=\"headerlink\" title=\"targetSdkVersion\"></a><strong>targetSdkVersion</strong></h2><p>这个版本号是这三者本文中最有趣的一个。<strong>targetSdkVersion是Android提供向前兼容最主要的方式</strong>，当targetSdkVersion不改变时，那么就不采取任何行为上的改变。</p>\n<p>大多数由于targetSdkVersion改变而造成的行为改变都被记录在 VERSION_CODES中，所有细节都被列在每个发布的版本上，同时在API Levels table中有相应的链接进行说明。</p>\n<p>例如，在Android6.0中讨论了如何针对过度到API 23的之后，如何对你的app进行运行时的权限分配模式。</p>\n<p>由于一些行为上的改变对用户来说是可视的（取消了menu按钮，运行时权限，等），<strong>更新到最新的SDK对多有的app都是有利的</strong>。这并不以为这你必须使用所有的新特性或者盲目的提高你的targetSdkVersion而将测试抛在一边。—-<strong>请注意，在你提高你的targetSdkVersion之前一定要进行相应的测试</strong>，这是提高软件质量所必须的，同时，你的用户会感激你的（也许没有感激，但是至少责骂会少很多）。</p>\n<h2 id=\"Gradle-and-SDK-versions\"><a href=\"#Gradle-and-SDK-versions\" class=\"headerlink\" title=\"Gradle and SDK versions\"></a><strong>Gradle and SDK versions</strong></h2><p>基于以上内容让我们知道设置正确的 compileSdkVersion, minSdkVersion , targetSdkVersion是相当重要的。也许你会想，如果在Android Studio和Gradle中，这些值都相应的整合进了工具系统中，如在模块的buile.gradle文件中设置好了。如下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  compileSdkVersion 23</span><br><span class=\"line\">  buildToolsVersion “23.0.1”</span><br><span class=\"line\"></span><br><span class=\"line\">  defaultConfig &#123;</span><br><span class=\"line\">    applicationId “com.example.checkyourtargetsdk&quot;</span><br><span class=\"line\">    minSdkVersion 7</span><br><span class=\"line\">    targetSdkVersion 23</span><br><span class=\"line\">    versionCode 1</span><br><span class=\"line\">    versionName “1.0”</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在外面的两个：compileSdkVersion 和buildToolsVersion 一个是编译时SDK的版本号，一个是编译时编译器的版本号，这个我在我的领一篇文章中有详细介绍<a href=\"http://blog.csdn.net/qqq2830/article/details/53405699\" target=\"_blank\" rel=\"noopener\">链接地址</a>。</p>\n<p>在<strong>defaultConfig</strong>中的内容则是项目构建的基础设置。</p>\n<p>在这当中 compileSdkVersion是和编译时有关，而minSdkVersion， targetSdkVersion这两者最终会放假APK中。你可以在生成的AndroidManifest.xml文件中看到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-sdk android:targetSdkVersion=”23&quot; android:minSdkVersion=”7&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>你会发现当你手动将这些设置进你的manifest中后，如果你使用Gradle进行build，那么它会忽略你的设置。</p>\n<h2 id=\"总的来说三者的关系\"><a href=\"#总的来说三者的关系\" class=\"headerlink\" title=\"总的来说三者的关系\"></a><strong>总的来说三者的关系</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</span><br></pre></td></tr></table></figure>\n<p><strong>理想化来说应该是这样：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minSdkVersion (lowest possible) &lt;= </span><br><span class=\"line\">    targetSdkVersion == compileSdkVersion (latest SDK)</span><br></pre></td></tr></table></figure>\n<p>通过这样，你就可以获得最多的潜在用户数，同时使app性能更好，同时界面更酷炫。</p>\n<p>期待您的加入 <a href=\"https://plus.google.com/+AndroidDevelopers/posts/4TRW8SztAHv?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog\" target=\"_blank\" rel=\"noopener\">Google+ post</a> 和<a href=\"https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog\" target=\"_blank\" rel=\"noopener\"> Android Development Patterns Collection</a></p>\n"},{"title":"python爬虫初涉","date":"2018-02-06T06:17:44.000Z","_content":"\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/helo004.jpg)\n\n### 文章简介\n\n**本文将介绍如何使用python对www.mzitu.com中所有的图片的爬取以及存储到本地最后我们会得到如下图1所示**\n\n\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206142745.png)\n\n是不是很心动，接下来就让我们开始python爬虫之旅，本期内容将会从单线程使用到多线程，从自己写python到使用scrapy包，以及分布式redis的使用，当然这些都是后话了，当前我们的目标是要爬去这个网站上的美图。\n\n### 环境介绍\n\n废话少说接下来就是我们的基础环境部分\n**1.Python -- 3.6.1**（这个版本其实要区别的就是python2和python3啦，我使用的python3）\n\n**2.Requests** （看名字就知道这个是用来进行网络请求用的，这里的request是rllib包中的，之后我们要学的scrapy中也有自己想要的request，到时候两个不要搞混了）\n\n**3.beautifulsoup** （当然数据获取到了之后，我们要对数据进行提取，解析就是通过beautifulsoup来进行，当然我们自己也可通过正则表达式来对数据进行过滤，如果你的正则水平不错的情况下） \n\n**4.LXML** 一个HTML解析包 用于辅助beautifulsoup解析网页  \n\n--------------\n**上面的模块需要 单独安装，下面几个就不用啦。**\n\n--------------\n**5.OS 系统内置模块** （这个玩意是系统内置的，在本文中我们通过它来将图片存储在本地）\n\n**6.PyCharm**   一个草鸡好用的PythonIDE工具 、真滴。\n\n\n### 模块的安装\n\n再使用pip指令之前我们需要安装python。（如果我们安装python时选择**不将**python写入环境变量的话，那么我们还需要将“文件夹\\python36”和“文件夹\\python36\\Scripts”写入path中，这样我们才能在控制台中使用python和pip指令）\n\n**接下来就用指令安装模块**\n    \n     pip install requests   \n     pip install beautifulsoup4  \n     pip install lxml\n\n大致结果就如下图所示\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206150606.png)\n\n当python + 3个模块 + PyCharm安装完成之后我们就可以开始我们本次抓取的代码编写了。\n\n### 爬虫编写\n**首先我们先整理一下爬图片的步骤：**\n\n1.我们需要一个目标网站（www.mzitu.com）\n2.我们需要从一个网页中找出接下来要去的网页的链接地址，通过beautifulsoup来获取\n3.获取网页中的图片地址\n4.下载图片到本地\n\n\n**步骤1：**\nwww.mzitu.com网站的截图如下，这里选择了www.mzitu.com/all作为起始网页，因为在该网页中包含了网站中所有图片组图的链接链接地址\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160047.png)\n\n\n**步骤2：**\n推荐使用chrome浏览器来进行网页源码的查看\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160522.png)\n\n通过观察我们可以发现接下来的链接地址在所在的**href**是被**div class=all**所包含着的，所有我们可以使用这一点来找到所有的url地址\n\n**步骤3：**\n接下来我们就进入到某个链接里面去看图了\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161232.png)\n相应图片的地址被包含在**div class='main-image'**中\n\n\n注意着个有一套图（一般她们拍写真都有很多张的），所以呢我们就看下接下来的这张图\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161358.png)\n着张图里的**href**就是套图里其他图片所在网页的地址了，有了这个我们就可以获取接下来的图片了，其中通过观察可以发现**href**被包在**div class=‘pagenavi’**中\n\n**步骤4：**\n**开始代码编写**\n\n我们需要在代码中引入相应的模块\n\n    import requests\n\tfrom bs4 import BeautifulSoup\n\timport os\n\n获取起始网页内容\n\n    html = self.request(url)\n    \n这里的request是下面的这个方法\n\n        def request(self, url):  ##这个函数获取网页的response 然后返回\n\t        headers = {\n            'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}\n\t        content = requests.get(url, headers=headers)\n\n\t        return content\n\n获取步骤1中内容（也就是所有套图的地址），并进一步发送请求获取到套图首张图片所在网页\n\n    all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')\n    for a in all_a:       \n\t    title = a.get_text() #取出a标签的文本       \n\t    href = a['href'] #取出a标签的href 属性，也就是套图地址\n\t    self.html(href, \"e:\\\\pic\\\\\" + path)\n\t\n相应的html方法\n\n        def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n\t        html = self.request(href)\n\t        helo = BeautifulSoup(html.text, 'lxml').find_all('span')\n\t        if len(helo) < 10:\n\t            return\n\t        max_span = helo[10].get_text()\n\t        for page in range(1, int(max_span) + 1):\n\t            page_url = href + '/' + str(page)\n\t            self.img(page_url, path)  ##调用img函数\n\n上面的html方法中的后半截是执行了步骤3中的后半部分，也就是遍历了套图中其他图片所在的网页，相应的img方法如下\n\n        def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n\t        img_html = self.request(page_url)\n\t        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')\n\t        if helo is not None:\n\t            helo1 = helo.find('img')\n\t            if helo1 is not None:\n\t                # do some thing you need\n\t                img_url = helo1['src']\n\t                self.saveImg(img_url, path)\n\n        def saveImg(self, url, path):\n\t        getHeaders = {\n\t            'Host': 'i.meizitu.net',\n\t            'Connection': 'Keep-Alive',\n\t            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',\n\t            'Referer': 'http://www.mzitu.com/',\n\t            'Accept-Encoding': 'gzip, deflate',\n\t            'Accept-Language': 'zh-CN,zh;q=0.9'\n\t        }\n\t        response = requests.get(url, headers=getHeaders)\n\t        \n\t        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n\t            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n\t            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n\t                name = url[-9:-4]\n\t                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址\n\t                response = requests.get(redirectUrl)\n\t                fp = open(name + \".jpg\", 'ab')\n\t                fp.write(response.content)\n\t                fp.close()\n\t        else:\n\t            os.chdir(path)\n\t            name = url[-9:-4]\n\t            fp = open(name + \".jpg\", 'ab')\n\t            fp.write(response.content)\n\t            fp.close()\n\t            self.picNum = self.picNum + 1\n\t            print(self.picNum)\n\t            \n方法saveImg执行了步骤4，也就是将图片保存在了本地。\n\n\n\n### 总结\n\n本片文字是在之前微信上看到的一篇文章改写的，当时照着那篇文字将代码写了一遍之后发现，保存在本地的图片都被篡改了，也就是被防盗链了，而后就只能修改request中的一些参数来确保准确性。在上面这些完成后，发现对爬虫有了一点的了解之后想着是不是可以使用多线程的方式来爬去，就又看了多线程的写法，下面贴出多线程的代码，这里使用的线程池。\n\n**多线程代码**\n\n    import requests\n\tfrom bs4 import BeautifulSoup\n\timport os\n\timport threading\n\timport threadpool\n\t\n\t\n\tclass mzitu():\n\t    num = 0\n\t    picNum = 0\n\n\t    def all_url(self, url):\n\t        self.cv = threading.Condition()\n\t        html = self.request(url)  ##调用request函数把套图地址传进去会返回给我们一个response\n\t        all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')\n\t\n\t        task_pool = threadpool.ThreadPool(50)\n\t        requests = threadpool.makeRequests(self.nice, all_a)\n\t        for req in requests:\n\t            task_pool.putRequest(req)\n\t        task_pool.wait()\n\n\t    def nice(self, a):\n\t        title = a.get_text()\n\t        path = str(title).replace(\"?\", '_')  ##我注意到有个标题带有 ？  这个符号Windows系统是不能创建文件夹的所以要替换掉\n\t        if self.mkdir(path):  ##调用mkdir函数创建文件夹！这儿path代表的是标题title哦！！！！！不要糊涂了哦！\n\t            os.chdir(\"e:\\\\pic\\\\\" + path)  ##切换到目录\n\t            href = a['href']\n\t            self.html(href, \"e:\\\\pic\\\\\" + path)  ##调用html函数把href参数传递过去！href是啥还记的吧？ 就是套图的地址哦！！不要迷糊了哦！\n\n\t    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n\t        html = self.request(href)\n\t        helo = BeautifulSoup(html.text, 'lxml').find_all('span')\n\t        if len(helo) < 10:\n\t            return\n\t        max_span = helo[10].get_text()\n\t        for page in range(1, int(max_span) + 1):\n\t            page_url = href + '/' + str(page)\n\t            self.img(page_url, path)  ##调用img函数\n\n\t    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n\t        img_html = self.request(page_url)\n\t        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')\n\t        if helo is not None:\n\t            helo1 = helo.find('img')\n\t            if helo1 is not None:\n\t                # do some thing you need\n\t                img_url = helo1['src']\n\t                self.saveImg(img_url, path)\n\t\n\t    def mkdir(self, path):  ##这个函数创建文件夹\n\t        path = path.strip()\n\t        if path.__contains__(\"妲己\"):\n\t            return False\n\t        isExists = os.path.exists(os.path.join(\"e:\\\\pic\\\\\", path))\n\t        if not isExists:\n\t            os.makedirs(os.path.join(\"e:\\\\pic\\\\\", path))\n\t            return True\n\t        else:\n\t            return False\n\t\n\t    def request(self, url):  ##这个函数获取网页的response 然后返回\n\t        headers = {\n\t            'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}\n\t        content = requests.get(url, headers=headers)\n\t\n\t        return content\n\t\n\t    def saveImg(self, url, path):\n\t        getHeaders = {\n\t            'Host': 'i.meizitu.net',\n\t            'Connection': 'Keep-Alive',\n\t            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',\n\t            'Referer': 'http://www.mzitu.com/',\n\t            'Accept-Encoding': 'gzip, deflate',\n\t            'Accept-Language': 'zh-CN,zh;q=0.9'\n\t        }\n\t\n\t        response = requests.get(url, headers=getHeaders)\n\t        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n\t            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n\t            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n\t                name = url[-9:-4]\n\t                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址\n\t                response = requests.get(redirectUrl)\n\t                fp = open(name + \".jpg\", 'ab')\n\t                fp.write(response.content)\n\t                fp.close()\n\t        else:\n\t            os.chdir(path)\n\t            name = url[-9:-4]\n\t            fp = open(name + \".jpg\", 'ab')\n\t            fp.write(response.content)\n\t            fp.close()\n\t            self.picNum = self.picNum + 1\n\t            print(self.picNum)\n\t            \n\tMzitu = mzitu()  ##实例化\n\tMzitu.all_url('http://www.mzitu.com/all')  ##给函数all_url传入参数  你可以当作启动爬虫（就是入口）\n\n\n\n\n\n\n\n       \n\n\n\n\n","source":"_posts/python抓妹子.md","raw":"---\ntitle: python爬虫初涉\ndate: 2018-02-06 14:17:44\ncategories: \"python\"\ntags:\n     - python\n     - 爬虫\n     - 技术\n---\n\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/helo004.jpg)\n\n### 文章简介\n\n**本文将介绍如何使用python对www.mzitu.com中所有的图片的爬取以及存储到本地最后我们会得到如下图1所示**\n\n\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206142745.png)\n\n是不是很心动，接下来就让我们开始python爬虫之旅，本期内容将会从单线程使用到多线程，从自己写python到使用scrapy包，以及分布式redis的使用，当然这些都是后话了，当前我们的目标是要爬去这个网站上的美图。\n\n### 环境介绍\n\n废话少说接下来就是我们的基础环境部分\n**1.Python -- 3.6.1**（这个版本其实要区别的就是python2和python3啦，我使用的python3）\n\n**2.Requests** （看名字就知道这个是用来进行网络请求用的，这里的request是rllib包中的，之后我们要学的scrapy中也有自己想要的request，到时候两个不要搞混了）\n\n**3.beautifulsoup** （当然数据获取到了之后，我们要对数据进行提取，解析就是通过beautifulsoup来进行，当然我们自己也可通过正则表达式来对数据进行过滤，如果你的正则水平不错的情况下） \n\n**4.LXML** 一个HTML解析包 用于辅助beautifulsoup解析网页  \n\n--------------\n**上面的模块需要 单独安装，下面几个就不用啦。**\n\n--------------\n**5.OS 系统内置模块** （这个玩意是系统内置的，在本文中我们通过它来将图片存储在本地）\n\n**6.PyCharm**   一个草鸡好用的PythonIDE工具 、真滴。\n\n\n### 模块的安装\n\n再使用pip指令之前我们需要安装python。（如果我们安装python时选择**不将**python写入环境变量的话，那么我们还需要将“文件夹\\python36”和“文件夹\\python36\\Scripts”写入path中，这样我们才能在控制台中使用python和pip指令）\n\n**接下来就用指令安装模块**\n    \n     pip install requests   \n     pip install beautifulsoup4  \n     pip install lxml\n\n大致结果就如下图所示\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206150606.png)\n\n当python + 3个模块 + PyCharm安装完成之后我们就可以开始我们本次抓取的代码编写了。\n\n### 爬虫编写\n**首先我们先整理一下爬图片的步骤：**\n\n1.我们需要一个目标网站（www.mzitu.com）\n2.我们需要从一个网页中找出接下来要去的网页的链接地址，通过beautifulsoup来获取\n3.获取网页中的图片地址\n4.下载图片到本地\n\n\n**步骤1：**\nwww.mzitu.com网站的截图如下，这里选择了www.mzitu.com/all作为起始网页，因为在该网页中包含了网站中所有图片组图的链接链接地址\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160047.png)\n\n\n**步骤2：**\n推荐使用chrome浏览器来进行网页源码的查看\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160522.png)\n\n通过观察我们可以发现接下来的链接地址在所在的**href**是被**div class=all**所包含着的，所有我们可以使用这一点来找到所有的url地址\n\n**步骤3：**\n接下来我们就进入到某个链接里面去看图了\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161232.png)\n相应图片的地址被包含在**div class='main-image'**中\n\n\n注意着个有一套图（一般她们拍写真都有很多张的），所以呢我们就看下接下来的这张图\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161358.png)\n着张图里的**href**就是套图里其他图片所在网页的地址了，有了这个我们就可以获取接下来的图片了，其中通过观察可以发现**href**被包在**div class=‘pagenavi’**中\n\n**步骤4：**\n**开始代码编写**\n\n我们需要在代码中引入相应的模块\n\n    import requests\n\tfrom bs4 import BeautifulSoup\n\timport os\n\n获取起始网页内容\n\n    html = self.request(url)\n    \n这里的request是下面的这个方法\n\n        def request(self, url):  ##这个函数获取网页的response 然后返回\n\t        headers = {\n            'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}\n\t        content = requests.get(url, headers=headers)\n\n\t        return content\n\n获取步骤1中内容（也就是所有套图的地址），并进一步发送请求获取到套图首张图片所在网页\n\n    all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')\n    for a in all_a:       \n\t    title = a.get_text() #取出a标签的文本       \n\t    href = a['href'] #取出a标签的href 属性，也就是套图地址\n\t    self.html(href, \"e:\\\\pic\\\\\" + path)\n\t\n相应的html方法\n\n        def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n\t        html = self.request(href)\n\t        helo = BeautifulSoup(html.text, 'lxml').find_all('span')\n\t        if len(helo) < 10:\n\t            return\n\t        max_span = helo[10].get_text()\n\t        for page in range(1, int(max_span) + 1):\n\t            page_url = href + '/' + str(page)\n\t            self.img(page_url, path)  ##调用img函数\n\n上面的html方法中的后半截是执行了步骤3中的后半部分，也就是遍历了套图中其他图片所在的网页，相应的img方法如下\n\n        def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n\t        img_html = self.request(page_url)\n\t        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')\n\t        if helo is not None:\n\t            helo1 = helo.find('img')\n\t            if helo1 is not None:\n\t                # do some thing you need\n\t                img_url = helo1['src']\n\t                self.saveImg(img_url, path)\n\n        def saveImg(self, url, path):\n\t        getHeaders = {\n\t            'Host': 'i.meizitu.net',\n\t            'Connection': 'Keep-Alive',\n\t            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',\n\t            'Referer': 'http://www.mzitu.com/',\n\t            'Accept-Encoding': 'gzip, deflate',\n\t            'Accept-Language': 'zh-CN,zh;q=0.9'\n\t        }\n\t        response = requests.get(url, headers=getHeaders)\n\t        \n\t        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n\t            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n\t            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n\t                name = url[-9:-4]\n\t                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址\n\t                response = requests.get(redirectUrl)\n\t                fp = open(name + \".jpg\", 'ab')\n\t                fp.write(response.content)\n\t                fp.close()\n\t        else:\n\t            os.chdir(path)\n\t            name = url[-9:-4]\n\t            fp = open(name + \".jpg\", 'ab')\n\t            fp.write(response.content)\n\t            fp.close()\n\t            self.picNum = self.picNum + 1\n\t            print(self.picNum)\n\t            \n方法saveImg执行了步骤4，也就是将图片保存在了本地。\n\n\n\n### 总结\n\n本片文字是在之前微信上看到的一篇文章改写的，当时照着那篇文字将代码写了一遍之后发现，保存在本地的图片都被篡改了，也就是被防盗链了，而后就只能修改request中的一些参数来确保准确性。在上面这些完成后，发现对爬虫有了一点的了解之后想着是不是可以使用多线程的方式来爬去，就又看了多线程的写法，下面贴出多线程的代码，这里使用的线程池。\n\n**多线程代码**\n\n    import requests\n\tfrom bs4 import BeautifulSoup\n\timport os\n\timport threading\n\timport threadpool\n\t\n\t\n\tclass mzitu():\n\t    num = 0\n\t    picNum = 0\n\n\t    def all_url(self, url):\n\t        self.cv = threading.Condition()\n\t        html = self.request(url)  ##调用request函数把套图地址传进去会返回给我们一个response\n\t        all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')\n\t\n\t        task_pool = threadpool.ThreadPool(50)\n\t        requests = threadpool.makeRequests(self.nice, all_a)\n\t        for req in requests:\n\t            task_pool.putRequest(req)\n\t        task_pool.wait()\n\n\t    def nice(self, a):\n\t        title = a.get_text()\n\t        path = str(title).replace(\"?\", '_')  ##我注意到有个标题带有 ？  这个符号Windows系统是不能创建文件夹的所以要替换掉\n\t        if self.mkdir(path):  ##调用mkdir函数创建文件夹！这儿path代表的是标题title哦！！！！！不要糊涂了哦！\n\t            os.chdir(\"e:\\\\pic\\\\\" + path)  ##切换到目录\n\t            href = a['href']\n\t            self.html(href, \"e:\\\\pic\\\\\" + path)  ##调用html函数把href参数传递过去！href是啥还记的吧？ 就是套图的地址哦！！不要迷糊了哦！\n\n\t    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n\t        html = self.request(href)\n\t        helo = BeautifulSoup(html.text, 'lxml').find_all('span')\n\t        if len(helo) < 10:\n\t            return\n\t        max_span = helo[10].get_text()\n\t        for page in range(1, int(max_span) + 1):\n\t            page_url = href + '/' + str(page)\n\t            self.img(page_url, path)  ##调用img函数\n\n\t    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n\t        img_html = self.request(page_url)\n\t        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')\n\t        if helo is not None:\n\t            helo1 = helo.find('img')\n\t            if helo1 is not None:\n\t                # do some thing you need\n\t                img_url = helo1['src']\n\t                self.saveImg(img_url, path)\n\t\n\t    def mkdir(self, path):  ##这个函数创建文件夹\n\t        path = path.strip()\n\t        if path.__contains__(\"妲己\"):\n\t            return False\n\t        isExists = os.path.exists(os.path.join(\"e:\\\\pic\\\\\", path))\n\t        if not isExists:\n\t            os.makedirs(os.path.join(\"e:\\\\pic\\\\\", path))\n\t            return True\n\t        else:\n\t            return False\n\t\n\t    def request(self, url):  ##这个函数获取网页的response 然后返回\n\t        headers = {\n\t            'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}\n\t        content = requests.get(url, headers=headers)\n\t\n\t        return content\n\t\n\t    def saveImg(self, url, path):\n\t        getHeaders = {\n\t            'Host': 'i.meizitu.net',\n\t            'Connection': 'Keep-Alive',\n\t            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',\n\t            'Referer': 'http://www.mzitu.com/',\n\t            'Accept-Encoding': 'gzip, deflate',\n\t            'Accept-Language': 'zh-CN,zh;q=0.9'\n\t        }\n\t\n\t        response = requests.get(url, headers=getHeaders)\n\t        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n\t            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n\t            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n\t                name = url[-9:-4]\n\t                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址\n\t                response = requests.get(redirectUrl)\n\t                fp = open(name + \".jpg\", 'ab')\n\t                fp.write(response.content)\n\t                fp.close()\n\t        else:\n\t            os.chdir(path)\n\t            name = url[-9:-4]\n\t            fp = open(name + \".jpg\", 'ab')\n\t            fp.write(response.content)\n\t            fp.close()\n\t            self.picNum = self.picNum + 1\n\t            print(self.picNum)\n\t            \n\tMzitu = mzitu()  ##实例化\n\tMzitu.all_url('http://www.mzitu.com/all')  ##给函数all_url传入参数  你可以当作启动爬虫（就是入口）\n\n\n\n\n\n\n\n       \n\n\n\n\n","slug":"python抓妹子","published":1,"updated":"2018-02-06T08:54:07.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdfnt20r0004j0iebuer9fls","content":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/helo004.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"文章简介\"><a href=\"#文章简介\" class=\"headerlink\" title=\"文章简介\"></a>文章简介</h3><p><strong>本文将介绍如何使用python对www.mzitu.com中所有的图片的爬取以及存储到本地最后我们会得到如下图1所示</strong></p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206142745.png\" alt=\"enter image description here\"></p>\n<p>是不是很心动，接下来就让我们开始python爬虫之旅，本期内容将会从单线程使用到多线程，从自己写python到使用scrapy包，以及分布式redis的使用，当然这些都是后话了，当前我们的目标是要爬去这个网站上的美图。</p>\n<h3 id=\"环境介绍\"><a href=\"#环境介绍\" class=\"headerlink\" title=\"环境介绍\"></a>环境介绍</h3><p>废话少说接下来就是我们的基础环境部分<br><strong>1.Python – 3.6.1</strong>（这个版本其实要区别的就是python2和python3啦，我使用的python3）</p>\n<p><strong>2.Requests</strong> （看名字就知道这个是用来进行网络请求用的，这里的request是rllib包中的，之后我们要学的scrapy中也有自己想要的request，到时候两个不要搞混了）</p>\n<p><strong>3.beautifulsoup</strong> （当然数据获取到了之后，我们要对数据进行提取，解析就是通过beautifulsoup来进行，当然我们自己也可通过正则表达式来对数据进行过滤，如果你的正则水平不错的情况下） </p>\n<p><strong>4.LXML</strong> 一个HTML解析包 用于辅助beautifulsoup解析网页  </p>\n<hr>\n<p><strong>上面的模块需要 单独安装，下面几个就不用啦。</strong></p>\n<hr>\n<p><strong>5.OS 系统内置模块</strong> （这个玩意是系统内置的，在本文中我们通过它来将图片存储在本地）</p>\n<p><strong>6.PyCharm</strong>   一个草鸡好用的PythonIDE工具 、真滴。</p>\n<h3 id=\"模块的安装\"><a href=\"#模块的安装\" class=\"headerlink\" title=\"模块的安装\"></a>模块的安装</h3><p>再使用pip指令之前我们需要安装python。（如果我们安装python时选择<strong>不将</strong>python写入环境变量的话，那么我们还需要将“文件夹\\python36”和“文件夹\\python36\\Scripts”写入path中，这样我们才能在控制台中使用python和pip指令）</p>\n<p><strong>接下来就用指令安装模块</strong></p>\n<pre><code>pip install requests   \npip install beautifulsoup4  \npip install lxml\n</code></pre><p>大致结果就如下图所示<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206150606.png\" alt=\"enter image description here\"></p>\n<p>当python + 3个模块 + PyCharm安装完成之后我们就可以开始我们本次抓取的代码编写了。</p>\n<h3 id=\"爬虫编写\"><a href=\"#爬虫编写\" class=\"headerlink\" title=\"爬虫编写\"></a>爬虫编写</h3><p><strong>首先我们先整理一下爬图片的步骤：</strong></p>\n<p>1.我们需要一个目标网站（www.mzitu.com）<br>2.我们需要从一个网页中找出接下来要去的网页的链接地址，通过beautifulsoup来获取<br>3.获取网页中的图片地址<br>4.下载图片到本地</p>\n<p><strong>步骤1：</strong><br>www.mzitu.com网站的截图如下，这里选择了www.mzitu.com/all作为起始网页，因为在该网页中包含了网站中所有图片组图的链接链接地址<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160047.png\" alt=\"enter image description here\"></p>\n<p><strong>步骤2：</strong><br>推荐使用chrome浏览器来进行网页源码的查看<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160522.png\" alt=\"enter image description here\"></p>\n<p>通过观察我们可以发现接下来的链接地址在所在的<strong>href</strong>是被<strong>div class=all</strong>所包含着的，所有我们可以使用这一点来找到所有的url地址</p>\n<p><strong>步骤3：</strong><br>接下来我们就进入到某个链接里面去看图了<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161232.png\" alt=\"enter image description here\"><br>相应图片的地址被包含在<strong>div class=’main-image’</strong>中</p>\n<p>注意着个有一套图（一般她们拍写真都有很多张的），所以呢我们就看下接下来的这张图<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161358.png\" alt=\"enter image description here\"><br>着张图里的<strong>href</strong>就是套图里其他图片所在网页的地址了，有了这个我们就可以获取接下来的图片了，其中通过观察可以发现<strong>href</strong>被包在<strong>div class=‘pagenavi’</strong>中</p>\n<p><strong>步骤4：</strong><br><strong>开始代码编写</strong></p>\n<p>我们需要在代码中引入相应的模块</p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport os\n</code></pre><p>获取起始网页内容</p>\n<pre><code>html = self.request(url)\n</code></pre><p>这里的request是下面的这个方法</p>\n<pre><code>def request(self, url):  ##这个函数获取网页的response 然后返回\n    headers = {\n    &apos;User-Agent&apos;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}\n    content = requests.get(url, headers=headers)\n\n    return content\n</code></pre><p>获取步骤1中内容（也就是所有套图的地址），并进一步发送请求获取到套图首张图片所在网页</p>\n<pre><code>all_a = BeautifulSoup(html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;all&apos;).find_all(&apos;a&apos;)\nfor a in all_a:       \n    title = a.get_text() #取出a标签的文本       \n    href = a[&apos;href&apos;] #取出a标签的href 属性，也就是套图地址\n    self.html(href, &quot;e:\\\\pic\\\\&quot; + path)\n</code></pre><p>相应的html方法</p>\n<pre><code>def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n    html = self.request(href)\n    helo = BeautifulSoup(html.text, &apos;lxml&apos;).find_all(&apos;span&apos;)\n    if len(helo) &lt; 10:\n        return\n    max_span = helo[10].get_text()\n    for page in range(1, int(max_span) + 1):\n        page_url = href + &apos;/&apos; + str(page)\n        self.img(page_url, path)  ##调用img函数\n</code></pre><p>上面的html方法中的后半截是执行了步骤3中的后半部分，也就是遍历了套图中其他图片所在的网页，相应的img方法如下</p>\n<pre><code>def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n    img_html = self.request(page_url)\n    helo = BeautifulSoup(img_html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;main-image&apos;)\n    if helo is not None:\n        helo1 = helo.find(&apos;img&apos;)\n        if helo1 is not None:\n            # do some thing you need\n            img_url = helo1[&apos;src&apos;]\n            self.saveImg(img_url, path)\n\ndef saveImg(self, url, path):\n    getHeaders = {\n        &apos;Host&apos;: &apos;i.meizitu.net&apos;,\n        &apos;Connection&apos;: &apos;Keep-Alive&apos;,\n        &apos;Accept&apos;: &apos;image/webp,image/apng,image/*,*/*;q=0.8&apos;,\n        &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,\n        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;,\n        &apos;Referer&apos;: &apos;http://www.mzitu.com/&apos;,\n        &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,\n        &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9&apos;\n    }\n    response = requests.get(url, headers=getHeaders)\n\n    if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n        response = requests.get(url, headers=getHeaders, allow_redirects=False)\n        if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n            name = url[-9:-4]\n            redirectUrl = response.headers[&apos;location&apos;]  # 因此需在响应头文件中获取重定向后地址\n            response = requests.get(redirectUrl)\n            fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n            fp.write(response.content)\n            fp.close()\n    else:\n        os.chdir(path)\n        name = url[-9:-4]\n        fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n        fp.write(response.content)\n        fp.close()\n        self.picNum = self.picNum + 1\n        print(self.picNum)\n</code></pre><p>方法saveImg执行了步骤4，也就是将图片保存在了本地。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本片文字是在之前微信上看到的一篇文章改写的，当时照着那篇文字将代码写了一遍之后发现，保存在本地的图片都被篡改了，也就是被防盗链了，而后就只能修改request中的一些参数来确保准确性。在上面这些完成后，发现对爬虫有了一点的了解之后想着是不是可以使用多线程的方式来爬去，就又看了多线程的写法，下面贴出多线程的代码，这里使用的线程池。</p>\n<p><strong>多线程代码</strong></p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport os\nimport threading\nimport threadpool\n\n\nclass mzitu():\n    num = 0\n    picNum = 0\n\n    def all_url(self, url):\n        self.cv = threading.Condition()\n        html = self.request(url)  ##调用request函数把套图地址传进去会返回给我们一个response\n        all_a = BeautifulSoup(html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;all&apos;).find_all(&apos;a&apos;)\n\n        task_pool = threadpool.ThreadPool(50)\n        requests = threadpool.makeRequests(self.nice, all_a)\n        for req in requests:\n            task_pool.putRequest(req)\n        task_pool.wait()\n\n    def nice(self, a):\n        title = a.get_text()\n        path = str(title).replace(&quot;?&quot;, &apos;_&apos;)  ##我注意到有个标题带有 ？  这个符号Windows系统是不能创建文件夹的所以要替换掉\n        if self.mkdir(path):  ##调用mkdir函数创建文件夹！这儿path代表的是标题title哦！！！！！不要糊涂了哦！\n            os.chdir(&quot;e:\\\\pic\\\\&quot; + path)  ##切换到目录\n            href = a[&apos;href&apos;]\n            self.html(href, &quot;e:\\\\pic\\\\&quot; + path)  ##调用html函数把href参数传递过去！href是啥还记的吧？ 就是套图的地址哦！！不要迷糊了哦！\n\n    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n        html = self.request(href)\n        helo = BeautifulSoup(html.text, &apos;lxml&apos;).find_all(&apos;span&apos;)\n        if len(helo) &lt; 10:\n            return\n        max_span = helo[10].get_text()\n        for page in range(1, int(max_span) + 1):\n            page_url = href + &apos;/&apos; + str(page)\n            self.img(page_url, path)  ##调用img函数\n\n    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n        img_html = self.request(page_url)\n        helo = BeautifulSoup(img_html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;main-image&apos;)\n        if helo is not None:\n            helo1 = helo.find(&apos;img&apos;)\n            if helo1 is not None:\n                # do some thing you need\n                img_url = helo1[&apos;src&apos;]\n                self.saveImg(img_url, path)\n\n    def mkdir(self, path):  ##这个函数创建文件夹\n        path = path.strip()\n        if path.__contains__(&quot;妲己&quot;):\n            return False\n        isExists = os.path.exists(os.path.join(&quot;e:\\\\pic\\\\&quot;, path))\n        if not isExists:\n            os.makedirs(os.path.join(&quot;e:\\\\pic\\\\&quot;, path))\n            return True\n        else:\n            return False\n\n    def request(self, url):  ##这个函数获取网页的response 然后返回\n        headers = {\n            &apos;User-Agent&apos;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}\n        content = requests.get(url, headers=headers)\n\n        return content\n\n    def saveImg(self, url, path):\n        getHeaders = {\n            &apos;Host&apos;: &apos;i.meizitu.net&apos;,\n            &apos;Connection&apos;: &apos;Keep-Alive&apos;,\n            &apos;Accept&apos;: &apos;image/webp,image/apng,image/*,*/*;q=0.8&apos;,\n            &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,\n            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;,\n            &apos;Referer&apos;: &apos;http://www.mzitu.com/&apos;,\n            &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,\n            &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9&apos;\n        }\n\n        response = requests.get(url, headers=getHeaders)\n        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n                name = url[-9:-4]\n                redirectUrl = response.headers[&apos;location&apos;]  # 因此需在响应头文件中获取重定向后地址\n                response = requests.get(redirectUrl)\n                fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n                fp.write(response.content)\n                fp.close()\n        else:\n            os.chdir(path)\n            name = url[-9:-4]\n            fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n            fp.write(response.content)\n            fp.close()\n            self.picNum = self.picNum + 1\n            print(self.picNum)\n\nMzitu = mzitu()  ##实例化\nMzitu.all_url(&apos;http://www.mzitu.com/all&apos;)  ##给函数all_url传入参数  你可以当作启动爬虫（就是入口）\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/helo004.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"文章简介\"><a href=\"#文章简介\" class=\"headerlink\" title=\"文章简介\"></a>文章简介</h3><p><strong>本文将介绍如何使用python对www.mzitu.com中所有的图片的爬取以及存储到本地最后我们会得到如下图1所示</strong></p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206142745.png\" alt=\"enter image description here\"></p>\n<p>是不是很心动，接下来就让我们开始python爬虫之旅，本期内容将会从单线程使用到多线程，从自己写python到使用scrapy包，以及分布式redis的使用，当然这些都是后话了，当前我们的目标是要爬去这个网站上的美图。</p>\n<h3 id=\"环境介绍\"><a href=\"#环境介绍\" class=\"headerlink\" title=\"环境介绍\"></a>环境介绍</h3><p>废话少说接下来就是我们的基础环境部分<br><strong>1.Python – 3.6.1</strong>（这个版本其实要区别的就是python2和python3啦，我使用的python3）</p>\n<p><strong>2.Requests</strong> （看名字就知道这个是用来进行网络请求用的，这里的request是rllib包中的，之后我们要学的scrapy中也有自己想要的request，到时候两个不要搞混了）</p>\n<p><strong>3.beautifulsoup</strong> （当然数据获取到了之后，我们要对数据进行提取，解析就是通过beautifulsoup来进行，当然我们自己也可通过正则表达式来对数据进行过滤，如果你的正则水平不错的情况下） </p>\n<p><strong>4.LXML</strong> 一个HTML解析包 用于辅助beautifulsoup解析网页  </p>\n<hr>\n<p><strong>上面的模块需要 单独安装，下面几个就不用啦。</strong></p>\n<hr>\n<p><strong>5.OS 系统内置模块</strong> （这个玩意是系统内置的，在本文中我们通过它来将图片存储在本地）</p>\n<p><strong>6.PyCharm</strong>   一个草鸡好用的PythonIDE工具 、真滴。</p>\n<h3 id=\"模块的安装\"><a href=\"#模块的安装\" class=\"headerlink\" title=\"模块的安装\"></a>模块的安装</h3><p>再使用pip指令之前我们需要安装python。（如果我们安装python时选择<strong>不将</strong>python写入环境变量的话，那么我们还需要将“文件夹\\python36”和“文件夹\\python36\\Scripts”写入path中，这样我们才能在控制台中使用python和pip指令）</p>\n<p><strong>接下来就用指令安装模块</strong></p>\n<pre><code>pip install requests   \npip install beautifulsoup4  \npip install lxml\n</code></pre><p>大致结果就如下图所示<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206150606.png\" alt=\"enter image description here\"></p>\n<p>当python + 3个模块 + PyCharm安装完成之后我们就可以开始我们本次抓取的代码编写了。</p>\n<h3 id=\"爬虫编写\"><a href=\"#爬虫编写\" class=\"headerlink\" title=\"爬虫编写\"></a>爬虫编写</h3><p><strong>首先我们先整理一下爬图片的步骤：</strong></p>\n<p>1.我们需要一个目标网站（www.mzitu.com）<br>2.我们需要从一个网页中找出接下来要去的网页的链接地址，通过beautifulsoup来获取<br>3.获取网页中的图片地址<br>4.下载图片到本地</p>\n<p><strong>步骤1：</strong><br>www.mzitu.com网站的截图如下，这里选择了www.mzitu.com/all作为起始网页，因为在该网页中包含了网站中所有图片组图的链接链接地址<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160047.png\" alt=\"enter image description here\"></p>\n<p><strong>步骤2：</strong><br>推荐使用chrome浏览器来进行网页源码的查看<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160522.png\" alt=\"enter image description here\"></p>\n<p>通过观察我们可以发现接下来的链接地址在所在的<strong>href</strong>是被<strong>div class=all</strong>所包含着的，所有我们可以使用这一点来找到所有的url地址</p>\n<p><strong>步骤3：</strong><br>接下来我们就进入到某个链接里面去看图了<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161232.png\" alt=\"enter image description here\"><br>相应图片的地址被包含在<strong>div class=’main-image’</strong>中</p>\n<p>注意着个有一套图（一般她们拍写真都有很多张的），所以呢我们就看下接下来的这张图<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161358.png\" alt=\"enter image description here\"><br>着张图里的<strong>href</strong>就是套图里其他图片所在网页的地址了，有了这个我们就可以获取接下来的图片了，其中通过观察可以发现<strong>href</strong>被包在<strong>div class=‘pagenavi’</strong>中</p>\n<p><strong>步骤4：</strong><br><strong>开始代码编写</strong></p>\n<p>我们需要在代码中引入相应的模块</p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport os\n</code></pre><p>获取起始网页内容</p>\n<pre><code>html = self.request(url)\n</code></pre><p>这里的request是下面的这个方法</p>\n<pre><code>def request(self, url):  ##这个函数获取网页的response 然后返回\n    headers = {\n    &apos;User-Agent&apos;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}\n    content = requests.get(url, headers=headers)\n\n    return content\n</code></pre><p>获取步骤1中内容（也就是所有套图的地址），并进一步发送请求获取到套图首张图片所在网页</p>\n<pre><code>all_a = BeautifulSoup(html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;all&apos;).find_all(&apos;a&apos;)\nfor a in all_a:       \n    title = a.get_text() #取出a标签的文本       \n    href = a[&apos;href&apos;] #取出a标签的href 属性，也就是套图地址\n    self.html(href, &quot;e:\\\\pic\\\\&quot; + path)\n</code></pre><p>相应的html方法</p>\n<pre><code>def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n    html = self.request(href)\n    helo = BeautifulSoup(html.text, &apos;lxml&apos;).find_all(&apos;span&apos;)\n    if len(helo) &lt; 10:\n        return\n    max_span = helo[10].get_text()\n    for page in range(1, int(max_span) + 1):\n        page_url = href + &apos;/&apos; + str(page)\n        self.img(page_url, path)  ##调用img函数\n</code></pre><p>上面的html方法中的后半截是执行了步骤3中的后半部分，也就是遍历了套图中其他图片所在的网页，相应的img方法如下</p>\n<pre><code>def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n    img_html = self.request(page_url)\n    helo = BeautifulSoup(img_html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;main-image&apos;)\n    if helo is not None:\n        helo1 = helo.find(&apos;img&apos;)\n        if helo1 is not None:\n            # do some thing you need\n            img_url = helo1[&apos;src&apos;]\n            self.saveImg(img_url, path)\n\ndef saveImg(self, url, path):\n    getHeaders = {\n        &apos;Host&apos;: &apos;i.meizitu.net&apos;,\n        &apos;Connection&apos;: &apos;Keep-Alive&apos;,\n        &apos;Accept&apos;: &apos;image/webp,image/apng,image/*,*/*;q=0.8&apos;,\n        &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,\n        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;,\n        &apos;Referer&apos;: &apos;http://www.mzitu.com/&apos;,\n        &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,\n        &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9&apos;\n    }\n    response = requests.get(url, headers=getHeaders)\n\n    if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n        response = requests.get(url, headers=getHeaders, allow_redirects=False)\n        if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n            name = url[-9:-4]\n            redirectUrl = response.headers[&apos;location&apos;]  # 因此需在响应头文件中获取重定向后地址\n            response = requests.get(redirectUrl)\n            fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n            fp.write(response.content)\n            fp.close()\n    else:\n        os.chdir(path)\n        name = url[-9:-4]\n        fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n        fp.write(response.content)\n        fp.close()\n        self.picNum = self.picNum + 1\n        print(self.picNum)\n</code></pre><p>方法saveImg执行了步骤4，也就是将图片保存在了本地。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本片文字是在之前微信上看到的一篇文章改写的，当时照着那篇文字将代码写了一遍之后发现，保存在本地的图片都被篡改了，也就是被防盗链了，而后就只能修改request中的一些参数来确保准确性。在上面这些完成后，发现对爬虫有了一点的了解之后想着是不是可以使用多线程的方式来爬去，就又看了多线程的写法，下面贴出多线程的代码，这里使用的线程池。</p>\n<p><strong>多线程代码</strong></p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport os\nimport threading\nimport threadpool\n\n\nclass mzitu():\n    num = 0\n    picNum = 0\n\n    def all_url(self, url):\n        self.cv = threading.Condition()\n        html = self.request(url)  ##调用request函数把套图地址传进去会返回给我们一个response\n        all_a = BeautifulSoup(html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;all&apos;).find_all(&apos;a&apos;)\n\n        task_pool = threadpool.ThreadPool(50)\n        requests = threadpool.makeRequests(self.nice, all_a)\n        for req in requests:\n            task_pool.putRequest(req)\n        task_pool.wait()\n\n    def nice(self, a):\n        title = a.get_text()\n        path = str(title).replace(&quot;?&quot;, &apos;_&apos;)  ##我注意到有个标题带有 ？  这个符号Windows系统是不能创建文件夹的所以要替换掉\n        if self.mkdir(path):  ##调用mkdir函数创建文件夹！这儿path代表的是标题title哦！！！！！不要糊涂了哦！\n            os.chdir(&quot;e:\\\\pic\\\\&quot; + path)  ##切换到目录\n            href = a[&apos;href&apos;]\n            self.html(href, &quot;e:\\\\pic\\\\&quot; + path)  ##调用html函数把href参数传递过去！href是啥还记的吧？ 就是套图的地址哦！！不要迷糊了哦！\n\n    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n        html = self.request(href)\n        helo = BeautifulSoup(html.text, &apos;lxml&apos;).find_all(&apos;span&apos;)\n        if len(helo) &lt; 10:\n            return\n        max_span = helo[10].get_text()\n        for page in range(1, int(max_span) + 1):\n            page_url = href + &apos;/&apos; + str(page)\n            self.img(page_url, path)  ##调用img函数\n\n    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n        img_html = self.request(page_url)\n        helo = BeautifulSoup(img_html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;main-image&apos;)\n        if helo is not None:\n            helo1 = helo.find(&apos;img&apos;)\n            if helo1 is not None:\n                # do some thing you need\n                img_url = helo1[&apos;src&apos;]\n                self.saveImg(img_url, path)\n\n    def mkdir(self, path):  ##这个函数创建文件夹\n        path = path.strip()\n        if path.__contains__(&quot;妲己&quot;):\n            return False\n        isExists = os.path.exists(os.path.join(&quot;e:\\\\pic\\\\&quot;, path))\n        if not isExists:\n            os.makedirs(os.path.join(&quot;e:\\\\pic\\\\&quot;, path))\n            return True\n        else:\n            return False\n\n    def request(self, url):  ##这个函数获取网页的response 然后返回\n        headers = {\n            &apos;User-Agent&apos;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}\n        content = requests.get(url, headers=headers)\n\n        return content\n\n    def saveImg(self, url, path):\n        getHeaders = {\n            &apos;Host&apos;: &apos;i.meizitu.net&apos;,\n            &apos;Connection&apos;: &apos;Keep-Alive&apos;,\n            &apos;Accept&apos;: &apos;image/webp,image/apng,image/*,*/*;q=0.8&apos;,\n            &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,\n            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;,\n            &apos;Referer&apos;: &apos;http://www.mzitu.com/&apos;,\n            &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,\n            &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9&apos;\n        }\n\n        response = requests.get(url, headers=getHeaders)\n        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n                name = url[-9:-4]\n                redirectUrl = response.headers[&apos;location&apos;]  # 因此需在响应头文件中获取重定向后地址\n                response = requests.get(redirectUrl)\n                fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n                fp.write(response.content)\n                fp.close()\n        else:\n            os.chdir(path)\n            name = url[-9:-4]\n            fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n            fp.write(response.content)\n            fp.close()\n            self.picNum = self.picNum + 1\n            print(self.picNum)\n\nMzitu = mzitu()  ##实例化\nMzitu.all_url(&apos;http://www.mzitu.com/all&apos;)  ##给函数all_url传入参数  你可以当作启动爬虫（就是入口）\n</code></pre>"},{"title":"Dagger2全面解析","date":"2016-06-01T15:47:44.000Z","_content":"\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/timg.jpg)\n\n### Dagger2的好处\n\n- 依赖的注入和配置独立于组件之外。\n- 因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。\n- 依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。\n\n\n### 相关标签\n\n **@Inject、@Module、@Provide、@Component**\n\n- @Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。\n\n- @Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。\n\n- @Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。\n\n- @Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。\n\n\n### 标签使用方式\n\n**1.@Inject**  \n\n    public class User {  \n  \n\t    ....  \n\t    ....  \n\t    //在被依赖类中使用@Inject标记该类的构造方法\n\t    @Inject  \n\t    public User() {  \n\t    }  \n\t  \n\t    ....  \n\t    ....    \n\t}  \n\n--------------\n\n    public class MainActivity extends AppCompatActivity {  \n\t\t  \n\t    //在依赖类中使用@Inject来注入被依赖类实例\n\t    @Inject  \n\t    User user;  \n\t    @Inject  \n\t    User user2;  \n\t    private TextView tv;  \n\t    private TextView tv2;  \n\t  \n\t    @Override  \n\t    protected void onCreate(Bundle savedInstanceState) {  \n\t        super.onCreate(savedInstanceState);  \n\t        setContentView(R.layout.activity_main);  \n\t        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n\t        DaggerActivityComponent.builder().build().inject(this);  \n\t        tv = ((TextView) findViewById(R.id.tv));  \n\t        tv2 = ((TextView) findViewById(R.id.tv2));  \n\t        tv.setText(user.toString());  \n\t        tv2.setText(user2.toString());  \n\t    }  \n\t} \n\n**2.@Component**\n\t\t\n    @Component  \n\tpublic interface ActivityComponent {  \n\t    void inject(MainActivity activity);  \n\t}  \n\n**3.@Provider & @Module**\n\n    @Module  \n\tpublic class UserModule {  \n\t    @Provides\n\t    User providesUser() {  \n\t        return new User();  \n\t    }  \n\t}  \n\n\n\n### 注入方式\n- 构造方法注入：在类的构造方法前面注释@Inject\n- 成员变量注入：在类的成员变量（非私有）前面注释@Inject\n- 函数方法注入：在函数前面注释@Inject\n\n\n### 不同类的关系\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png)\n\n\n### 编译后的生成文件与原文件及关系图\n\n**原文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png)\n\n**生成文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png)\n\n**各文件对应关系**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png)\n\n\n###  注入路径\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png)\n\n\n\n### @Scope（用于划分作用域）\n\n**javax包中自带的@Singleton,其class如下：**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png)\n\n**用户自己写的**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png)\n\n***可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别***\n\n#### 各标签的意义\n\n**@Retention**\n\nRetention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:\n1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略\n2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略\n3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.\n\n**@Documented**\n\nDocumented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 \n\n\n**@Scope**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png)\n\n\n\n### @Singleton的单例模式是如何起作用的（我只是个栗子）\n\n该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png)\n\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png)\n\n\n### @Qualifier的巧用（指哪打哪）\n\n@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。\n\n两个@Qualifier\n\n    @Qualifier\n\tpublic @interface ThemeNight {\n\t\n\t}\n\t\n\t@Qualifier\n\tpublic @interface ThemeDay {\n\t}\n\n-----------------------\n\n    @Module\n\tpublic class ThemeModule {\n\t    @Provides\n\t    @ThemeDay\n\t    Theme provideDayTheme() {\n\t        return new Theme(\"day\");\n\t    }\n\n\t    @Provides\n\t    @ThemeNight\n\t    Theme provideNightTheme() {\n\t        return new Theme(\"night\");\n\t    }\n\t}\n\n------------------\n\n    @Component\n    public interface ThemeComponent{\n\t    void inject(ThemeTest themeTest);\n    }\n    \n\n--------------------\n\n    public class ThemeTest {\n\t    @Inject\n\t    @ThemeDay\n\t    Theme dayTheme;\n\t    @Inject\n\t    @ThemeNight\n\t    Theme nightTheme;\n\n\t    public static void main(String[] arg) {\n\t        ThemeTest themeTest = new ThemeTest();\n\t        DaggerThemeComponent.create().inject(themeTest);\n\t        System.out.println(themeTest.dayTheme.themeName);\n\t        System.out.println(themeTest.nightTheme.themeName);\n\t    }\n\t}\n\n\n\n","source":"_posts/Dagger2.md","raw":"---\ntitle: Dagger2全面解析\ndate: 2016-06-01 23:47:44\ncategories: \"Android基础学习\"\ntags:\n     - Android\n     - 三方框架\n     - 技术\n---\n\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/timg.jpg)\n\n### Dagger2的好处\n\n- 依赖的注入和配置独立于组件之外。\n- 因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。\n- 依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。\n\n\n### 相关标签\n\n **@Inject、@Module、@Provide、@Component**\n\n- @Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。\n\n- @Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。\n\n- @Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。\n\n- @Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。\n\n\n### 标签使用方式\n\n**1.@Inject**  \n\n    public class User {  \n  \n\t    ....  \n\t    ....  \n\t    //在被依赖类中使用@Inject标记该类的构造方法\n\t    @Inject  \n\t    public User() {  \n\t    }  \n\t  \n\t    ....  \n\t    ....    \n\t}  \n\n--------------\n\n    public class MainActivity extends AppCompatActivity {  \n\t\t  \n\t    //在依赖类中使用@Inject来注入被依赖类实例\n\t    @Inject  \n\t    User user;  \n\t    @Inject  \n\t    User user2;  \n\t    private TextView tv;  \n\t    private TextView tv2;  \n\t  \n\t    @Override  \n\t    protected void onCreate(Bundle savedInstanceState) {  \n\t        super.onCreate(savedInstanceState);  \n\t        setContentView(R.layout.activity_main);  \n\t        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n\t        DaggerActivityComponent.builder().build().inject(this);  \n\t        tv = ((TextView) findViewById(R.id.tv));  \n\t        tv2 = ((TextView) findViewById(R.id.tv2));  \n\t        tv.setText(user.toString());  \n\t        tv2.setText(user2.toString());  \n\t    }  \n\t} \n\n**2.@Component**\n\t\t\n    @Component  \n\tpublic interface ActivityComponent {  \n\t    void inject(MainActivity activity);  \n\t}  \n\n**3.@Provider & @Module**\n\n    @Module  \n\tpublic class UserModule {  \n\t    @Provides\n\t    User providesUser() {  \n\t        return new User();  \n\t    }  \n\t}  \n\n\n\n### 注入方式\n- 构造方法注入：在类的构造方法前面注释@Inject\n- 成员变量注入：在类的成员变量（非私有）前面注释@Inject\n- 函数方法注入：在函数前面注释@Inject\n\n\n### 不同类的关系\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png)\n\n\n### 编译后的生成文件与原文件及关系图\n\n**原文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png)\n\n**生成文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png)\n\n**各文件对应关系**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png)\n\n\n###  注入路径\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png)\n\n\n\n### @Scope（用于划分作用域）\n\n**javax包中自带的@Singleton,其class如下：**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png)\n\n**用户自己写的**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png)\n\n***可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别***\n\n#### 各标签的意义\n\n**@Retention**\n\nRetention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:\n1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略\n2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略\n3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.\n\n**@Documented**\n\nDocumented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 \n\n\n**@Scope**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png)\n\n\n\n### @Singleton的单例模式是如何起作用的（我只是个栗子）\n\n该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png)\n\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png)\n\n\n### @Qualifier的巧用（指哪打哪）\n\n@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。\n\n两个@Qualifier\n\n    @Qualifier\n\tpublic @interface ThemeNight {\n\t\n\t}\n\t\n\t@Qualifier\n\tpublic @interface ThemeDay {\n\t}\n\n-----------------------\n\n    @Module\n\tpublic class ThemeModule {\n\t    @Provides\n\t    @ThemeDay\n\t    Theme provideDayTheme() {\n\t        return new Theme(\"day\");\n\t    }\n\n\t    @Provides\n\t    @ThemeNight\n\t    Theme provideNightTheme() {\n\t        return new Theme(\"night\");\n\t    }\n\t}\n\n------------------\n\n    @Component\n    public interface ThemeComponent{\n\t    void inject(ThemeTest themeTest);\n    }\n    \n\n--------------------\n\n    public class ThemeTest {\n\t    @Inject\n\t    @ThemeDay\n\t    Theme dayTheme;\n\t    @Inject\n\t    @ThemeNight\n\t    Theme nightTheme;\n\n\t    public static void main(String[] arg) {\n\t        ThemeTest themeTest = new ThemeTest();\n\t        DaggerThemeComponent.create().inject(themeTest);\n\t        System.out.println(themeTest.dayTheme.themeName);\n\t        System.out.println(themeTest.nightTheme.themeName);\n\t    }\n\t}\n\n\n\n","slug":"Dagger2","published":1,"updated":"2018-02-06T03:24:54.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdfnt20s0005j0iexm9pb95a","content":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/timg.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"Dagger2的好处\"><a href=\"#Dagger2的好处\" class=\"headerlink\" title=\"Dagger2的好处\"></a>Dagger2的好处</h3><ul>\n<li>依赖的注入和配置独立于组件之外。</li>\n<li>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</li>\n<li>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</li>\n</ul>\n<h3 id=\"相关标签\"><a href=\"#相关标签\" class=\"headerlink\" title=\"相关标签\"></a>相关标签</h3><p> <strong>@Inject、@Module、@Provide、@Component</strong></p>\n<ul>\n<li><p>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</p>\n</li>\n<li><p>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</p>\n</li>\n<li><p>@Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</p>\n</li>\n<li><p>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。</p>\n</li>\n</ul>\n<h3 id=\"标签使用方式\"><a href=\"#标签使用方式\" class=\"headerlink\" title=\"标签使用方式\"></a>标签使用方式</h3><p><strong>1.@Inject</strong>  </p>\n<pre><code>public class User {  \n\n    ....  \n    ....  \n    //在被依赖类中使用@Inject标记该类的构造方法\n    @Inject  \n    public User() {  \n    }  \n\n    ....  \n    ....    \n}  \n</code></pre><hr>\n<pre><code>public class MainActivity extends AppCompatActivity {  \n\n    //在依赖类中使用@Inject来注入被依赖类实例\n    @Inject  \n    User user;  \n    @Inject  \n    User user2;  \n    private TextView tv;  \n    private TextView tv2;  \n\n    @Override  \n    protected void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.activity_main);  \n        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n        DaggerActivityComponent.builder().build().inject(this);  \n        tv = ((TextView) findViewById(R.id.tv));  \n        tv2 = ((TextView) findViewById(R.id.tv2));  \n        tv.setText(user.toString());  \n        tv2.setText(user2.toString());  \n    }  \n} \n</code></pre><p><strong>2.@Component</strong></p>\n<pre><code>@Component  \npublic interface ActivityComponent {  \n    void inject(MainActivity activity);  \n}  \n</code></pre><p><strong>3.@Provider &amp; @Module</strong></p>\n<pre><code>@Module  \npublic class UserModule {  \n    @Provides\n    User providesUser() {  \n        return new User();  \n    }  \n}  \n</code></pre><h3 id=\"注入方式\"><a href=\"#注入方式\" class=\"headerlink\" title=\"注入方式\"></a>注入方式</h3><ul>\n<li>构造方法注入：在类的构造方法前面注释@Inject</li>\n<li>成员变量注入：在类的成员变量（非私有）前面注释@Inject</li>\n<li>函数方法注入：在函数前面注释@Inject</li>\n</ul>\n<h3 id=\"不同类的关系\"><a href=\"#不同类的关系\" class=\"headerlink\" title=\"不同类的关系\"></a>不同类的关系</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png\" alt=\"enter image description here\"></p>\n<h3 id=\"编译后的生成文件与原文件及关系图\"><a href=\"#编译后的生成文件与原文件及关系图\" class=\"headerlink\" title=\"编译后的生成文件与原文件及关系图\"></a>编译后的生成文件与原文件及关系图</h3><p><strong>原文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png\" alt=\"enter image description here\"></p>\n<p><strong>生成文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png\" alt=\"enter image description here\"></p>\n<p><strong>各文件对应关系</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png\" alt=\"enter image description here\"></p>\n<h3 id=\"注入路径\"><a href=\"#注入路径\" class=\"headerlink\" title=\"注入路径\"></a>注入路径</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Scope（用于划分作用域）\"><a href=\"#Scope（用于划分作用域）\" class=\"headerlink\" title=\"@Scope（用于划分作用域）\"></a>@Scope（用于划分作用域）</h3><p><strong>javax包中自带的@Singleton,其class如下：</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png\" alt=\"enter image description here\"></p>\n<p><strong>用户自己写的</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png\" alt=\"enter image description here\"></p>\n<p><strong><em>可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别</em></strong></p>\n<h4 id=\"各标签的意义\"><a href=\"#各标签的意义\" class=\"headerlink\" title=\"各标签的意义\"></a>各标签的意义</h4><p><strong>@Retention</strong></p>\n<p>Retention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:<br>1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略<br>2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略<br>3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.</p>\n<p><strong>@Documented</strong></p>\n<p>Documented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 </p>\n<p><strong>@Scope</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Singleton的单例模式是如何起作用的（我只是个栗子）\"><a href=\"#Singleton的单例模式是如何起作用的（我只是个栗子）\" class=\"headerlink\" title=\"@Singleton的单例模式是如何起作用的（我只是个栗子）\"></a>@Singleton的单例模式是如何起作用的（我只是个栗子）</h3><p>该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Qualifier的巧用（指哪打哪）\"><a href=\"#Qualifier的巧用（指哪打哪）\" class=\"headerlink\" title=\"@Qualifier的巧用（指哪打哪）\"></a>@Qualifier的巧用（指哪打哪）</h3><p>@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。</p>\n<p>两个@Qualifier</p>\n<pre><code>@Qualifier\npublic @interface ThemeNight {\n\n}\n\n@Qualifier\npublic @interface ThemeDay {\n}\n</code></pre><hr>\n<pre><code>@Module\npublic class ThemeModule {\n    @Provides\n    @ThemeDay\n    Theme provideDayTheme() {\n        return new Theme(&quot;day&quot;);\n    }\n\n    @Provides\n    @ThemeNight\n    Theme provideNightTheme() {\n        return new Theme(&quot;night&quot;);\n    }\n}\n</code></pre><hr>\n<pre><code>@Component\npublic interface ThemeComponent{\n    void inject(ThemeTest themeTest);\n}\n</code></pre><hr>\n<pre><code>public class ThemeTest {\n    @Inject\n    @ThemeDay\n    Theme dayTheme;\n    @Inject\n    @ThemeNight\n    Theme nightTheme;\n\n    public static void main(String[] arg) {\n        ThemeTest themeTest = new ThemeTest();\n        DaggerThemeComponent.create().inject(themeTest);\n        System.out.println(themeTest.dayTheme.themeName);\n        System.out.println(themeTest.nightTheme.themeName);\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/timg.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"Dagger2的好处\"><a href=\"#Dagger2的好处\" class=\"headerlink\" title=\"Dagger2的好处\"></a>Dagger2的好处</h3><ul>\n<li>依赖的注入和配置独立于组件之外。</li>\n<li>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</li>\n<li>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</li>\n</ul>\n<h3 id=\"相关标签\"><a href=\"#相关标签\" class=\"headerlink\" title=\"相关标签\"></a>相关标签</h3><p> <strong>@Inject、@Module、@Provide、@Component</strong></p>\n<ul>\n<li><p>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</p>\n</li>\n<li><p>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</p>\n</li>\n<li><p>@Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</p>\n</li>\n<li><p>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。</p>\n</li>\n</ul>\n<h3 id=\"标签使用方式\"><a href=\"#标签使用方式\" class=\"headerlink\" title=\"标签使用方式\"></a>标签使用方式</h3><p><strong>1.@Inject</strong>  </p>\n<pre><code>public class User {  \n\n    ....  \n    ....  \n    //在被依赖类中使用@Inject标记该类的构造方法\n    @Inject  \n    public User() {  \n    }  \n\n    ....  \n    ....    \n}  \n</code></pre><hr>\n<pre><code>public class MainActivity extends AppCompatActivity {  \n\n    //在依赖类中使用@Inject来注入被依赖类实例\n    @Inject  \n    User user;  \n    @Inject  \n    User user2;  \n    private TextView tv;  \n    private TextView tv2;  \n\n    @Override  \n    protected void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.activity_main);  \n        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n        DaggerActivityComponent.builder().build().inject(this);  \n        tv = ((TextView) findViewById(R.id.tv));  \n        tv2 = ((TextView) findViewById(R.id.tv2));  \n        tv.setText(user.toString());  \n        tv2.setText(user2.toString());  \n    }  \n} \n</code></pre><p><strong>2.@Component</strong></p>\n<pre><code>@Component  \npublic interface ActivityComponent {  \n    void inject(MainActivity activity);  \n}  \n</code></pre><p><strong>3.@Provider &amp; @Module</strong></p>\n<pre><code>@Module  \npublic class UserModule {  \n    @Provides\n    User providesUser() {  \n        return new User();  \n    }  \n}  \n</code></pre><h3 id=\"注入方式\"><a href=\"#注入方式\" class=\"headerlink\" title=\"注入方式\"></a>注入方式</h3><ul>\n<li>构造方法注入：在类的构造方法前面注释@Inject</li>\n<li>成员变量注入：在类的成员变量（非私有）前面注释@Inject</li>\n<li>函数方法注入：在函数前面注释@Inject</li>\n</ul>\n<h3 id=\"不同类的关系\"><a href=\"#不同类的关系\" class=\"headerlink\" title=\"不同类的关系\"></a>不同类的关系</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png\" alt=\"enter image description here\"></p>\n<h3 id=\"编译后的生成文件与原文件及关系图\"><a href=\"#编译后的生成文件与原文件及关系图\" class=\"headerlink\" title=\"编译后的生成文件与原文件及关系图\"></a>编译后的生成文件与原文件及关系图</h3><p><strong>原文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png\" alt=\"enter image description here\"></p>\n<p><strong>生成文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png\" alt=\"enter image description here\"></p>\n<p><strong>各文件对应关系</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png\" alt=\"enter image description here\"></p>\n<h3 id=\"注入路径\"><a href=\"#注入路径\" class=\"headerlink\" title=\"注入路径\"></a>注入路径</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Scope（用于划分作用域）\"><a href=\"#Scope（用于划分作用域）\" class=\"headerlink\" title=\"@Scope（用于划分作用域）\"></a>@Scope（用于划分作用域）</h3><p><strong>javax包中自带的@Singleton,其class如下：</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png\" alt=\"enter image description here\"></p>\n<p><strong>用户自己写的</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png\" alt=\"enter image description here\"></p>\n<p><strong><em>可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别</em></strong></p>\n<h4 id=\"各标签的意义\"><a href=\"#各标签的意义\" class=\"headerlink\" title=\"各标签的意义\"></a>各标签的意义</h4><p><strong>@Retention</strong></p>\n<p>Retention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:<br>1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略<br>2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略<br>3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.</p>\n<p><strong>@Documented</strong></p>\n<p>Documented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 </p>\n<p><strong>@Scope</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Singleton的单例模式是如何起作用的（我只是个栗子）\"><a href=\"#Singleton的单例模式是如何起作用的（我只是个栗子）\" class=\"headerlink\" title=\"@Singleton的单例模式是如何起作用的（我只是个栗子）\"></a>@Singleton的单例模式是如何起作用的（我只是个栗子）</h3><p>该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Qualifier的巧用（指哪打哪）\"><a href=\"#Qualifier的巧用（指哪打哪）\" class=\"headerlink\" title=\"@Qualifier的巧用（指哪打哪）\"></a>@Qualifier的巧用（指哪打哪）</h3><p>@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。</p>\n<p>两个@Qualifier</p>\n<pre><code>@Qualifier\npublic @interface ThemeNight {\n\n}\n\n@Qualifier\npublic @interface ThemeDay {\n}\n</code></pre><hr>\n<pre><code>@Module\npublic class ThemeModule {\n    @Provides\n    @ThemeDay\n    Theme provideDayTheme() {\n        return new Theme(&quot;day&quot;);\n    }\n\n    @Provides\n    @ThemeNight\n    Theme provideNightTheme() {\n        return new Theme(&quot;night&quot;);\n    }\n}\n</code></pre><hr>\n<pre><code>@Component\npublic interface ThemeComponent{\n    void inject(ThemeTest themeTest);\n}\n</code></pre><hr>\n<pre><code>public class ThemeTest {\n    @Inject\n    @ThemeDay\n    Theme dayTheme;\n    @Inject\n    @ThemeNight\n    Theme nightTheme;\n\n    public static void main(String[] arg) {\n        ThemeTest themeTest = new ThemeTest();\n        DaggerThemeComponent.create().inject(themeTest);\n        System.out.println(themeTest.dayTheme.themeName);\n        System.out.println(themeTest.nightTheme.themeName);\n    }\n}\n</code></pre>"},{"title":"python爬虫scrapy的使用","date":"2018-02-06T09:13:44.000Z","_content":"\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/helo005.jpg)\n\n### 简介\n**本文将记录一次使用scrapy进行网页数据爬取的经历。**\n\n### 环境与安装\n**环境**\n\npython -- 3.6.1（区别python2和python3就行了，两者的语法在有些地方有区别）\nscrapy -- 1.5.0 （这个是根据你的python版本来选择的）\ntwisted\nwheel\npywin32\n\n\n**安装python**\n这里就不再赘述了，无非就是到python的官方网站下载相应安装包安装。如果要看的话，可以看blog里的另外一篇文章，也就是《python爬妹子》这一篇，或者可以看这个网址[python安装](https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000)\n\n**安装scrapy**\n一般使用windows电脑安装时会出现安装失败的情况，故而我们需要到[这个网站](https://pypi.python.org/pypi/Scrapy/1.5.0)下载相应的版本，来进行安装在安装之前我们还需要先安装wheel只需要在cmd中敲入：\n\n    pip install wheel\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153010.png)\n\n而后我们到https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153247.png)\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153547.png)\n经过上面两部我们就将scrapy安装到了本地，但是有没有发现还是无法运行，因为还有**pywin32 和twisted没有安装**故而我们继续到https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装\n![pywin32](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153939.png)\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207154852.png)\n同样使用命令行进行安装\n\n    pip install pywin32-222-cp36-cp36m-win_amd64.whl\n    pip install Twisted-17.9.0-cp27-cp27m-win_amd64.whl\n\n\n安装好这些之后我们就可以来看下scrapy了\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207155127.png)\n\n### scrapy初涉\n之前没有接触过的小伙伴可以先看下这个网站的内容https://doc.scrapy.org/en/latest/intro/tutorial.html\n\n我们先通过下面命令行创建一个scrapy项目\n\n    scrapy startproject heloScrapy\n\n相应的文件结构如下图所示\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207161524.png)\n\n而后我们在spiders文件夹下创建一个demo.py文件，之后的主要代码都将在该文件内完成。\n引入scrapy以及相应的request，并命名为demo\n\n    import scrapy\n\tfrom tutorial.items import TutorialItem\n\tfrom scrapy.http import Request\n\t\n\tclass DmozSpider(scrapy.Spider):\n\t    name = \"demo\"\n\t    allowed_domains = [\"blog.csdn.net\", \"baidu.com\"]\n\t    start_urls = [\n        \"http://blog.csdn.net/u013687632/article/details/57075514\"\n\t    ]\n\n此处在start_urls中设置了相应的初始网址http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains 的设置使我们只爬取这个域名内的网页。\n\n在设置好以上内容之后，scrapy会将start_urls 网页的内容以response的形式传递给parse函数，下面我们就将对parse函数进行定义\n\n        def parse(self, response):\n\t        filename = response.url.split(\"/\")[-2]\n\t        with open(filename, 'wb') as f:\n\t            f.write(response.body)\n\t        for sel in response.xpath('//ul/li'):\n\t            item = TutorialItem()\n\t            item['title'] = sel.xpath('a/text()').extract()\n\t            item['link'] = sel.xpath('a/@href').extract()\n\t            item['desc'] = sel.xpath('text()').extract()\n\t            yield item\n\n\t            if sel.xpath('a/@href').extract() == '':\n\t                print('empty')\n\t            else:\n\t                if len(sel.xpath('a/@href').extract()) > 0:\n\t                    self.num = self.num + 1\n\n\t                    print('helo%s' % (self.num))\n\t                    yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)\n\n从以上内容可以看出我们的是对网页内人title、link、desc进行了抽取，同时根据link中的内容来进行接下去的网页爬取，其中需要注意的方法有一下几个：\n\n        with open(filename, 'wb') as f:\n            f.write(response.body)\n\nwith as的语法是对于有_enter_()和_exit_()方法的对象使用的，这样可以减少我们代码的书写，不让像上面的内容我们就要写出如下的形式：\n\n    file = open(\"/tmp/foo.txt\")\n\ttry:\n\t    data = file.read()\n\tfinally:\n\t    file.close()\n\n然后就是TutorialItem这个类了，该类我们定义在items.py中\n\n    import scrapy\n    \n\tclass TutorialItem(scrapy.Item):\n\t    # define the fields for your item here like:\n\t    # name = scrapy.Field()\n\t    title = scrapy.Field()\n\t    link = scrapy.Field()\n\t    desc = scrapy.Field()\n\t    pass\n\n至于sel.xpath('a/text()')就是用来过滤出我们需要的xml对象了，这个方法是lxml包中的，这个包我们在上一篇文章中已经安装过滤，也就是pip instll lxml，而该方法中的表达式该如何写，这个就要靠自己了，人总是要靠自己的。当然我们也可以看下这篇blog的内容https://www.cnblogs.com/lei0213/p/7506130.html\n\n最后你是不是对yield这个语法很困惑，这个就和生成器相关了，详细内容可以看这个blog http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return, 不同之处在于，yield返回的是一个生成器。\n\n\n最后的最后就是下面这段代码了\n\n     yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)\n\n它发起了对新的url的请求，并将返回的内容传递给parse进行处理，这就实现了新url的爬取效果。\n\n最后我们可以通过cmd输入一些命令来运行程序\n\n    scrapy crawl demo\n\n\n运行结果如下\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207164936.png)\n\n\n### 总结\n使用scrapy能够为我们提供很大的便利，如待爬取队里的建立，以及url去重等都不需要我们去做了，当然最棒的是它有一个扩展包scrapy-redis，通过使用这个包我们可以实现分布式爬取，到时候我们的爬取速度就能够有指数级的提升了（在有多台硬件设备的情况下），而后通过这大量的数据我们就可以进行一些如数据挖掘、机器学习的工作了，是不是很心动。\n","source":"_posts/python爬虫scrapy的使用.md","raw":"---\ntitle: python爬虫scrapy的使用\ndate: 2018-02-06 17:13:44\ncategories: \"python\"\ntags:\n     - python\n     - 爬虫\n     - 技术\n---\n\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/helo005.jpg)\n\n### 简介\n**本文将记录一次使用scrapy进行网页数据爬取的经历。**\n\n### 环境与安装\n**环境**\n\npython -- 3.6.1（区别python2和python3就行了，两者的语法在有些地方有区别）\nscrapy -- 1.5.0 （这个是根据你的python版本来选择的）\ntwisted\nwheel\npywin32\n\n\n**安装python**\n这里就不再赘述了，无非就是到python的官方网站下载相应安装包安装。如果要看的话，可以看blog里的另外一篇文章，也就是《python爬妹子》这一篇，或者可以看这个网址[python安装](https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000)\n\n**安装scrapy**\n一般使用windows电脑安装时会出现安装失败的情况，故而我们需要到[这个网站](https://pypi.python.org/pypi/Scrapy/1.5.0)下载相应的版本，来进行安装在安装之前我们还需要先安装wheel只需要在cmd中敲入：\n\n    pip install wheel\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153010.png)\n\n而后我们到https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153247.png)\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153547.png)\n经过上面两部我们就将scrapy安装到了本地，但是有没有发现还是无法运行，因为还有**pywin32 和twisted没有安装**故而我们继续到https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装\n![pywin32](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153939.png)\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207154852.png)\n同样使用命令行进行安装\n\n    pip install pywin32-222-cp36-cp36m-win_amd64.whl\n    pip install Twisted-17.9.0-cp27-cp27m-win_amd64.whl\n\n\n安装好这些之后我们就可以来看下scrapy了\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207155127.png)\n\n### scrapy初涉\n之前没有接触过的小伙伴可以先看下这个网站的内容https://doc.scrapy.org/en/latest/intro/tutorial.html\n\n我们先通过下面命令行创建一个scrapy项目\n\n    scrapy startproject heloScrapy\n\n相应的文件结构如下图所示\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207161524.png)\n\n而后我们在spiders文件夹下创建一个demo.py文件，之后的主要代码都将在该文件内完成。\n引入scrapy以及相应的request，并命名为demo\n\n    import scrapy\n\tfrom tutorial.items import TutorialItem\n\tfrom scrapy.http import Request\n\t\n\tclass DmozSpider(scrapy.Spider):\n\t    name = \"demo\"\n\t    allowed_domains = [\"blog.csdn.net\", \"baidu.com\"]\n\t    start_urls = [\n        \"http://blog.csdn.net/u013687632/article/details/57075514\"\n\t    ]\n\n此处在start_urls中设置了相应的初始网址http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains 的设置使我们只爬取这个域名内的网页。\n\n在设置好以上内容之后，scrapy会将start_urls 网页的内容以response的形式传递给parse函数，下面我们就将对parse函数进行定义\n\n        def parse(self, response):\n\t        filename = response.url.split(\"/\")[-2]\n\t        with open(filename, 'wb') as f:\n\t            f.write(response.body)\n\t        for sel in response.xpath('//ul/li'):\n\t            item = TutorialItem()\n\t            item['title'] = sel.xpath('a/text()').extract()\n\t            item['link'] = sel.xpath('a/@href').extract()\n\t            item['desc'] = sel.xpath('text()').extract()\n\t            yield item\n\n\t            if sel.xpath('a/@href').extract() == '':\n\t                print('empty')\n\t            else:\n\t                if len(sel.xpath('a/@href').extract()) > 0:\n\t                    self.num = self.num + 1\n\n\t                    print('helo%s' % (self.num))\n\t                    yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)\n\n从以上内容可以看出我们的是对网页内人title、link、desc进行了抽取，同时根据link中的内容来进行接下去的网页爬取，其中需要注意的方法有一下几个：\n\n        with open(filename, 'wb') as f:\n            f.write(response.body)\n\nwith as的语法是对于有_enter_()和_exit_()方法的对象使用的，这样可以减少我们代码的书写，不让像上面的内容我们就要写出如下的形式：\n\n    file = open(\"/tmp/foo.txt\")\n\ttry:\n\t    data = file.read()\n\tfinally:\n\t    file.close()\n\n然后就是TutorialItem这个类了，该类我们定义在items.py中\n\n    import scrapy\n    \n\tclass TutorialItem(scrapy.Item):\n\t    # define the fields for your item here like:\n\t    # name = scrapy.Field()\n\t    title = scrapy.Field()\n\t    link = scrapy.Field()\n\t    desc = scrapy.Field()\n\t    pass\n\n至于sel.xpath('a/text()')就是用来过滤出我们需要的xml对象了，这个方法是lxml包中的，这个包我们在上一篇文章中已经安装过滤，也就是pip instll lxml，而该方法中的表达式该如何写，这个就要靠自己了，人总是要靠自己的。当然我们也可以看下这篇blog的内容https://www.cnblogs.com/lei0213/p/7506130.html\n\n最后你是不是对yield这个语法很困惑，这个就和生成器相关了，详细内容可以看这个blog http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return, 不同之处在于，yield返回的是一个生成器。\n\n\n最后的最后就是下面这段代码了\n\n     yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)\n\n它发起了对新的url的请求，并将返回的内容传递给parse进行处理，这就实现了新url的爬取效果。\n\n最后我们可以通过cmd输入一些命令来运行程序\n\n    scrapy crawl demo\n\n\n运行结果如下\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207164936.png)\n\n\n### 总结\n使用scrapy能够为我们提供很大的便利，如待爬取队里的建立，以及url去重等都不需要我们去做了，当然最棒的是它有一个扩展包scrapy-redis，通过使用这个包我们可以实现分布式爬取，到时候我们的爬取速度就能够有指数级的提升了（在有多台硬件设备的情况下），而后通过这大量的数据我们就可以进行一些如数据挖掘、机器学习的工作了，是不是很心动。\n","slug":"python爬虫scrapy的使用","published":1,"updated":"2018-02-07T08:57:24.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdfnt20u0006j0ie7cosyht2","content":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/helo005.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><strong>本文将记录一次使用scrapy进行网页数据爬取的经历。</strong></p>\n<h3 id=\"环境与安装\"><a href=\"#环境与安装\" class=\"headerlink\" title=\"环境与安装\"></a>环境与安装</h3><p><strong>环境</strong></p>\n<p>python – 3.6.1（区别python2和python3就行了，两者的语法在有些地方有区别）<br>scrapy – 1.5.0 （这个是根据你的python版本来选择的）<br>twisted<br>wheel<br>pywin32</p>\n<p><strong>安装python</strong><br>这里就不再赘述了，无非就是到python的官方网站下载相应安装包安装。如果要看的话，可以看blog里的另外一篇文章，也就是《python爬妹子》这一篇，或者可以看这个网址<a href=\"https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000\" target=\"_blank\" rel=\"noopener\">python安装</a></p>\n<p><strong>安装scrapy</strong><br>一般使用windows电脑安装时会出现安装失败的情况，故而我们需要到<a href=\"https://pypi.python.org/pypi/Scrapy/1.5.0\" target=\"_blank\" rel=\"noopener\">这个网站</a>下载相应的版本，来进行安装在安装之前我们还需要先安装wheel只需要在cmd中敲入：</p>\n<pre><code>pip install wheel\n</code></pre><p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153010.png\" alt=\"|center\"></p>\n<p>而后我们到<a href=\"https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件</a><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153247.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153547.png\" alt=\"|center\"><br>经过上面两部我们就将scrapy安装到了本地，但是有没有发现还是无法运行，因为还有<strong>pywin32 和twisted没有安装</strong>故而我们继续到<a href=\"https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装</a><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153939.png\" alt=\"pywin32\"><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207154852.png\" alt=\"|center\"><br>同样使用命令行进行安装</p>\n<pre><code>pip install pywin32-222-cp36-cp36m-win_amd64.whl\npip install Twisted-17.9.0-cp27-cp27m-win_amd64.whl\n</code></pre><p>安装好这些之后我们就可以来看下scrapy了<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207155127.png\" alt=\"|center\"></p>\n<h3 id=\"scrapy初涉\"><a href=\"#scrapy初涉\" class=\"headerlink\" title=\"scrapy初涉\"></a>scrapy初涉</h3><p>之前没有接触过的小伙伴可以先看下这个网站的内容<a href=\"https://doc.scrapy.org/en/latest/intro/tutorial.html\" target=\"_blank\" rel=\"noopener\">https://doc.scrapy.org/en/latest/intro/tutorial.html</a></p>\n<p>我们先通过下面命令行创建一个scrapy项目</p>\n<pre><code>scrapy startproject heloScrapy\n</code></pre><p>相应的文件结构如下图所示</p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207161524.png\" alt=\"|center\"></p>\n<p>而后我们在spiders文件夹下创建一个demo.py文件，之后的主要代码都将在该文件内完成。<br>引入scrapy以及相应的request，并命名为demo</p>\n<pre><code>import scrapy\nfrom tutorial.items import TutorialItem\nfrom scrapy.http import Request\n\nclass DmozSpider(scrapy.Spider):\n    name = &quot;demo&quot;\n    allowed_domains = [&quot;blog.csdn.net&quot;, &quot;baidu.com&quot;]\n    start_urls = [\n    &quot;http://blog.csdn.net/u013687632/article/details/57075514&quot;\n    ]\n</code></pre><p>此处在start_urls中设置了相应的初始网址<a href=\"http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains</a> 的设置使我们只爬取这个域名内的网页。</p>\n<p>在设置好以上内容之后，scrapy会将start_urls 网页的内容以response的形式传递给parse函数，下面我们就将对parse函数进行定义</p>\n<pre><code>def parse(self, response):\n    filename = response.url.split(&quot;/&quot;)[-2]\n    with open(filename, &apos;wb&apos;) as f:\n        f.write(response.body)\n    for sel in response.xpath(&apos;//ul/li&apos;):\n        item = TutorialItem()\n        item[&apos;title&apos;] = sel.xpath(&apos;a/text()&apos;).extract()\n        item[&apos;link&apos;] = sel.xpath(&apos;a/@href&apos;).extract()\n        item[&apos;desc&apos;] = sel.xpath(&apos;text()&apos;).extract()\n        yield item\n\n        if sel.xpath(&apos;a/@href&apos;).extract() == &apos;&apos;:\n            print(&apos;empty&apos;)\n        else:\n            if len(sel.xpath(&apos;a/@href&apos;).extract()) &gt; 0:\n                self.num = self.num + 1\n\n                print(&apos;helo%s&apos; % (self.num))\n                yield Request(response.urljoin(sel.xpath(&apos;a/@href&apos;).extract()[0]), callback=self.parse)\n</code></pre><p>从以上内容可以看出我们的是对网页内人title、link、desc进行了抽取，同时根据link中的内容来进行接下去的网页爬取，其中需要注意的方法有一下几个：</p>\n<pre><code>with open(filename, &apos;wb&apos;) as f:\n    f.write(response.body)\n</code></pre><p>with as的语法是对于有<em>enter</em>()和<em>exit</em>()方法的对象使用的，这样可以减少我们代码的书写，不让像上面的内容我们就要写出如下的形式：</p>\n<pre><code>file = open(&quot;/tmp/foo.txt&quot;)\ntry:\n    data = file.read()\nfinally:\n    file.close()\n</code></pre><p>然后就是TutorialItem这个类了，该类我们定义在items.py中</p>\n<pre><code>import scrapy\n\nclass TutorialItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    title = scrapy.Field()\n    link = scrapy.Field()\n    desc = scrapy.Field()\n    pass\n</code></pre><p>至于sel.xpath(‘a/text()’)就是用来过滤出我们需要的xml对象了，这个方法是lxml包中的，这个包我们在上一篇文章中已经安装过滤，也就是pip instll lxml，而该方法中的表达式该如何写，这个就要靠自己了，人总是要靠自己的。当然我们也可以看下这篇blog的内容<a href=\"https://www.cnblogs.com/lei0213/p/7506130.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lei0213/p/7506130.html</a></p>\n<p>最后你是不是对yield这个语法很困惑，这个就和生成器相关了，详细内容可以看这个blog <a href=\"http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return</a>, 不同之处在于，yield返回的是一个生成器。</p>\n<p>最后的最后就是下面这段代码了</p>\n<pre><code>yield Request(response.urljoin(sel.xpath(&apos;a/@href&apos;).extract()[0]), callback=self.parse)\n</code></pre><p>它发起了对新的url的请求，并将返回的内容传递给parse进行处理，这就实现了新url的爬取效果。</p>\n<p>最后我们可以通过cmd输入一些命令来运行程序</p>\n<pre><code>scrapy crawl demo\n</code></pre><p>运行结果如下<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207164936.png\" alt=\"enter image description here\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用scrapy能够为我们提供很大的便利，如待爬取队里的建立，以及url去重等都不需要我们去做了，当然最棒的是它有一个扩展包scrapy-redis，通过使用这个包我们可以实现分布式爬取，到时候我们的爬取速度就能够有指数级的提升了（在有多台硬件设备的情况下），而后通过这大量的数据我们就可以进行一些如数据挖掘、机器学习的工作了，是不是很心动。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/helo005.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><strong>本文将记录一次使用scrapy进行网页数据爬取的经历。</strong></p>\n<h3 id=\"环境与安装\"><a href=\"#环境与安装\" class=\"headerlink\" title=\"环境与安装\"></a>环境与安装</h3><p><strong>环境</strong></p>\n<p>python – 3.6.1（区别python2和python3就行了，两者的语法在有些地方有区别）<br>scrapy – 1.5.0 （这个是根据你的python版本来选择的）<br>twisted<br>wheel<br>pywin32</p>\n<p><strong>安装python</strong><br>这里就不再赘述了，无非就是到python的官方网站下载相应安装包安装。如果要看的话，可以看blog里的另外一篇文章，也就是《python爬妹子》这一篇，或者可以看这个网址<a href=\"https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000\" target=\"_blank\" rel=\"noopener\">python安装</a></p>\n<p><strong>安装scrapy</strong><br>一般使用windows电脑安装时会出现安装失败的情况，故而我们需要到<a href=\"https://pypi.python.org/pypi/Scrapy/1.5.0\" target=\"_blank\" rel=\"noopener\">这个网站</a>下载相应的版本，来进行安装在安装之前我们还需要先安装wheel只需要在cmd中敲入：</p>\n<pre><code>pip install wheel\n</code></pre><p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153010.png\" alt=\"|center\"></p>\n<p>而后我们到<a href=\"https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件</a><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153247.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153547.png\" alt=\"|center\"><br>经过上面两部我们就将scrapy安装到了本地，但是有没有发现还是无法运行，因为还有<strong>pywin32 和twisted没有安装</strong>故而我们继续到<a href=\"https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装</a><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153939.png\" alt=\"pywin32\"><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207154852.png\" alt=\"|center\"><br>同样使用命令行进行安装</p>\n<pre><code>pip install pywin32-222-cp36-cp36m-win_amd64.whl\npip install Twisted-17.9.0-cp27-cp27m-win_amd64.whl\n</code></pre><p>安装好这些之后我们就可以来看下scrapy了<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207155127.png\" alt=\"|center\"></p>\n<h3 id=\"scrapy初涉\"><a href=\"#scrapy初涉\" class=\"headerlink\" title=\"scrapy初涉\"></a>scrapy初涉</h3><p>之前没有接触过的小伙伴可以先看下这个网站的内容<a href=\"https://doc.scrapy.org/en/latest/intro/tutorial.html\" target=\"_blank\" rel=\"noopener\">https://doc.scrapy.org/en/latest/intro/tutorial.html</a></p>\n<p>我们先通过下面命令行创建一个scrapy项目</p>\n<pre><code>scrapy startproject heloScrapy\n</code></pre><p>相应的文件结构如下图所示</p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207161524.png\" alt=\"|center\"></p>\n<p>而后我们在spiders文件夹下创建一个demo.py文件，之后的主要代码都将在该文件内完成。<br>引入scrapy以及相应的request，并命名为demo</p>\n<pre><code>import scrapy\nfrom tutorial.items import TutorialItem\nfrom scrapy.http import Request\n\nclass DmozSpider(scrapy.Spider):\n    name = &quot;demo&quot;\n    allowed_domains = [&quot;blog.csdn.net&quot;, &quot;baidu.com&quot;]\n    start_urls = [\n    &quot;http://blog.csdn.net/u013687632/article/details/57075514&quot;\n    ]\n</code></pre><p>此处在start_urls中设置了相应的初始网址<a href=\"http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains</a> 的设置使我们只爬取这个域名内的网页。</p>\n<p>在设置好以上内容之后，scrapy会将start_urls 网页的内容以response的形式传递给parse函数，下面我们就将对parse函数进行定义</p>\n<pre><code>def parse(self, response):\n    filename = response.url.split(&quot;/&quot;)[-2]\n    with open(filename, &apos;wb&apos;) as f:\n        f.write(response.body)\n    for sel in response.xpath(&apos;//ul/li&apos;):\n        item = TutorialItem()\n        item[&apos;title&apos;] = sel.xpath(&apos;a/text()&apos;).extract()\n        item[&apos;link&apos;] = sel.xpath(&apos;a/@href&apos;).extract()\n        item[&apos;desc&apos;] = sel.xpath(&apos;text()&apos;).extract()\n        yield item\n\n        if sel.xpath(&apos;a/@href&apos;).extract() == &apos;&apos;:\n            print(&apos;empty&apos;)\n        else:\n            if len(sel.xpath(&apos;a/@href&apos;).extract()) &gt; 0:\n                self.num = self.num + 1\n\n                print(&apos;helo%s&apos; % (self.num))\n                yield Request(response.urljoin(sel.xpath(&apos;a/@href&apos;).extract()[0]), callback=self.parse)\n</code></pre><p>从以上内容可以看出我们的是对网页内人title、link、desc进行了抽取，同时根据link中的内容来进行接下去的网页爬取，其中需要注意的方法有一下几个：</p>\n<pre><code>with open(filename, &apos;wb&apos;) as f:\n    f.write(response.body)\n</code></pre><p>with as的语法是对于有<em>enter</em>()和<em>exit</em>()方法的对象使用的，这样可以减少我们代码的书写，不让像上面的内容我们就要写出如下的形式：</p>\n<pre><code>file = open(&quot;/tmp/foo.txt&quot;)\ntry:\n    data = file.read()\nfinally:\n    file.close()\n</code></pre><p>然后就是TutorialItem这个类了，该类我们定义在items.py中</p>\n<pre><code>import scrapy\n\nclass TutorialItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    title = scrapy.Field()\n    link = scrapy.Field()\n    desc = scrapy.Field()\n    pass\n</code></pre><p>至于sel.xpath(‘a/text()’)就是用来过滤出我们需要的xml对象了，这个方法是lxml包中的，这个包我们在上一篇文章中已经安装过滤，也就是pip instll lxml，而该方法中的表达式该如何写，这个就要靠自己了，人总是要靠自己的。当然我们也可以看下这篇blog的内容<a href=\"https://www.cnblogs.com/lei0213/p/7506130.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lei0213/p/7506130.html</a></p>\n<p>最后你是不是对yield这个语法很困惑，这个就和生成器相关了，详细内容可以看这个blog <a href=\"http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return</a>, 不同之处在于，yield返回的是一个生成器。</p>\n<p>最后的最后就是下面这段代码了</p>\n<pre><code>yield Request(response.urljoin(sel.xpath(&apos;a/@href&apos;).extract()[0]), callback=self.parse)\n</code></pre><p>它发起了对新的url的请求，并将返回的内容传递给parse进行处理，这就实现了新url的爬取效果。</p>\n<p>最后我们可以通过cmd输入一些命令来运行程序</p>\n<pre><code>scrapy crawl demo\n</code></pre><p>运行结果如下<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207164936.png\" alt=\"enter image description here\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用scrapy能够为我们提供很大的便利，如待爬取队里的建立，以及url去重等都不需要我们去做了，当然最棒的是它有一个扩展包scrapy-redis，通过使用这个包我们可以实现分布式爬取，到时候我们的爬取速度就能够有指数级的提升了（在有多台硬件设备的情况下），而后通过这大量的数据我们就可以进行一些如数据挖掘、机器学习的工作了，是不是很心动。</p>\n"},{"title":"点击图标启动activity的过程","date":"2018-02-26T04:02:30.000Z","_content":"\n![enter image description here](http://hi.csdn.net/attachment/201108/14/0_1313305334OkCc.gif)\n\n**1.在ActivityStack.startActivityLocked（创建ActivityRecord）**\n\n**2.在ActivityStack.startActivityUncheckedLocked（创建TaskRecord）**\n\n3.startActivityLocked -->  \nstartActivityUncheckedLocked --> \nstartActivityLocked --> \nresumeTopActivityLocked --> \nstartPausingLocked \n**-binder->** \n**ApplicationThreadProxy.schedulePauseActivity -->** \n\n**（下面的两行是message的传递）**\nActivityThread.queueOrSendMessage --> \nH.handleMessage --> \n\n**ActivityThread.handlePauseActivity（真正执行pause）** \n\n**-binder->** \n**ActivityManagerProxy.activityPaused -->** \n**ActivityStack.activityPaused（在stack中做一些pause之后的处理） -->**\nActivityStack.completePauseLocked --> \n\nActivityStack.resumeTopActivityLocked(launcer已停止，需启动mainactivity) -->  \n\nActivityStack.startSpecificActivityLocked --> \n**ActivityManagerService.startProcessLocked(开始创建进程，并将ActivityThread添入其中)**\n\nProcessRecord app = getProcessRecordLocked(processName, info.uid);  \nint pid = Process.start(\"android.app.ActivityThread\",  \n                mSimpleProcessManagement ? app.processName : null, uid, uid,  \n                gids, debugFlags, null); \n\n**ActivityThread.main（启动ActivityThread）** \n**-binder->** \nActivityManagerProxy.attachApplication \n\n通过pid将processRecord取回，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作\n\n**ActivityStack.realStartActivityLocked** \n**-binder->** \n**ApplicationThreadProxy.scheduleLaunchActivity -->** \n\nActivityThread.queueOrSendMessage --> \n**ActivityThread.handleLaunchActivity（真正launcher new Activity）** \n\n这里首先调用performLaunchActivity函数来加载这个Activity类，即shy.luo.activity.MainActivity，然后调用它的onCreate函数，最后回到handleLaunchActivity函数时，再调用handleResumeActivity函数来使这个Activity进入Resumed状态，即会调用这个Activity的onResume函数，这是遵循Activity的生命周期的。\n\n**ActivityThread.performLaunchActivity -->**\n\n**1函数前面是收集要启动的Activity的相关信息，主要package和component信息**\n**2然后通过ClassLoader将shy.luo.activity.MainActivity类加载进来**\n**3接下来是创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的**\n**4后面的代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到MainActivity中去**\n**5最后还要调用MainActivity的onCreate函数**\n\n这里不是直接调用MainActivity的onCreate函数，而是通过mInstrumentation的callActivityOnCreate函数来间接调用，前面我们说过，mInstrumentation在这里的作用是监控Activity与系统的交互操作，相当于是系统运行日志。\n\n\n\n 一. Step1 - Step 11：Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；\n\n二. Step 12 - Step 16：ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；\n\n三. Step 17 - Step 24：Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；\n\n四. Step 25 - Step 27：ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；\n\n五. Step 28 - Step 35：ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。 ","source":"_posts/点击图标启动activity的过程.md","raw":"---\ntitle: 点击图标启动activity的过程\ndate: 2018-02-26 12:02:30\ncategories: \"android\"\ntags:\n     - android\n     - 源码\n     - 技术\n---\n\n![enter image description here](http://hi.csdn.net/attachment/201108/14/0_1313305334OkCc.gif)\n\n**1.在ActivityStack.startActivityLocked（创建ActivityRecord）**\n\n**2.在ActivityStack.startActivityUncheckedLocked（创建TaskRecord）**\n\n3.startActivityLocked -->  \nstartActivityUncheckedLocked --> \nstartActivityLocked --> \nresumeTopActivityLocked --> \nstartPausingLocked \n**-binder->** \n**ApplicationThreadProxy.schedulePauseActivity -->** \n\n**（下面的两行是message的传递）**\nActivityThread.queueOrSendMessage --> \nH.handleMessage --> \n\n**ActivityThread.handlePauseActivity（真正执行pause）** \n\n**-binder->** \n**ActivityManagerProxy.activityPaused -->** \n**ActivityStack.activityPaused（在stack中做一些pause之后的处理） -->**\nActivityStack.completePauseLocked --> \n\nActivityStack.resumeTopActivityLocked(launcer已停止，需启动mainactivity) -->  \n\nActivityStack.startSpecificActivityLocked --> \n**ActivityManagerService.startProcessLocked(开始创建进程，并将ActivityThread添入其中)**\n\nProcessRecord app = getProcessRecordLocked(processName, info.uid);  \nint pid = Process.start(\"android.app.ActivityThread\",  \n                mSimpleProcessManagement ? app.processName : null, uid, uid,  \n                gids, debugFlags, null); \n\n**ActivityThread.main（启动ActivityThread）** \n**-binder->** \nActivityManagerProxy.attachApplication \n\n通过pid将processRecord取回，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作\n\n**ActivityStack.realStartActivityLocked** \n**-binder->** \n**ApplicationThreadProxy.scheduleLaunchActivity -->** \n\nActivityThread.queueOrSendMessage --> \n**ActivityThread.handleLaunchActivity（真正launcher new Activity）** \n\n这里首先调用performLaunchActivity函数来加载这个Activity类，即shy.luo.activity.MainActivity，然后调用它的onCreate函数，最后回到handleLaunchActivity函数时，再调用handleResumeActivity函数来使这个Activity进入Resumed状态，即会调用这个Activity的onResume函数，这是遵循Activity的生命周期的。\n\n**ActivityThread.performLaunchActivity -->**\n\n**1函数前面是收集要启动的Activity的相关信息，主要package和component信息**\n**2然后通过ClassLoader将shy.luo.activity.MainActivity类加载进来**\n**3接下来是创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的**\n**4后面的代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到MainActivity中去**\n**5最后还要调用MainActivity的onCreate函数**\n\n这里不是直接调用MainActivity的onCreate函数，而是通过mInstrumentation的callActivityOnCreate函数来间接调用，前面我们说过，mInstrumentation在这里的作用是监控Activity与系统的交互操作，相当于是系统运行日志。\n\n\n\n 一. Step1 - Step 11：Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；\n\n二. Step 12 - Step 16：ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；\n\n三. Step 17 - Step 24：Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；\n\n四. Step 25 - Step 27：ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；\n\n五. Step 28 - Step 35：ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。 ","slug":"点击图标启动activity的过程","published":1,"updated":"2018-02-26T04:07:49.788Z","_id":"cje3pad7p0000a4iemctlasta","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"http://hi.csdn.net/attachment/201108/14/0_1313305334OkCc.gif\" alt=\"enter image description here\"></p>\n<p><strong>1.在ActivityStack.startActivityLocked（创建ActivityRecord）</strong></p>\n<p><strong>2.在ActivityStack.startActivityUncheckedLocked（创建TaskRecord）</strong></p>\n<p>3.startActivityLocked –&gt;<br>startActivityUncheckedLocked –&gt;<br>startActivityLocked –&gt;<br>resumeTopActivityLocked –&gt;<br>startPausingLocked<br><strong>-binder-&gt;</strong><br><strong>ApplicationThreadProxy.schedulePauseActivity –&gt;</strong> </p>\n<p><strong>（下面的两行是message的传递）</strong><br>ActivityThread.queueOrSendMessage –&gt;<br>H.handleMessage –&gt; </p>\n<p><strong>ActivityThread.handlePauseActivity（真正执行pause）</strong> </p>\n<p><strong>-binder-&gt;</strong><br><strong>ActivityManagerProxy.activityPaused –&gt;</strong><br><strong>ActivityStack.activityPaused（在stack中做一些pause之后的处理） –&gt;</strong><br>ActivityStack.completePauseLocked –&gt; </p>\n<p>ActivityStack.resumeTopActivityLocked(launcer已停止，需启动mainactivity) –&gt;  </p>\n<p>ActivityStack.startSpecificActivityLocked –&gt;<br><strong>ActivityManagerService.startProcessLocked(开始创建进程，并将ActivityThread添入其中)</strong></p>\n<p>ProcessRecord app = getProcessRecordLocked(processName, info.uid);<br>int pid = Process.start(“android.app.ActivityThread”,<br>                mSimpleProcessManagement ? app.processName : null, uid, uid,<br>                gids, debugFlags, null); </p>\n<p><strong>ActivityThread.main（启动ActivityThread）</strong><br><strong>-binder-&gt;</strong><br>ActivityManagerProxy.attachApplication </p>\n<p>通过pid将processRecord取回，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作</p>\n<p><strong>ActivityStack.realStartActivityLocked</strong><br><strong>-binder-&gt;</strong><br><strong>ApplicationThreadProxy.scheduleLaunchActivity –&gt;</strong> </p>\n<p>ActivityThread.queueOrSendMessage –&gt;<br><strong>ActivityThread.handleLaunchActivity（真正launcher new Activity）</strong> </p>\n<p>这里首先调用performLaunchActivity函数来加载这个Activity类，即shy.luo.activity.MainActivity，然后调用它的onCreate函数，最后回到handleLaunchActivity函数时，再调用handleResumeActivity函数来使这个Activity进入Resumed状态，即会调用这个Activity的onResume函数，这是遵循Activity的生命周期的。</p>\n<p><strong>ActivityThread.performLaunchActivity –&gt;</strong></p>\n<p><strong>1函数前面是收集要启动的Activity的相关信息，主要package和component信息</strong><br><strong>2然后通过ClassLoader将shy.luo.activity.MainActivity类加载进来</strong><br><strong>3接下来是创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的</strong><br><strong>4后面的代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到MainActivity中去</strong><br><strong>5最后还要调用MainActivity的onCreate函数</strong></p>\n<p>这里不是直接调用MainActivity的onCreate函数，而是通过mInstrumentation的callActivityOnCreate函数来间接调用，前面我们说过，mInstrumentation在这里的作用是监控Activity与系统的交互操作，相当于是系统运行日志。</p>\n<p> 一. Step1 - Step 11：Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；</p>\n<p>二. Step 12 - Step 16：ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</p>\n<p>三. Step 17 - Step 24：Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</p>\n<p>四. Step 25 - Step 27：ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</p>\n<p>五. Step 28 - Step 35：ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://hi.csdn.net/attachment/201108/14/0_1313305334OkCc.gif\" alt=\"enter image description here\"></p>\n<p><strong>1.在ActivityStack.startActivityLocked（创建ActivityRecord）</strong></p>\n<p><strong>2.在ActivityStack.startActivityUncheckedLocked（创建TaskRecord）</strong></p>\n<p>3.startActivityLocked –&gt;<br>startActivityUncheckedLocked –&gt;<br>startActivityLocked –&gt;<br>resumeTopActivityLocked –&gt;<br>startPausingLocked<br><strong>-binder-&gt;</strong><br><strong>ApplicationThreadProxy.schedulePauseActivity –&gt;</strong> </p>\n<p><strong>（下面的两行是message的传递）</strong><br>ActivityThread.queueOrSendMessage –&gt;<br>H.handleMessage –&gt; </p>\n<p><strong>ActivityThread.handlePauseActivity（真正执行pause）</strong> </p>\n<p><strong>-binder-&gt;</strong><br><strong>ActivityManagerProxy.activityPaused –&gt;</strong><br><strong>ActivityStack.activityPaused（在stack中做一些pause之后的处理） –&gt;</strong><br>ActivityStack.completePauseLocked –&gt; </p>\n<p>ActivityStack.resumeTopActivityLocked(launcer已停止，需启动mainactivity) –&gt;  </p>\n<p>ActivityStack.startSpecificActivityLocked –&gt;<br><strong>ActivityManagerService.startProcessLocked(开始创建进程，并将ActivityThread添入其中)</strong></p>\n<p>ProcessRecord app = getProcessRecordLocked(processName, info.uid);<br>int pid = Process.start(“android.app.ActivityThread”,<br>                mSimpleProcessManagement ? app.processName : null, uid, uid,<br>                gids, debugFlags, null); </p>\n<p><strong>ActivityThread.main（启动ActivityThread）</strong><br><strong>-binder-&gt;</strong><br>ActivityManagerProxy.attachApplication </p>\n<p>通过pid将processRecord取回，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作</p>\n<p><strong>ActivityStack.realStartActivityLocked</strong><br><strong>-binder-&gt;</strong><br><strong>ApplicationThreadProxy.scheduleLaunchActivity –&gt;</strong> </p>\n<p>ActivityThread.queueOrSendMessage –&gt;<br><strong>ActivityThread.handleLaunchActivity（真正launcher new Activity）</strong> </p>\n<p>这里首先调用performLaunchActivity函数来加载这个Activity类，即shy.luo.activity.MainActivity，然后调用它的onCreate函数，最后回到handleLaunchActivity函数时，再调用handleResumeActivity函数来使这个Activity进入Resumed状态，即会调用这个Activity的onResume函数，这是遵循Activity的生命周期的。</p>\n<p><strong>ActivityThread.performLaunchActivity –&gt;</strong></p>\n<p><strong>1函数前面是收集要启动的Activity的相关信息，主要package和component信息</strong><br><strong>2然后通过ClassLoader将shy.luo.activity.MainActivity类加载进来</strong><br><strong>3接下来是创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的</strong><br><strong>4后面的代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到MainActivity中去</strong><br><strong>5最后还要调用MainActivity的onCreate函数</strong></p>\n<p>这里不是直接调用MainActivity的onCreate函数，而是通过mInstrumentation的callActivityOnCreate函数来间接调用，前面我们说过，mInstrumentation在这里的作用是监控Activity与系统的交互操作，相当于是系统运行日志。</p>\n<p> 一. Step1 - Step 11：Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；</p>\n<p>二. Step 12 - Step 16：ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</p>\n<p>三. Step 17 - Step 24：Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</p>\n<p>四. Step 25 - Step 27：ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</p>\n<p>五. Step 28 - Step 35：ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。 </p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjdfnt20s0005j0iexm9pb95a","category_id":"cjdfnt20o0002j0iemoocupfx","_id":"cjdfnt20x0009j0ie7dwnqte6"},{"post_id":"cjdfnt20g0000j0ie68obd3cl","category_id":"cjdfnt20o0002j0iemoocupfx","_id":"cjdfnt20y000cj0ieyn4smmpw"},{"post_id":"cjdfnt20l0001j0ievhbj3vy4","category_id":"cjdfnt20o0002j0iemoocupfx","_id":"cjdfnt20z000dj0iex0bx31ea"},{"post_id":"cjdfnt20r0004j0iebuer9fls","category_id":"cjdfnt20x000aj0iegwqpzbd7","_id":"cjdfnt210000hj0iegp7jjex0"},{"post_id":"cjdfnt20u0006j0ie7cosyht2","category_id":"cjdfnt20x000aj0iegwqpzbd7","_id":"cjdfnt211000lj0iemjoqrcsi"},{"post_id":"cje3pad7p0000a4iemctlasta","category_id":"cje3pd2np000010iemojpx6mn","_id":"cje3pd2nt000310ievna63pwk"}],"PostTag":[{"post_id":"cjdfnt20g0000j0ie68obd3cl","tag_id":"cjdfnt20q0003j0iet0cxdoqg","_id":"cjdfnt210000gj0ierh1k0wk2"},{"post_id":"cjdfnt20g0000j0ie68obd3cl","tag_id":"cjdfnt20v0008j0iegp3x1fwy","_id":"cjdfnt211000ij0iejp0p849a"},{"post_id":"cjdfnt20g0000j0ie68obd3cl","tag_id":"cjdfnt20y000bj0ie1z3fk923","_id":"cjdfnt211000kj0iecsx8zhl0"},{"post_id":"cjdfnt20l0001j0ievhbj3vy4","tag_id":"cjdfnt20q0003j0iet0cxdoqg","_id":"cjdfnt211000mj0iefd20c9gn"},{"post_id":"cjdfnt20r0004j0iebuer9fls","tag_id":"cjdfnt211000jj0ies6aol9qg","_id":"cjdfnt213000qj0iev01x2sbj"},{"post_id":"cjdfnt20r0004j0iebuer9fls","tag_id":"cjdfnt212000nj0iedgk1uvyo","_id":"cjdfnt213000rj0iex4xlo84g"},{"post_id":"cjdfnt20r0004j0iebuer9fls","tag_id":"cjdfnt20y000bj0ie1z3fk923","_id":"cjdfnt214000tj0iew08gzsf7"},{"post_id":"cjdfnt20s0005j0iexm9pb95a","tag_id":"cjdfnt20q0003j0iet0cxdoqg","_id":"cjdfnt215000vj0ie5ckrlttm"},{"post_id":"cjdfnt20s0005j0iexm9pb95a","tag_id":"cjdfnt213000pj0ieq95n8fel","_id":"cjdfnt215000wj0ieg0b55gmb"},{"post_id":"cjdfnt20s0005j0iexm9pb95a","tag_id":"cjdfnt20y000bj0ie1z3fk923","_id":"cjdfnt216000yj0ie7o96jviv"},{"post_id":"cjdfnt20u0006j0ie7cosyht2","tag_id":"cjdfnt211000jj0ies6aol9qg","_id":"cjdfnt2160010j0ieraupb6kw"},{"post_id":"cjdfnt20u0006j0ie7cosyht2","tag_id":"cjdfnt212000nj0iedgk1uvyo","_id":"cjdfnt2170011j0iepewss1oi"},{"post_id":"cjdfnt20u0006j0ie7cosyht2","tag_id":"cjdfnt20y000bj0ie1z3fk923","_id":"cjdfnt2170012j0iei9cyuh49"},{"post_id":"cje3pad7p0000a4iemctlasta","tag_id":"cje3pd2nq000110iek46vtoff","_id":"cje3pd2nu000410iesrhps05y"},{"post_id":"cje3pad7p0000a4iemctlasta","tag_id":"cje3pd2ns000210ie1nlalq88","_id":"cje3pd2nu000510ieo992cfir"},{"post_id":"cje3pad7p0000a4iemctlasta","tag_id":"cjdfnt20y000bj0ie1z3fk923","_id":"cje3pd2nv000610iezgzjc4ol"}],"Tag":[{"name":"Android","_id":"cjdfnt20q0003j0iet0cxdoqg"},{"name":"测试","_id":"cjdfnt20v0008j0iegp3x1fwy"},{"name":"技术","_id":"cjdfnt20y000bj0ie1z3fk923"},{"name":"python","_id":"cjdfnt211000jj0ies6aol9qg"},{"name":"爬虫","_id":"cjdfnt212000nj0iedgk1uvyo"},{"name":"三方框架","_id":"cjdfnt213000pj0ieq95n8fel"},{"name":"android","_id":"cje3pd2nq000110iek46vtoff"},{"name":"源码","_id":"cje3pd2ns000210ie1nlalq88"}]}}