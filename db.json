{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/LICENSE","hash":"4c3927c82d0aa4fac5cdf945e07afe5e24335891","modified":1517882480948},{"_id":"themes/BlueLake/README.en.md","hash":"6cc6e346635bf26dd71030b9c3c6443507cd4108","modified":1517882480948},{"_id":"themes/BlueLake/_config.yml","hash":"5baf7e3dcf77588223fcbe662b07ad62023b43bf","modified":1517886451414},{"_id":"themes/BlueLake/README.md","hash":"66c3ef7a779b6d65bad90daa2e03bcb7a1bb742f","modified":1517882480949},{"_id":"themes/BlueLake/package.json","hash":"cdef382c442618b24305fd3e38ac7a3accf87aa9","modified":1517882480956},{"_id":"source/_posts/Android自动化测试.md","hash":"a1cbe08b4af305f75221e43ba491d1a7170b9fa2","modified":1517888476280},{"_id":"source/_posts/面试题1.md","hash":"cb8766a140798c6f6cbd6c1da5f052d4d7cb231f","modified":1519631791332},{"_id":"source/_posts/面试题2.md","hash":"9ea6ce743154c4090ba040754136d15fbe144f0b","modified":1519701578972},{"_id":"source/_posts/Dagger2.md","hash":"c7ce231d70d019afd691445dba25b3dac15b5d5e","modified":1517887494935},{"_id":"source/_posts/面试题4.md","hash":"28f9a13e4b24a17f79bc3200e41067e604257141","modified":1519723607484},{"_id":"source/_posts/面试题3.md","hash":"b922d606549c23831f049c307853728bfe6ede67","modified":1519716825805},{"_id":"source/_posts/compileSdkVersion, minSdkVersion， targetSdkVersion这三兄弟.md","hash":"cff72d77399b0c1756f7ed3bd9055bdeb09bb049","modified":1517888360580},{"_id":"source/_posts/python爬虫scrapy的使用.md","hash":"5e926b0d531501c746022ea2325415229c2766aa","modified":1517993844299},{"_id":"themes/BlueLake/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1517882480940},{"_id":"themes/BlueLake/.git/config","hash":"05165d804714e9c1a0e5d4a99a95a77f34d4fac6","modified":1517882480943},{"_id":"source/_posts/python抓妹子.md","hash":"691943b1095d55ae70aa801497dbe6e64b3178cb","modified":1517907247083},{"_id":"source/_posts/点击图标启动activity的过程.md","hash":"6b669a06eaf264717032c1b3e496ee95962840aa","modified":1519618069788},{"_id":"themes/BlueLake/.git/index","hash":"fe3d8040723435f9b49be2f5605e66ddce03c3e7","modified":1517886833431},{"_id":"themes/BlueLake/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1517882477479},{"_id":"themes/BlueLake/.git/packed-refs","hash":"842a64dcd40e108353d1da6314a0c447e35b921d","modified":1517882480937},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"d7f5842295509746f878e627c4c7e298f3f1613a","modified":1517884275631},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"bd97d5e4b39d30da1644b90256dfc4e6b1d76988","modified":1517882480950},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"baa68725feeec6643f875a532a9d55ba8aacdb2c","modified":1517882480950},{"_id":"themes/BlueLake/languages/en.yml","hash":"95bac2c366505d016b5defc47370679b9f5f3c4b","modified":1517882480949},{"_id":"themes/BlueLake/languages/ko.yml","hash":"fc8826724f570136d9a2d3ec2705b7b7000e0f14","modified":1517882480950},{"_id":"themes/BlueLake/languages/tr.yml","hash":"5f13d55fdd5bdd1115075736e3e26a1ea1dd1dea","modified":1517882480950},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"d4d587ba81864910715c0c3879605cc6a9362e09","modified":1517882480951},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"d7f5842295509746f878e627c4c7e298f3f1613a","modified":1517882480950},{"_id":"themes/BlueLake/layout/archive.jade","hash":"98d9fb812edbc180878fdadb65bc38499eef2cc4","modified":1517882480955},{"_id":"themes/BlueLake/layout/category.jade","hash":"9f3a9f1d6f0bbad258b308ad8d49128c05b422cf","modified":1517882480955},{"_id":"themes/BlueLake/layout/page.jade","hash":"415404398931d98db28bff723886b07dcb8bbbc3","modified":1517882480955},{"_id":"themes/BlueLake/layout/index.jade","hash":"dd81d9f7a6b388de2ab731b17b3ba55f70df4a5f","modified":1517882480955},{"_id":"themes/BlueLake/layout/tag.jade","hash":"50c7af7565751db5d7672beb434768885fb224cb","modified":1517882480956},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1517882480956},{"_id":"themes/BlueLake/layout/post.jade","hash":"0305258c33e4d02f977ee1aaf7f2429b993fda17","modified":1517882480956},{"_id":"themes/BlueLake/layout/base.jade","hash":"ee19d63543f898336dee846ed45d932239c40fe0","modified":1517882480955},{"_id":"themes/BlueLake/source/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1517882480957},{"_id":"themes/BlueLake/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1517882477480},{"_id":"themes/BlueLake/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1517882477481},{"_id":"themes/BlueLake/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1517882477480},{"_id":"themes/BlueLake/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1517882477481},{"_id":"themes/BlueLake/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1517882477483},{"_id":"themes/BlueLake/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1517882477482},{"_id":"themes/BlueLake/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1517882477482},{"_id":"themes/BlueLake/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1517882477482},{"_id":"themes/BlueLake/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1517882477484},{"_id":"themes/BlueLake/.git/logs/HEAD","hash":"2f7a0fbd99e0608fd3683ee2a67d30c4c23e234e","modified":1517882480941},{"_id":"themes/BlueLake/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1517882477483},{"_id":"themes/BlueLake/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1517882477484},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"c1f1955d12aee22a931a3f4ad9d0e9a408e80f3c","modified":1517882480951},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"21d05990aa5a19632f9ed51085ef7727adeea17a","modified":1517882480951},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"3f11d2b5a4c647bf2b37c4d00bdc250cda80b770","modified":1517882480951},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/mathjax.jade","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/mathjax2.jade","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"e0aa5d7adc1218a324a484abe3513e9545f89067","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1517882480953},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"d970c81b5cdbd7c0348ee28e93bcbb006d613b6d","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"c632919f04194dcf6e0e8ccc572554a859aa922b","modified":1517882480953},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"6e587b7d254d0d92b959ba58262f5e81b618eba2","modified":1517882480953},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"0107affa0c6b22e09546fcf82a6f71ba2dd1e315","modified":1517882480954},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1517882480953},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"164a83faaf92ec19d268fd303bf6e30348ddef5c","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"c75308c2b72456cfb98cb80f280c66e58f171705","modified":1517882480954},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"ba0839518db2cb9dafee67ca5e471219bfba2e90","modified":1517882480953},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"4e90378aa88c5694126dc8ea5bed3bb2f8642e53","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"9af40206a525db1cb9761fa6facb36332057acf3","modified":1517882480954},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"4f2fba7fcb39a6bf70ff04dad9a3dab2563b21e7","modified":1517882480953},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"c6f778d5d2f13bacbd83a56a9e9faaeac0dda0ed","modified":1517882480954},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"92b5c306f276f8ea6a134e303b1b63612d25ecfe","modified":1517882480957},{"_id":"themes/BlueLake/source/css/style.styl","hash":"45776bc176bc8ed0d664e953e23d6a0a9a030929","modified":1517882480957},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1517882480958},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1517882480959},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1517882480958},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1517882480959},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"7ce826f7b678ff3c524fce8bbd480c188e50c7ee","modified":1517882480960},{"_id":"themes/BlueLake/source/js/totop.js","hash":"d9367c6fa3e973bc5f32ce38d951858455726a02","modified":1517882480961},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"9e68d688f2f12ec193ce9496beb0fd42e1de2288","modified":1517882480960},{"_id":"themes/BlueLake/.git/objects/pack/pack-3960201a6b68eb8fa7ccb74fce2c388277a0b0ef.idx","hash":"72b864447dcf0acf0212056587453d6cbed114af","modified":1517882480900},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1517882480960},{"_id":"themes/BlueLake/.git/refs/heads/master","hash":"c292cfc66fa6a171bcb9e25157b4ee8f09da6755","modified":1517882480941},{"_id":"themes/BlueLake/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1517882480939},{"_id":"themes/BlueLake/.git/logs/refs/heads/master","hash":"2f7a0fbd99e0608fd3683ee2a67d30c4c23e234e","modified":1517882480942},{"_id":"themes/BlueLake/.git/logs/refs/remotes/origin/HEAD","hash":"2f7a0fbd99e0608fd3683ee2a67d30c4c23e234e","modified":1517882480939},{"_id":"themes/BlueLake/.git/objects/pack/pack-3960201a6b68eb8fa7ccb74fce2c388277a0b0ef.pack","hash":"dba040ba1c38e38283e16f9ff438852ac811a55a","modified":1517882480903},{"_id":"public/2018/02/26/点击图标启动activity的过程/index.html","hash":"daf0f0f7193bb7abc8a29c03fb1c3db80631a06b","modified":1519813143877},{"_id":"public/archives/index.html","hash":"bf9f998ec26fe6208a75b8923cf00225a19d9d70","modified":1519813143877},{"_id":"public/archives/2016/index.html","hash":"fd88f95ff964eb812d317f8234d1f768fda3dd64","modified":1519813143877},{"_id":"public/archives/2016/06/index.html","hash":"fd88f95ff964eb812d317f8234d1f768fda3dd64","modified":1519813143877},{"_id":"public/archives/2018/index.html","hash":"c3098fd39a5124d145ecd172bd6bcab6f6b96bcb","modified":1519813143877},{"_id":"public/archives/2018/02/index.html","hash":"c3098fd39a5124d145ecd172bd6bcab6f6b96bcb","modified":1519813143878},{"_id":"public/tags/Android/index.html","hash":"a4d452ec8bad428f4d55f30721ba44c877f16996","modified":1519813143878},{"_id":"public/tags/测试/index.html","hash":"ea7aa9d3583811d69bfd7af1337c4a6b0524e9d1","modified":1519813143878},{"_id":"public/tags/技术/index.html","hash":"e06eb662b18df1604d145f38f5e5989f7f9326ef","modified":1519813143878},{"_id":"public/tags/三方框架/index.html","hash":"38542e7f444e98405acbed32a28065c06ed13675","modified":1519813143878},{"_id":"public/tags/python/index.html","hash":"d818874b5246a3de93d1f50ed1657ee95f1c20ba","modified":1519813143878},{"_id":"public/tags/爬虫/index.html","hash":"b2eae6e0f5a20d29046e09d86ff59506a0aee3da","modified":1519813143878},{"_id":"public/tags/android/index.html","hash":"fbe9bb3fe5a7b132912ab016fd9f7733726fd20a","modified":1519813143878},{"_id":"public/index.html","hash":"d8cd8820b71186b5f25451df35895da786b7b42b","modified":1519813143878},{"_id":"public/categories/Android基础学习/index.html","hash":"2972f993cd0a2b68ac0154c0d5ecbd723b77cf23","modified":1519813143878},{"_id":"public/categories/python/index.html","hash":"26cab063ab514ecd446a4ae1d91d67349110edb7","modified":1519813143878},{"_id":"public/2018/02/06/python爬虫scrapy的使用/index.html","hash":"adb0ca258ddf66f204266a18664e10ecd6bb5552","modified":1519813143878},{"_id":"public/2018/02/06/python抓妹子/index.html","hash":"1dde4fc4b370dec2dd5ed489bd8dfa53c54fadbd","modified":1519813143879},{"_id":"public/2016/06/01/Android自动化测试/index.html","hash":"600b2f80ce1cb6baee4812b317d9456272993d88","modified":1519813143879},{"_id":"public/2016/06/01/Dagger2/index.html","hash":"da3cad3aa93ba68e37fcaff3dbff21ee40e670c8","modified":1519813143879},{"_id":"public/2016/06/01/compileSdkVersion, minSdkVersion， targetSdkVersion这三兄弟/index.html","hash":"a031b57d6cf3695577e9c0a809812c1c31075002","modified":1519813143879},{"_id":"public/2018/02/27/面试题4/index.html","hash":"4b180edbb1499bb7542a7e4e57c8007614e96a4c","modified":1519813143877},{"_id":"public/2018/02/27/面试题3/index.html","hash":"62042ec96a3233951caf6deee8c24587831f6786","modified":1519813143876},{"_id":"public/2018/02/27/面试题2/index.html","hash":"fe37cc288c96e9f73c505b82d582bc72fe529f8b","modified":1519813143877},{"_id":"public/2018/02/27/面试题1/index.html","hash":"cfb7e56dec4bf6b7ffb908ac16e0fa60fc570b77","modified":1519813143877},{"_id":"public/tags/源码/index.html","hash":"5979cb4971d99fa14e041f09f95e95a98a2bad3a","modified":1519813143878},{"_id":"public/categories/android/index.html","hash":"a1ff01d5bec8dc4a5916695d644b076f3773ac54","modified":1519813143878},{"_id":"public/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1519727422165},{"_id":"public/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1519727422165},{"_id":"public/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1519727422165},{"_id":"public/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1519727422166},{"_id":"public/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1519727422166},{"_id":"public/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1519727422166},{"_id":"public/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1519727422446},{"_id":"public/css/highlight.css","hash":"fb0403feb34cc8bb8b1f28f238540d36588b86df","modified":1519727422450},{"_id":"public/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1519727422451},{"_id":"public/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1519727422451},{"_id":"public/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1519727422451},{"_id":"public/css/style.css","hash":"0b87f0674cad37ed4006f989cca7e1cd9f9568a3","modified":1519727422451},{"_id":"source/_posts/面试题5.md","hash":"307abd9ac5ed4fd4ba92a28bd3b5e1a0a32faefa","modified":1519788485913},{"_id":"source/_posts/面试题6.md","hash":"6f8adeb11c3fc3f44e3b11ae6cd399c3ab3081e3","modified":1519813065933},{"_id":"public/2018/02/28/面试题6/index.html","hash":"d3d8edace30493f97fba25e6a40eb4915afa983a","modified":1519813143879},{"_id":"public/2018/02/28/面试题5/index.html","hash":"72fc222d9c213a66d7f9e97838186b3622398775","modified":1519813143879},{"_id":"public/archives/page/2/index.html","hash":"86aaa3035f5257f771eac6258c3f5955da076b96","modified":1519813143880},{"_id":"public/page/2/index.html","hash":"58b5ad147d72f55e83f943780bcabed95fd0f246","modified":1519813143880}],"Category":[{"name":"Android基础学习","_id":"cje5igux300048gie159j4x4k"},{"name":"python","_id":"cje5iguxe000g8gieg9njy156"},{"name":"android","_id":"cje5iguxi000l8gie2thkvamo"}],"Data":[],"Page":[],"Post":[{"_content":"1.4种启动方式\n2.service的两者启动方式：\n\tstartService\n\tbindService --> 使用serviceConnection监听获取相应的binder来调用service的服务\n\n3.BroadcastReceiver的两者注册方式：\n\t静态注册 --> 生命周期与应用无关，当应用关闭时仍监听广播\n\t动态注册 --> 生命周期从被注册开始到应用结束或被unregister\n\n\t无序广播（sendBroadcast） --> 所有广播接收器同时接收广播 \n\t有序广播（sendOrderedBroadcast） --> 广播接收器按优先级进行广播的接收 ，高优先级的receiver先接收，而后可以对广播进行处理，如setResultData（设置广播内容）、abortBroadcast（终止广播）\n\n4.HttpClient和HttpUrlConnection的选择\n\t在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。\n\n\tHttpUrlConnection的bug比如说对一个可读的InputStream调用close()方法时，就有可能会导致连接池失效了。那么我们通常的解决办法就是直接禁用掉连接池的功能\n\n\t而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。对于新的应用程序应该更加偏向于使用HttpURLConnection，因为在以后的工作当中我们也会将更多的时间放在优化HttpURLConnection上面。\n\n5.HTTP 和 HTTPS 的不同之处\n\tHTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头\n\tHTTP 是不安全的，而 HTTPS 是安全的\n\tHTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443\n\t在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层\n\tHTTP 无需加密，而 HTTPS 对传输的数据进行加密\n\tHTTP 无需证书，而 HTTPS 需要认证证书\n\n\t使用 HTTPS 连接时，服务器要求有公钥和签名的证书。\n\n\tHTTP 包含如下动作：\n\n\t\t浏览器打开一个 TCP 连接\n\t\t浏览器发送 HTTP 请求到服务器端\n\t\t服务器发送 HTTP 回应信息到浏览器\n\t\tTCP 连接关闭\n\t\n\tSSL 包含如下动作：\n\n\t\t验证服务器端\n\t\t允许客户端和服务器端选择加密算法和密码，确保双方都支持\n\t\t验证客户端(可选)\n\t\t使用公钥加密技术来生成共享加密数据\n\t\t创建一个加密的 SSL 连接\n\t\t基于该 SSL 连接传递 HTTP 请求\n\n\t对称密钥与非对称密钥一起使用：\n\t\t1.客户端向服务器端发起SSL连接请求；（在此过程中依然存在数据被中间方盗取的可能，下面将会说明如何保证此过程的安全）\n\n        2 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥；\n\n        3.客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端；\n\n        4.服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），这样保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。\n\n        5.进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。\n\n    CA（电子商务认证机构）认证作用： \n    \t在上面提到的 客户端向服务器端发起请求时存在数据被盗取的过程：  假如服务器端经由中间方向客户端发送公钥的时候，中间方没有将公钥发送给客户端，而是伪造了医药公钥，并将伪造的公钥发送给客户端，此时客户端用中间方伪造的公钥对自己正确的对称秘钥加密并由中间方发送给服务器端，而中间方将用自己伪造的公钥的私钥对其进行解密，得到正确的对称秘钥，并将得到的正确的对称秘钥用服务器端发过来的公钥进行加密发给服务器端，服务器daunt再用正确的私钥进行解密，也得到正确的对称秘钥，此时客户端，服务器端，中间方三者都拥有一套正确的对称秘钥，可以对传送的数据进行加密，解密。\n\n\n    \t为了解决上述问题，一般情况下，服务器端会向CA申请认证书，此证书包含了CA及服务器端的一些信息（可以理解为类似公章），这样，服务器端将证书发给客户端的过程中，中间方是无法伪造的，保证了，发给客户端的公钥是服务器端发送的。\n\n\n\n","source":"_posts/面试题1.md","raw":"1.4种启动方式\n2.service的两者启动方式：\n\tstartService\n\tbindService --> 使用serviceConnection监听获取相应的binder来调用service的服务\n\n3.BroadcastReceiver的两者注册方式：\n\t静态注册 --> 生命周期与应用无关，当应用关闭时仍监听广播\n\t动态注册 --> 生命周期从被注册开始到应用结束或被unregister\n\n\t无序广播（sendBroadcast） --> 所有广播接收器同时接收广播 \n\t有序广播（sendOrderedBroadcast） --> 广播接收器按优先级进行广播的接收 ，高优先级的receiver先接收，而后可以对广播进行处理，如setResultData（设置广播内容）、abortBroadcast（终止广播）\n\n4.HttpClient和HttpUrlConnection的选择\n\t在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。\n\n\tHttpUrlConnection的bug比如说对一个可读的InputStream调用close()方法时，就有可能会导致连接池失效了。那么我们通常的解决办法就是直接禁用掉连接池的功能\n\n\t而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。对于新的应用程序应该更加偏向于使用HttpURLConnection，因为在以后的工作当中我们也会将更多的时间放在优化HttpURLConnection上面。\n\n5.HTTP 和 HTTPS 的不同之处\n\tHTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头\n\tHTTP 是不安全的，而 HTTPS 是安全的\n\tHTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443\n\t在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层\n\tHTTP 无需加密，而 HTTPS 对传输的数据进行加密\n\tHTTP 无需证书，而 HTTPS 需要认证证书\n\n\t使用 HTTPS 连接时，服务器要求有公钥和签名的证书。\n\n\tHTTP 包含如下动作：\n\n\t\t浏览器打开一个 TCP 连接\n\t\t浏览器发送 HTTP 请求到服务器端\n\t\t服务器发送 HTTP 回应信息到浏览器\n\t\tTCP 连接关闭\n\t\n\tSSL 包含如下动作：\n\n\t\t验证服务器端\n\t\t允许客户端和服务器端选择加密算法和密码，确保双方都支持\n\t\t验证客户端(可选)\n\t\t使用公钥加密技术来生成共享加密数据\n\t\t创建一个加密的 SSL 连接\n\t\t基于该 SSL 连接传递 HTTP 请求\n\n\t对称密钥与非对称密钥一起使用：\n\t\t1.客户端向服务器端发起SSL连接请求；（在此过程中依然存在数据被中间方盗取的可能，下面将会说明如何保证此过程的安全）\n\n        2 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥；\n\n        3.客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端；\n\n        4.服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），这样保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。\n\n        5.进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。\n\n    CA（电子商务认证机构）认证作用： \n    \t在上面提到的 客户端向服务器端发起请求时存在数据被盗取的过程：  假如服务器端经由中间方向客户端发送公钥的时候，中间方没有将公钥发送给客户端，而是伪造了医药公钥，并将伪造的公钥发送给客户端，此时客户端用中间方伪造的公钥对自己正确的对称秘钥加密并由中间方发送给服务器端，而中间方将用自己伪造的公钥的私钥对其进行解密，得到正确的对称秘钥，并将得到的正确的对称秘钥用服务器端发过来的公钥进行加密发给服务器端，服务器daunt再用正确的私钥进行解密，也得到正确的对称秘钥，此时客户端，服务器端，中间方三者都拥有一套正确的对称秘钥，可以对传送的数据进行加密，解密。\n\n\n    \t为了解决上述问题，一般情况下，服务器端会向CA申请认证书，此证书包含了CA及服务器端的一些信息（可以理解为类似公章），这样，服务器端将证书发给客户端的过程中，中间方是无法伪造的，保证了，发给客户端的公钥是服务器端发送的。\n\n\n\n","slug":"面试题1","published":1,"date":"2018-02-27T10:29:44.169Z","updated":"2018-02-26T07:56:31.332Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5iguwt00008giem6qaj16q","content":"<p>1.4种启动方式<br>2.service的两者启动方式：<br>    startService<br>    bindService –&gt; 使用serviceConnection监听获取相应的binder来调用service的服务</p>\n<p>3.BroadcastReceiver的两者注册方式：<br>    静态注册 –&gt; 生命周期与应用无关，当应用关闭时仍监听广播<br>    动态注册 –&gt; 生命周期从被注册开始到应用结束或被unregister</p>\n<pre><code>无序广播（sendBroadcast） --&gt; 所有广播接收器同时接收广播 \n有序广播（sendOrderedBroadcast） --&gt; 广播接收器按优先级进行广播的接收 ，高优先级的receiver先接收，而后可以对广播进行处理，如setResultData（设置广播内容）、abortBroadcast（终止广播）\n</code></pre><p>4.HttpClient和HttpUrlConnection的选择<br>    在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。</p>\n<pre><code>HttpUrlConnection的bug比如说对一个可读的InputStream调用close()方法时，就有可能会导致连接池失效了。那么我们通常的解决办法就是直接禁用掉连接池的功能\n\n而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。对于新的应用程序应该更加偏向于使用HttpURLConnection，因为在以后的工作当中我们也会将更多的时间放在优化HttpURLConnection上面。\n</code></pre><p>5.HTTP 和 HTTPS 的不同之处<br>    HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头<br>    HTTP 是不安全的，而 HTTPS 是安全的<br>    HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443<br>    在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层<br>    HTTP 无需加密，而 HTTPS 对传输的数据进行加密<br>    HTTP 无需证书，而 HTTPS 需要认证证书</p>\n<pre><code>使用 HTTPS 连接时，服务器要求有公钥和签名的证书。\n\nHTTP 包含如下动作：\n\n    浏览器打开一个 TCP 连接\n    浏览器发送 HTTP 请求到服务器端\n    服务器发送 HTTP 回应信息到浏览器\n    TCP 连接关闭\n\nSSL 包含如下动作：\n\n    验证服务器端\n    允许客户端和服务器端选择加密算法和密码，确保双方都支持\n    验证客户端(可选)\n    使用公钥加密技术来生成共享加密数据\n    创建一个加密的 SSL 连接\n    基于该 SSL 连接传递 HTTP 请求\n\n对称密钥与非对称密钥一起使用：\n    1.客户端向服务器端发起SSL连接请求；（在此过程中依然存在数据被中间方盗取的可能，下面将会说明如何保证此过程的安全）\n\n    2 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥；\n\n    3.客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端；\n\n    4.服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），这样保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。\n\n    5.进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。\n\nCA（电子商务认证机构）认证作用： \n    在上面提到的 客户端向服务器端发起请求时存在数据被盗取的过程：  假如服务器端经由中间方向客户端发送公钥的时候，中间方没有将公钥发送给客户端，而是伪造了医药公钥，并将伪造的公钥发送给客户端，此时客户端用中间方伪造的公钥对自己正确的对称秘钥加密并由中间方发送给服务器端，而中间方将用自己伪造的公钥的私钥对其进行解密，得到正确的对称秘钥，并将得到的正确的对称秘钥用服务器端发过来的公钥进行加密发给服务器端，服务器daunt再用正确的私钥进行解密，也得到正确的对称秘钥，此时客户端，服务器端，中间方三者都拥有一套正确的对称秘钥，可以对传送的数据进行加密，解密。\n\n\n    为了解决上述问题，一般情况下，服务器端会向CA申请认证书，此证书包含了CA及服务器端的一些信息（可以理解为类似公章），这样，服务器端将证书发给客户端的过程中，中间方是无法伪造的，保证了，发给客户端的公钥是服务器端发送的。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>1.4种启动方式<br>2.service的两者启动方式：<br>    startService<br>    bindService –&gt; 使用serviceConnection监听获取相应的binder来调用service的服务</p>\n<p>3.BroadcastReceiver的两者注册方式：<br>    静态注册 –&gt; 生命周期与应用无关，当应用关闭时仍监听广播<br>    动态注册 –&gt; 生命周期从被注册开始到应用结束或被unregister</p>\n<pre><code>无序广播（sendBroadcast） --&gt; 所有广播接收器同时接收广播 \n有序广播（sendOrderedBroadcast） --&gt; 广播接收器按优先级进行广播的接收 ，高优先级的receiver先接收，而后可以对广播进行处理，如setResultData（设置广播内容）、abortBroadcast（终止广播）\n</code></pre><p>4.HttpClient和HttpUrlConnection的选择<br>    在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。</p>\n<pre><code>HttpUrlConnection的bug比如说对一个可读的InputStream调用close()方法时，就有可能会导致连接池失效了。那么我们通常的解决办法就是直接禁用掉连接池的功能\n\n而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。对于新的应用程序应该更加偏向于使用HttpURLConnection，因为在以后的工作当中我们也会将更多的时间放在优化HttpURLConnection上面。\n</code></pre><p>5.HTTP 和 HTTPS 的不同之处<br>    HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头<br>    HTTP 是不安全的，而 HTTPS 是安全的<br>    HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443<br>    在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层<br>    HTTP 无需加密，而 HTTPS 对传输的数据进行加密<br>    HTTP 无需证书，而 HTTPS 需要认证证书</p>\n<pre><code>使用 HTTPS 连接时，服务器要求有公钥和签名的证书。\n\nHTTP 包含如下动作：\n\n    浏览器打开一个 TCP 连接\n    浏览器发送 HTTP 请求到服务器端\n    服务器发送 HTTP 回应信息到浏览器\n    TCP 连接关闭\n\nSSL 包含如下动作：\n\n    验证服务器端\n    允许客户端和服务器端选择加密算法和密码，确保双方都支持\n    验证客户端(可选)\n    使用公钥加密技术来生成共享加密数据\n    创建一个加密的 SSL 连接\n    基于该 SSL 连接传递 HTTP 请求\n\n对称密钥与非对称密钥一起使用：\n    1.客户端向服务器端发起SSL连接请求；（在此过程中依然存在数据被中间方盗取的可能，下面将会说明如何保证此过程的安全）\n\n    2 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥；\n\n    3.客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端；\n\n    4.服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），这样保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。\n\n    5.进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。\n\nCA（电子商务认证机构）认证作用： \n    在上面提到的 客户端向服务器端发起请求时存在数据被盗取的过程：  假如服务器端经由中间方向客户端发送公钥的时候，中间方没有将公钥发送给客户端，而是伪造了医药公钥，并将伪造的公钥发送给客户端，此时客户端用中间方伪造的公钥对自己正确的对称秘钥加密并由中间方发送给服务器端，而中间方将用自己伪造的公钥的私钥对其进行解密，得到正确的对称秘钥，并将得到的正确的对称秘钥用服务器端发过来的公钥进行加密发给服务器端，服务器daunt再用正确的私钥进行解密，也得到正确的对称秘钥，此时客户端，服务器端，中间方三者都拥有一套正确的对称秘钥，可以对传送的数据进行加密，解密。\n\n\n    为了解决上述问题，一般情况下，服务器端会向CA申请认证书，此证书包含了CA及服务器端的一些信息（可以理解为类似公章），这样，服务器端将证书发给客户端的过程中，中间方是无法伪造的，保证了，发给客户端的公钥是服务器端发送的。\n</code></pre>"},{"_content":"1.算法\n\t冒泡排序：从后面开始，小的往上\n\t选择排序：选择最小的放到第一个\n\t插入排序：当前的与前一个对比，若小则swap，而后在于前一个对比\n\t归并排序：分为2个一组，排序，而后在合并（N*log(N)）\n\n2.进程保活手段\n\t黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒）\n\t白色保活：启动前台Service\n\t灰色保活：利用系统的漏洞启动前台Service\n\n3.进程间通信的方式 \n\tAIDL\n\t\t通过bindService进行连接获取binder，数据的传送使用parcel\n\n\t\tandroid.os.Parcel _data = android.os.Parcel.obtain();  \n\t\tandroid.os.Parcel _reply = android.os.Parcel.obtain();  \n\n\t\tmRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);  \n\t\tStub.TRANSACTION_add代表方法是int类型\n\t\t_data.writeInt(x); \n\t\tint t = _data.readInt();\n\n\t\t_reply.writeInt(f)\n\n\t\t服务端：binder.onTransact\n\t\t客户端：binder.transact\n\n\n\t广播\n\n\tMessenger \n\t\t其实原理也是通过binder来实现的\n\n4.加载大图\n\tBitmapRegionDecoder类的使用\n\n5.图片的3级缓存\n\t内存缓存（LruCache）\n\t\tint maxMemory = (int) Runtime.getRuntime().maxMemory();  //获取应用最大内存，而后使用其1/8来作为相应的图片缓存\n\t\tmMemoryCache = new LruCache<String, Bitmap>(cacheSize) {  \n            @Override  \n            protected int sizeOf(String key, Bitmap bitmap) {  \n                return bitmap.getByteCount();  \n            }  \n        };  \n\n        照片墙使用异步加载图片的方式，图片下载完成后将图片放入LruCache中。每次都先到缓存中获取照片，若没有则进行网络获取，下载的方法在onScroll（首次）和onScrollStateChanged中调用，当滚动时将所有下载任务停止并取消，滚动结束时开始相应的下载任务。\n\n    本地缓存（DiskLruCache）\n    \t数据存放在 /sdcard/Android/data/应用包名/cache \n    \t有一个journal文件\n\n    \tpublic static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)  \n\t\topen()方法接收四个参数，第一个参数指定的是数据的缓存地址，第二个参数指定当前应用程序的版本号，第三个参数指定同一个key可以对应多少个缓存文件，基本都是传1，第四个参数指定最多可以缓存多少字节的数据。\n    \t当SD卡存在或者SD卡不可被移除的时候，就调用getExternalCacheDir()方法来获取缓存路径，否则就调用getCacheDir()方法来获取缓存路径。前者获取到的就是 /sdcard/Android/data/<application package>/cache 这个路径，而后者获取到的是 /data/data/<application package>/cache 这个路径。\n\n    （LruCache与DiskLruCache结合使用）\n    \thttp://blog.csdn.net/guolin_blog/article/details/34093441\n    \t每次加载图片的时候都优先去内存缓存当中读取，当读取不到的时候则回去硬盘缓存中读取，而如果硬盘缓存仍然读取不到的话，就从网络上请求原始数据。不管是从硬盘缓存还是从网络获取，读取到了数据之后都应该添加到内存缓存当中，这样的话我们下次再去读取图片的时候就能迅速从内存当中读取到，而如果该图片从内存中被移除了的话，那就重复再执行一遍上述流程就可以了。\n\n\n\n\n\n\n\n\n\n","source":"_posts/面试题2.md","raw":"1.算法\n\t冒泡排序：从后面开始，小的往上\n\t选择排序：选择最小的放到第一个\n\t插入排序：当前的与前一个对比，若小则swap，而后在于前一个对比\n\t归并排序：分为2个一组，排序，而后在合并（N*log(N)）\n\n2.进程保活手段\n\t黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒）\n\t白色保活：启动前台Service\n\t灰色保活：利用系统的漏洞启动前台Service\n\n3.进程间通信的方式 \n\tAIDL\n\t\t通过bindService进行连接获取binder，数据的传送使用parcel\n\n\t\tandroid.os.Parcel _data = android.os.Parcel.obtain();  \n\t\tandroid.os.Parcel _reply = android.os.Parcel.obtain();  \n\n\t\tmRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);  \n\t\tStub.TRANSACTION_add代表方法是int类型\n\t\t_data.writeInt(x); \n\t\tint t = _data.readInt();\n\n\t\t_reply.writeInt(f)\n\n\t\t服务端：binder.onTransact\n\t\t客户端：binder.transact\n\n\n\t广播\n\n\tMessenger \n\t\t其实原理也是通过binder来实现的\n\n4.加载大图\n\tBitmapRegionDecoder类的使用\n\n5.图片的3级缓存\n\t内存缓存（LruCache）\n\t\tint maxMemory = (int) Runtime.getRuntime().maxMemory();  //获取应用最大内存，而后使用其1/8来作为相应的图片缓存\n\t\tmMemoryCache = new LruCache<String, Bitmap>(cacheSize) {  \n            @Override  \n            protected int sizeOf(String key, Bitmap bitmap) {  \n                return bitmap.getByteCount();  \n            }  \n        };  \n\n        照片墙使用异步加载图片的方式，图片下载完成后将图片放入LruCache中。每次都先到缓存中获取照片，若没有则进行网络获取，下载的方法在onScroll（首次）和onScrollStateChanged中调用，当滚动时将所有下载任务停止并取消，滚动结束时开始相应的下载任务。\n\n    本地缓存（DiskLruCache）\n    \t数据存放在 /sdcard/Android/data/应用包名/cache \n    \t有一个journal文件\n\n    \tpublic static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)  \n\t\topen()方法接收四个参数，第一个参数指定的是数据的缓存地址，第二个参数指定当前应用程序的版本号，第三个参数指定同一个key可以对应多少个缓存文件，基本都是传1，第四个参数指定最多可以缓存多少字节的数据。\n    \t当SD卡存在或者SD卡不可被移除的时候，就调用getExternalCacheDir()方法来获取缓存路径，否则就调用getCacheDir()方法来获取缓存路径。前者获取到的就是 /sdcard/Android/data/<application package>/cache 这个路径，而后者获取到的是 /data/data/<application package>/cache 这个路径。\n\n    （LruCache与DiskLruCache结合使用）\n    \thttp://blog.csdn.net/guolin_blog/article/details/34093441\n    \t每次加载图片的时候都优先去内存缓存当中读取，当读取不到的时候则回去硬盘缓存中读取，而如果硬盘缓存仍然读取不到的话，就从网络上请求原始数据。不管是从硬盘缓存还是从网络获取，读取到了数据之后都应该添加到内存缓存当中，这样的话我们下次再去读取图片的时候就能迅速从内存当中读取到，而如果该图片从内存中被移除了的话，那就重复再执行一遍上述流程就可以了。\n\n\n\n\n\n\n\n\n\n","slug":"面试题2","published":1,"date":"2018-02-27T10:29:44.175Z","updated":"2018-02-27T03:19:38.972Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5iguwx00018gie311l8rn4","content":"<p>1.算法<br>    冒泡排序：从后面开始，小的往上<br>    选择排序：选择最小的放到第一个<br>    插入排序：当前的与前一个对比，若小则swap，而后在于前一个对比<br>    归并排序：分为2个一组，排序，而后在合并（N*log(N)）</p>\n<p>2.进程保活手段<br>    黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒）<br>    白色保活：启动前台Service<br>    灰色保活：利用系统的漏洞启动前台Service</p>\n<p>3.进程间通信的方式<br>    AIDL<br>        通过bindService进行连接获取binder，数据的传送使用parcel</p>\n<pre><code>    android.os.Parcel _data = android.os.Parcel.obtain();  \n    android.os.Parcel _reply = android.os.Parcel.obtain();  \n\n    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);  \n    Stub.TRANSACTION_add代表方法是int类型\n    _data.writeInt(x); \n    int t = _data.readInt();\n\n    _reply.writeInt(f)\n\n    服务端：binder.onTransact\n    客户端：binder.transact\n\n\n广播\n\nMessenger \n    其实原理也是通过binder来实现的\n</code></pre><p>4.加载大图<br>    BitmapRegionDecoder类的使用</p>\n<p>5.图片的3级缓存<br>    内存缓存（LruCache）<br>        int maxMemory = (int) Runtime.getRuntime().maxMemory();  //获取应用最大内存，而后使用其1/8来作为相应的图片缓存<br>        mMemoryCache = new LruCache<string, bitmap=\"\">(cacheSize) {<br>            @Override<br>            protected int sizeOf(String key, Bitmap bitmap) {<br>                return bitmap.getByteCount();<br>            }<br>        };  </string,></p>\n<pre><code>    照片墙使用异步加载图片的方式，图片下载完成后将图片放入LruCache中。每次都先到缓存中获取照片，若没有则进行网络获取，下载的方法在onScroll（首次）和onScrollStateChanged中调用，当滚动时将所有下载任务停止并取消，滚动结束时开始相应的下载任务。\n\n本地缓存（DiskLruCache）\n    数据存放在 /sdcard/Android/data/应用包名/cache \n    有一个journal文件\n\n    public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)  \n    open()方法接收四个参数，第一个参数指定的是数据的缓存地址，第二个参数指定当前应用程序的版本号，第三个参数指定同一个key可以对应多少个缓存文件，基本都是传1，第四个参数指定最多可以缓存多少字节的数据。\n    当SD卡存在或者SD卡不可被移除的时候，就调用getExternalCacheDir()方法来获取缓存路径，否则就调用getCacheDir()方法来获取缓存路径。前者获取到的就是 /sdcard/Android/data/&lt;application package&gt;/cache 这个路径，而后者获取到的是 /data/data/&lt;application package&gt;/cache 这个路径。\n\n（LruCache与DiskLruCache结合使用）\n    http://blog.csdn.net/guolin_blog/article/details/34093441\n    每次加载图片的时候都优先去内存缓存当中读取，当读取不到的时候则回去硬盘缓存中读取，而如果硬盘缓存仍然读取不到的话，就从网络上请求原始数据。不管是从硬盘缓存还是从网络获取，读取到了数据之后都应该添加到内存缓存当中，这样的话我们下次再去读取图片的时候就能迅速从内存当中读取到，而如果该图片从内存中被移除了的话，那就重复再执行一遍上述流程就可以了。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>1.算法<br>    冒泡排序：从后面开始，小的往上<br>    选择排序：选择最小的放到第一个<br>    插入排序：当前的与前一个对比，若小则swap，而后在于前一个对比<br>    归并排序：分为2个一组，排序，而后在合并（N*log(N)）</p>\n<p>2.进程保活手段<br>    黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒）<br>    白色保活：启动前台Service<br>    灰色保活：利用系统的漏洞启动前台Service</p>\n<p>3.进程间通信的方式<br>    AIDL<br>        通过bindService进行连接获取binder，数据的传送使用parcel</p>\n<pre><code>    android.os.Parcel _data = android.os.Parcel.obtain();  \n    android.os.Parcel _reply = android.os.Parcel.obtain();  \n\n    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);  \n    Stub.TRANSACTION_add代表方法是int类型\n    _data.writeInt(x); \n    int t = _data.readInt();\n\n    _reply.writeInt(f)\n\n    服务端：binder.onTransact\n    客户端：binder.transact\n\n\n广播\n\nMessenger \n    其实原理也是通过binder来实现的\n</code></pre><p>4.加载大图<br>    BitmapRegionDecoder类的使用</p>\n<p>5.图片的3级缓存<br>    内存缓存（LruCache）<br>        int maxMemory = (int) Runtime.getRuntime().maxMemory();  //获取应用最大内存，而后使用其1/8来作为相应的图片缓存<br>        mMemoryCache = new LruCache<string, bitmap=\"\">(cacheSize) {<br>            @Override<br>            protected int sizeOf(String key, Bitmap bitmap) {<br>                return bitmap.getByteCount();<br>            }<br>        };  </string,></p>\n<pre><code>    照片墙使用异步加载图片的方式，图片下载完成后将图片放入LruCache中。每次都先到缓存中获取照片，若没有则进行网络获取，下载的方法在onScroll（首次）和onScrollStateChanged中调用，当滚动时将所有下载任务停止并取消，滚动结束时开始相应的下载任务。\n\n本地缓存（DiskLruCache）\n    数据存放在 /sdcard/Android/data/应用包名/cache \n    有一个journal文件\n\n    public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)  \n    open()方法接收四个参数，第一个参数指定的是数据的缓存地址，第二个参数指定当前应用程序的版本号，第三个参数指定同一个key可以对应多少个缓存文件，基本都是传1，第四个参数指定最多可以缓存多少字节的数据。\n    当SD卡存在或者SD卡不可被移除的时候，就调用getExternalCacheDir()方法来获取缓存路径，否则就调用getCacheDir()方法来获取缓存路径。前者获取到的就是 /sdcard/Android/data/&lt;application package&gt;/cache 这个路径，而后者获取到的是 /data/data/&lt;application package&gt;/cache 这个路径。\n\n（LruCache与DiskLruCache结合使用）\n    http://blog.csdn.net/guolin_blog/article/details/34093441\n    每次加载图片的时候都优先去内存缓存当中读取，当读取不到的时候则回去硬盘缓存中读取，而如果硬盘缓存仍然读取不到的话，就从网络上请求原始数据。不管是从硬盘缓存还是从网络获取，读取到了数据之后都应该添加到内存缓存当中，这样的话我们下次再去读取图片的时候就能迅速从内存当中读取到，而如果该图片从内存中被移除了的话，那就重复再执行一遍上述流程就可以了。\n</code></pre>"},{"title":"Android自动化测试","date":"2016-06-01T15:47:44.000Z","_content":"\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg)\n\n\n\n-----------------\n\n    \n\n### 摘要\n    Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n\n### Monkey测试\n\n#### 简介\n\tMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n\n#### 使用方式\n\t（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n\t（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n\t（3）Monkey 命令启动方式：  \n\t  \n\t    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n\t    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n\t    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n\t\n#### 效果展示\n部分输出数据如下所示：\n![输出数据](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png)\n\n#### 更多参数介绍\n[点击查看](http://blog.csdn.net/linghu_java/article/details/6732895)\n\t\t\n#### 可能会遇到的问题\n\t（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n[点击查看解决方案](http://www.cnblogs.com/dwf07223/p/3228047.html)\n\n\n### 单元测试\n\t\n#### 简介\n\t单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n\n#### 使用方式\n\t首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\t\n\tdependencies {\n\t    testCompile 'junit:junit:4.12'\n    }\n\n而后在test文件下写单元测试类\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png)\n\n被测试类如下\n\n\tpublic class Calculator {\n\t    public static int add(int a, int b) {\n\t        return a + b;\n\t    }\n\t}\n\n单元测试类如下\n\n\tpublic class ExampleUnitTest {\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        assertEquals(4, Calculator.add(2,2));\n\t    }\n\t}\n\n最后运行单元测试类，结果如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png)\n\t\n#### Junit标签解析\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n\t@Test： 将方法（函数）标记为测试用例\n\t@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n\t@After： 每一个使用@Test标记的方法运行之后都要运行一次\n\t@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n\t@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n\n以如下代码为例：\n\t\n\tpublic class ExampleUnitTest {\n\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t\n\t    @Test\n\t    public void addition_isErr() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t    @Before\n\t    public void before() throws Exception {\n\t        System.out.println(\"@Before\");\n\t    }\n\t\n\t    @After\n\t    public void after() throws Exception {\n\t        System.out.println(\"@After\");\n\t    }\n\t\n\t\n\t    @AfterClass\n\t    public static void afterClass() throws Exception {\n\t        System.out.println(\"@AfterClass\");\n\t    }\n\t\n\t    @BeforeClass\n\t    public static void beforeClass() throws Exception {\n\t        System.out.println(\"@BeforeClass\");\n\t    }\n\t}\n\t\n相应的执行顺序如下：\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png)\n\n#### Mockito使用方式\n\n简介：\n\t\t\n\tMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n\n**先体验以下Mockito的使用：**\n\n1.添加依赖\n\n\ttestCompile 'org.mockito:mockito-core:2.8.47'\n\n2.被依赖类\n\t\n\tpublic interface IMathUtils {\n\t    public int abs(int num); // 求绝对值\n\t}\n\t\n3.依赖类\n\n\t@RunWith(MockitoJUnitRunner.class)\n\tpublic class MockTest {\n\t    @Mock\n\t    IMathUtils mathUtils;\n\t\n\t    @Test\n\t    public void mockTest() {\n\t\n\t        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n\t    }\n\t}\n\n可以发现**IMathUtils**是一个接口，根本就没有实现，用**Mockito**框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！**Mockito代理了IMathUtils.abs(num)的行为**，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法**when...thenReturn...**相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\n\tpublic class MockTest {\n\n        @Mock\n        IMathUtils iMathUtils ; \n\n        @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n        @Test\n        public void mockTest()  {\n            when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n        }\n\t}\n\n其中**@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();** 用于初始化Mock对象，效果与在类前添加**@RunWith(MockitoJUnitRunner.class)**标签类似\n\n**Mock配置**\n\nMock有多种配置方式，如下所示：\n\t\t\n\t@Test\n\tpublic void test1()  {\n\t        //  创建 mock\n\t        MyClass test = Mockito.mock(MyClass.class);\n\n        // 自定义 getUniqueId() 的返回值\n        when(test.getUniqueId()).thenReturn(43);\n\n        // 在测试中使用mock对象\n        assertEquals(test.getUniqueId(), 43);\n\t}\n\t\n\t// 返回多个值\n\t@Test\n\tpublic void testMoreThanOneReturnValue()  {\n\t        Iterator i= mock(Iterator.class);\n\t        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n\t        String result=i.next()+\" \"+i.next();\n\t        // 断言\n\t        assertEquals(\"Mockito rocks\", result);\n\t}\n\t\n\t// 如何根据输入来返回值\n\t@Test\n\tpublic void testReturnValueDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(\"Mockito\")).thenReturn(1);\n\t        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n\t        // 断言\n\t        assertEquals(1,c.compareTo(\"Mockito\"));\n\t}\n\t\n\t// 如何让返回值不依赖于输入\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(anyInt())).thenReturn(-1);\n\t        // 断言\n\t        assertEquals(-1 ,c.compareTo(9));\n\t}\n\t\n\t// 根据参数类型来返回值\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n\t        // 断言\n\t        Todo todo = new Todo(5);\n\t        assertEquals(todo ,c.compareTo(new Todo(1)));\n\t}\n\t\n更多配置可以看下这个网站  [点击链接](http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html)\n\n\n### UI测试\n\n#### 简介\n\tUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n\n#### 使用方式\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\n\ttestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\n\ttestCompile 'com.android.support.test:runner:0.4.1'\n\n2.在androidTest目录下创建测试类\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png)\n\n3.被测试类（即activity之类的展示界面）\nMainActivity.class\n\t\n\tpublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n\t    private EditText mEt;\n\t    private TextView mTv;\n\t    private Button mBtn;\n\t\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t\n\t        mEt = (EditText) findViewById(R.id.et);\n\t        mTv = (TextView) findViewById(R.id.tv);\n\t        mBtn = (Button) findViewById(R.id.btn);\n\t\n\t        mBtn.setOnClickListener(this);\n\t    }\n\t\n\t    @Override\n\t    public void onClick(View v) {\n\t        mTv.setText(mEt.getText().toString());\n\t    }\n\t}\n\nactivity_main.xml\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n\t    xmlns:tools=\"http://schemas.android.com/tools\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n    <TextView\n        android:id=\"@+id/tv\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"15dp\"\n        android:padding=\"10dp\"\n        android:text=\"helo\" />\n\n    <EditText\n        android:id=\"@+id/et\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"40dp\"\n        android:layout_alignParentLeft=\"true\"\n        android:layout_alignParentStart=\"true\"\n        android:layout_alignParentTop=\"true\"\n        android:layout_marginTop=\"75dp\" />\n\n    <Button\n        android:id=\"@+id/btn\"\n        android:layout_width=\"80dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/et\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginTop=\"49dp\"\n        android:text=\"sure\" />\n\t</RelativeLayout>\n\n测试类\nExampleInstrumentedTest.class\n\n\t@RunWith(AndroidJUnit4.class)\n\tpublic class ExampleInstrumentedTest {\n\t    @Rule\n\t    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n\t            MainActivity.class);\n\n\t    @Test\n\t    public void useAppContext() throws Exception {\n\t        // Context of the app under test.\n\t        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n\t                closeSoftKeyboard());\n\t        onView(withId(R.id.btn)).perform(click());\n\t    }\n\t}\n其中**onView(withId(R.id.et)).perform(typeText(\"helo world\"), closeSoftKeyboard());**选择界面中的输入框，并输入“helo world”，**onView(withId(R.id.btn)).perform(click());**选择界面中的按钮并点击。\n\n[更多操作方式-1](https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md)        \n[更多操作方式-2](http://blog.csdn.net/eclipsexys/article/details/45622813)\n\n#### 标签解析\n\n\t@Rule: 应用于成员变量\n\t@ClassRule: 应用于测试类中的静态变量\n\t两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\t\t\n\t@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n\n\n### 总结\n\t总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\nAndroid自动化测试\n\nenter image description here\n\nAndroid自动化测试\n摘要\nMonkey测试\n简介\n使用方式\n效果展示\n更多参数介绍\n可能会遇到的问题\n单元测试\n简介\n使用方式\nJunit标签解析\nMockito使用方式\nUI测试\n简介\n使用方式\n标签解析\n总结\n摘要\n\nAndroid自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\nMonkey测试\n\n简介\n\nMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n使用方式\n\n（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n效果展示\n\n部分输出数据如下所示：\n\n输出数据\n\n更多参数介绍\n\n点击查看\n\n可能会遇到的问题\n\n（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n点击查看解决方案\n\n单元测试\n\n简介\n\n单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n使用方式\n\n首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile 'junit:junit:4.12'\n}\n而后在test文件下写单元测试类\n\nenter image description here\n\n被测试类如下\n\npublic class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n单元测试类如下\n\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n最后运行单元测试类，结果如下：\n\nenter image description here\n\nJunit标签解析\n\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n以如下代码为例：\n\npublic class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(\"@Before\");\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(\"@After\");\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(\"@AfterClass\");\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(\"@BeforeClass\");\n    }\n}\n相应的执行顺序如下：\n\nenter image description here\n\nMockito使用方式\n\n简介：\n\nMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n先体验以下Mockito的使用：\n\n1.添加依赖\n\ntestCompile 'org.mockito:mockito-core:2.8.47'\n2.被依赖类\n\npublic interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n3.依赖类\n\n@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\npublic class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似\n\nMock配置\n\nMock有多种配置方式，如下所示：\n\n@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n        String result=i.next()+\" \"+i.next();\n        // 断言\n        assertEquals(\"Mockito rocks\", result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(\"Mockito\")).thenReturn(1);\n        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(\"Mockito\"));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n更多配置可以看下这个网站 点击链接\n\nUI测试\n\n简介\n\nUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n使用方式\n\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\ntestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\ntestCompile 'com.android.support.test:runner:0.4.1'\n2.在androidTest目录下创建测试类\n\nenter image description here\n\n3.被测试类（即activity之类的展示界面） \nMainActivity.class\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\nactivity_main.xml\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<TextView\n    android:id=\"@+id/tv\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_marginTop=\"15dp\"\n    android:padding=\"10dp\"\n    android:text=\"helo\" />\n\n<EditText\n    android:id=\"@+id/et\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"40dp\"\n    android:layout_alignParentLeft=\"true\"\n    android:layout_alignParentStart=\"true\"\n    android:layout_alignParentTop=\"true\"\n    android:layout_marginTop=\"75dp\" />\n\n<Button\n    android:id=\"@+id/btn\"\n    android:layout_width=\"80dp\"\n    android:layout_height=\"wrap_content\"\n    android:layout_below=\"@+id/et\"\n    android:layout_centerHorizontal=\"true\"\n    android:layout_marginTop=\"49dp\"\n    android:text=\"sure\" />\n</RelativeLayout>\n测试类 \nExampleInstrumentedTest.class\n\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。\n\n更多操作方式-1 \n更多操作方式-2\n\n标签解析\n\n@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n总结\n\n总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n     7539 \nqqq2830\n 退出账号\n当前文档\n 恢复至上次同步状态\n 删除文档\n 导出...\n 预览文档\n 分享链接\n系统\n 设置\n 使用说明\n 快捷帮助\n 常见问题\n 关于\n\n搜索文件\n杂物 Android自动化测试 \n杂物 SwipeToLoadLayout \n检查Evernote中的笔记版本\n\n","source":"_posts/Android自动化测试.md","raw":"---\ntitle: Android自动化测试\ndate: 2016-06-01 23:47:44\ncategories: \"Android基础学习\"\ntags:\n     - Android\n     - 测试\n     - 技术\n---\n\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg)\n\n\n\n-----------------\n\n    \n\n### 摘要\n    Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n\n### Monkey测试\n\n#### 简介\n\tMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n\n#### 使用方式\n\t（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n\t（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n\t（3）Monkey 命令启动方式：  \n\t  \n\t    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n\t    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n\t    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n\t\n#### 效果展示\n部分输出数据如下所示：\n![输出数据](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png)\n\n#### 更多参数介绍\n[点击查看](http://blog.csdn.net/linghu_java/article/details/6732895)\n\t\t\n#### 可能会遇到的问题\n\t（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n[点击查看解决方案](http://www.cnblogs.com/dwf07223/p/3228047.html)\n\n\n### 单元测试\n\t\n#### 简介\n\t单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n\n#### 使用方式\n\t首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\t\n\tdependencies {\n\t    testCompile 'junit:junit:4.12'\n    }\n\n而后在test文件下写单元测试类\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png)\n\n被测试类如下\n\n\tpublic class Calculator {\n\t    public static int add(int a, int b) {\n\t        return a + b;\n\t    }\n\t}\n\n单元测试类如下\n\n\tpublic class ExampleUnitTest {\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        assertEquals(4, Calculator.add(2,2));\n\t    }\n\t}\n\n最后运行单元测试类，结果如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png)\n\t\n#### Junit标签解析\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n\t@Test： 将方法（函数）标记为测试用例\n\t@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n\t@After： 每一个使用@Test标记的方法运行之后都要运行一次\n\t@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n\t@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n\n以如下代码为例：\n\t\n\tpublic class ExampleUnitTest {\n\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t\n\t    @Test\n\t    public void addition_isErr() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t    @Before\n\t    public void before() throws Exception {\n\t        System.out.println(\"@Before\");\n\t    }\n\t\n\t    @After\n\t    public void after() throws Exception {\n\t        System.out.println(\"@After\");\n\t    }\n\t\n\t\n\t    @AfterClass\n\t    public static void afterClass() throws Exception {\n\t        System.out.println(\"@AfterClass\");\n\t    }\n\t\n\t    @BeforeClass\n\t    public static void beforeClass() throws Exception {\n\t        System.out.println(\"@BeforeClass\");\n\t    }\n\t}\n\t\n相应的执行顺序如下：\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png)\n\n#### Mockito使用方式\n\n简介：\n\t\t\n\tMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n\n**先体验以下Mockito的使用：**\n\n1.添加依赖\n\n\ttestCompile 'org.mockito:mockito-core:2.8.47'\n\n2.被依赖类\n\t\n\tpublic interface IMathUtils {\n\t    public int abs(int num); // 求绝对值\n\t}\n\t\n3.依赖类\n\n\t@RunWith(MockitoJUnitRunner.class)\n\tpublic class MockTest {\n\t    @Mock\n\t    IMathUtils mathUtils;\n\t\n\t    @Test\n\t    public void mockTest() {\n\t\n\t        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n\t    }\n\t}\n\n可以发现**IMathUtils**是一个接口，根本就没有实现，用**Mockito**框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！**Mockito代理了IMathUtils.abs(num)的行为**，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法**when...thenReturn...**相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\n\tpublic class MockTest {\n\n        @Mock\n        IMathUtils iMathUtils ; \n\n        @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n        @Test\n        public void mockTest()  {\n            when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n        }\n\t}\n\n其中**@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();** 用于初始化Mock对象，效果与在类前添加**@RunWith(MockitoJUnitRunner.class)**标签类似\n\n**Mock配置**\n\nMock有多种配置方式，如下所示：\n\t\t\n\t@Test\n\tpublic void test1()  {\n\t        //  创建 mock\n\t        MyClass test = Mockito.mock(MyClass.class);\n\n        // 自定义 getUniqueId() 的返回值\n        when(test.getUniqueId()).thenReturn(43);\n\n        // 在测试中使用mock对象\n        assertEquals(test.getUniqueId(), 43);\n\t}\n\t\n\t// 返回多个值\n\t@Test\n\tpublic void testMoreThanOneReturnValue()  {\n\t        Iterator i= mock(Iterator.class);\n\t        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n\t        String result=i.next()+\" \"+i.next();\n\t        // 断言\n\t        assertEquals(\"Mockito rocks\", result);\n\t}\n\t\n\t// 如何根据输入来返回值\n\t@Test\n\tpublic void testReturnValueDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(\"Mockito\")).thenReturn(1);\n\t        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n\t        // 断言\n\t        assertEquals(1,c.compareTo(\"Mockito\"));\n\t}\n\t\n\t// 如何让返回值不依赖于输入\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(anyInt())).thenReturn(-1);\n\t        // 断言\n\t        assertEquals(-1 ,c.compareTo(9));\n\t}\n\t\n\t// 根据参数类型来返回值\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n\t        // 断言\n\t        Todo todo = new Todo(5);\n\t        assertEquals(todo ,c.compareTo(new Todo(1)));\n\t}\n\t\n更多配置可以看下这个网站  [点击链接](http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html)\n\n\n### UI测试\n\n#### 简介\n\tUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n\n#### 使用方式\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\n\ttestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\n\ttestCompile 'com.android.support.test:runner:0.4.1'\n\n2.在androidTest目录下创建测试类\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png)\n\n3.被测试类（即activity之类的展示界面）\nMainActivity.class\n\t\n\tpublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n\t    private EditText mEt;\n\t    private TextView mTv;\n\t    private Button mBtn;\n\t\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t\n\t        mEt = (EditText) findViewById(R.id.et);\n\t        mTv = (TextView) findViewById(R.id.tv);\n\t        mBtn = (Button) findViewById(R.id.btn);\n\t\n\t        mBtn.setOnClickListener(this);\n\t    }\n\t\n\t    @Override\n\t    public void onClick(View v) {\n\t        mTv.setText(mEt.getText().toString());\n\t    }\n\t}\n\nactivity_main.xml\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n\t    xmlns:tools=\"http://schemas.android.com/tools\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n    <TextView\n        android:id=\"@+id/tv\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"15dp\"\n        android:padding=\"10dp\"\n        android:text=\"helo\" />\n\n    <EditText\n        android:id=\"@+id/et\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"40dp\"\n        android:layout_alignParentLeft=\"true\"\n        android:layout_alignParentStart=\"true\"\n        android:layout_alignParentTop=\"true\"\n        android:layout_marginTop=\"75dp\" />\n\n    <Button\n        android:id=\"@+id/btn\"\n        android:layout_width=\"80dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/et\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginTop=\"49dp\"\n        android:text=\"sure\" />\n\t</RelativeLayout>\n\n测试类\nExampleInstrumentedTest.class\n\n\t@RunWith(AndroidJUnit4.class)\n\tpublic class ExampleInstrumentedTest {\n\t    @Rule\n\t    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n\t            MainActivity.class);\n\n\t    @Test\n\t    public void useAppContext() throws Exception {\n\t        // Context of the app under test.\n\t        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n\t                closeSoftKeyboard());\n\t        onView(withId(R.id.btn)).perform(click());\n\t    }\n\t}\n其中**onView(withId(R.id.et)).perform(typeText(\"helo world\"), closeSoftKeyboard());**选择界面中的输入框，并输入“helo world”，**onView(withId(R.id.btn)).perform(click());**选择界面中的按钮并点击。\n\n[更多操作方式-1](https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md)        \n[更多操作方式-2](http://blog.csdn.net/eclipsexys/article/details/45622813)\n\n#### 标签解析\n\n\t@Rule: 应用于成员变量\n\t@ClassRule: 应用于测试类中的静态变量\n\t两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\t\t\n\t@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n\n\n### 总结\n\t总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\nAndroid自动化测试\n\nenter image description here\n\nAndroid自动化测试\n摘要\nMonkey测试\n简介\n使用方式\n效果展示\n更多参数介绍\n可能会遇到的问题\n单元测试\n简介\n使用方式\nJunit标签解析\nMockito使用方式\nUI测试\n简介\n使用方式\n标签解析\n总结\n摘要\n\nAndroid自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\nMonkey测试\n\n简介\n\nMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n使用方式\n\n（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n效果展示\n\n部分输出数据如下所示：\n\n输出数据\n\n更多参数介绍\n\n点击查看\n\n可能会遇到的问题\n\n（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n点击查看解决方案\n\n单元测试\n\n简介\n\n单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n使用方式\n\n首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile 'junit:junit:4.12'\n}\n而后在test文件下写单元测试类\n\nenter image description here\n\n被测试类如下\n\npublic class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n单元测试类如下\n\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n最后运行单元测试类，结果如下：\n\nenter image description here\n\nJunit标签解析\n\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n以如下代码为例：\n\npublic class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(\"@Before\");\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(\"@After\");\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(\"@AfterClass\");\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(\"@BeforeClass\");\n    }\n}\n相应的执行顺序如下：\n\nenter image description here\n\nMockito使用方式\n\n简介：\n\nMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n先体验以下Mockito的使用：\n\n1.添加依赖\n\ntestCompile 'org.mockito:mockito-core:2.8.47'\n2.被依赖类\n\npublic interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n3.依赖类\n\n@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\npublic class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似\n\nMock配置\n\nMock有多种配置方式，如下所示：\n\n@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n        String result=i.next()+\" \"+i.next();\n        // 断言\n        assertEquals(\"Mockito rocks\", result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(\"Mockito\")).thenReturn(1);\n        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(\"Mockito\"));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n更多配置可以看下这个网站 点击链接\n\nUI测试\n\n简介\n\nUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n使用方式\n\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\ntestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\ntestCompile 'com.android.support.test:runner:0.4.1'\n2.在androidTest目录下创建测试类\n\nenter image description here\n\n3.被测试类（即activity之类的展示界面） \nMainActivity.class\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\nactivity_main.xml\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<TextView\n    android:id=\"@+id/tv\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_marginTop=\"15dp\"\n    android:padding=\"10dp\"\n    android:text=\"helo\" />\n\n<EditText\n    android:id=\"@+id/et\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"40dp\"\n    android:layout_alignParentLeft=\"true\"\n    android:layout_alignParentStart=\"true\"\n    android:layout_alignParentTop=\"true\"\n    android:layout_marginTop=\"75dp\" />\n\n<Button\n    android:id=\"@+id/btn\"\n    android:layout_width=\"80dp\"\n    android:layout_height=\"wrap_content\"\n    android:layout_below=\"@+id/et\"\n    android:layout_centerHorizontal=\"true\"\n    android:layout_marginTop=\"49dp\"\n    android:text=\"sure\" />\n</RelativeLayout>\n测试类 \nExampleInstrumentedTest.class\n\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。\n\n更多操作方式-1 \n更多操作方式-2\n\n标签解析\n\n@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n总结\n\n总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n     7539 \nqqq2830\n 退出账号\n当前文档\n 恢复至上次同步状态\n 删除文档\n 导出...\n 预览文档\n 分享链接\n系统\n 设置\n 使用说明\n 快捷帮助\n 常见问题\n 关于\n\n搜索文件\n杂物 Android自动化测试 \n杂物 SwipeToLoadLayout \n检查Evernote中的笔记版本\n\n","slug":"Android自动化测试","published":1,"updated":"2018-02-06T03:41:16.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5iguwz00028giea4rawu2f","content":"<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg\" alt=\"enter image description here\"></p>\n<hr>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><pre><code>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n</code></pre><h3 id=\"Monkey测试\"><a href=\"#Monkey测试\" class=\"headerlink\" title=\"Monkey测试\"></a>Monkey测试</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n</code></pre><h4 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><h4 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h4><p>部分输出数据如下所示：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png\" alt=\"输出数据\"></p>\n<h4 id=\"更多参数介绍\"><a href=\"#更多参数介绍\" class=\"headerlink\" title=\"更多参数介绍\"></a>更多参数介绍</h4><p><a href=\"http://blog.csdn.net/linghu_java/article/details/6732895\" target=\"_blank\" rel=\"noopener\">点击查看</a></p>\n<h4 id=\"可能会遇到的问题\"><a href=\"#可能会遇到的问题\" class=\"headerlink\" title=\"可能会遇到的问题\"></a>可能会遇到的问题</h4><pre><code>（1）“&apos;adb&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n</code></pre><p><a href=\"http://www.cnblogs.com/dwf07223/p/3228047.html\" target=\"_blank\" rel=\"noopener\">点击查看解决方案</a></p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n</code></pre><h4 id=\"使用方式-1\"><a href=\"#使用方式-1\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile &apos;junit:junit:4.12&apos;\n}\n</code></pre><p>而后在test文件下写单元测试类<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png\" alt=\"enter image description here\"></p>\n<p>被测试类如下</p>\n<pre><code>public class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n</code></pre><p>单元测试类如下</p>\n<pre><code>public class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n</code></pre><p>最后运行单元测试类，结果如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Junit标签解析\"><a href=\"#Junit标签解析\" class=\"headerlink\" title=\"Junit标签解析\"></a>Junit标签解析</h4><p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<pre><code>@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n</code></pre><p>以如下代码为例：</p>\n<pre><code>public class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(&quot;@Before&quot;);\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(&quot;@After&quot;);\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(&quot;@AfterClass&quot;);\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(&quot;@BeforeClass&quot;);\n    }\n}\n</code></pre><p>相应的执行顺序如下：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Mockito使用方式\"><a href=\"#Mockito使用方式\" class=\"headerlink\" title=\"Mockito使用方式\"></a>Mockito使用方式</h4><p>简介：</p>\n<pre><code>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n</code></pre><p><strong>先体验以下Mockito的使用：</strong></p>\n<p>1.添加依赖</p>\n<pre><code>testCompile &apos;org.mockito:mockito-core:2.8.47&apos;\n</code></pre><p>2.被依赖类</p>\n<pre><code>public interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n</code></pre><p>3.依赖类</p>\n<pre><code>@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>可以发现<strong>IMathUtils</strong>是一个接口，根本就没有实现，用<strong>Mockito</strong>框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！<strong>Mockito代理了IMathUtils.abs(num)的行为</strong>，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法<strong>when…thenReturn…</strong>相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<pre><code>public class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>其中<strong>@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();</strong> 用于初始化Mock对象，效果与在类前添加<strong>@RunWith(MockitoJUnitRunner.class)</strong>标签类似</p>\n<p><strong>Mock配置</strong></p>\n<p>Mock有多种配置方式，如下所示：</p>\n<pre><code>@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);\n        String result=i.next()+&quot; &quot;+i.next();\n        // 断言\n        assertEquals(&quot;Mockito rocks&quot;, result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);\n        when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(&quot;Mockito&quot;));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n</code></pre><p>更多配置可以看下这个网站  <a href=\"http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html\" target=\"_blank\" rel=\"noopener\">点击链接</a></p>\n<h3 id=\"UI测试\"><a href=\"#UI测试\" class=\"headerlink\" title=\"UI测试\"></a>UI测试</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n</code></pre><h4 id=\"使用方式-2\"><a href=\"#使用方式-2\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<pre><code>testCompile &apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;\ntestCompile &apos;com.android.support.test:runner:0.4.1&apos;\n</code></pre><p>2.在androidTest目录下创建测试类</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png\" alt=\"enter image description here\"></p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\n</code></pre><p>activity_main.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    tools:context=&quot;xgn.com.androidautotest.MainActivity&quot;&gt;\n\n&lt;TextView\n    android:id=&quot;@+id/tv&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_marginTop=&quot;15dp&quot;\n    android:padding=&quot;10dp&quot;\n    android:text=&quot;helo&quot; /&gt;\n\n&lt;EditText\n    android:id=&quot;@+id/et&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;40dp&quot;\n    android:layout_alignParentLeft=&quot;true&quot;\n    android:layout_alignParentStart=&quot;true&quot;\n    android:layout_alignParentTop=&quot;true&quot;\n    android:layout_marginTop=&quot;75dp&quot; /&gt;\n\n&lt;Button\n    android:id=&quot;@+id/btn&quot;\n    android:layout_width=&quot;80dp&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_below=&quot;@+id/et&quot;\n    android:layout_centerHorizontal=&quot;true&quot;\n    android:layout_marginTop=&quot;49dp&quot;\n    android:text=&quot;sure&quot; /&gt;\n&lt;/RelativeLayout&gt;\n</code></pre><p>测试类<br>ExampleInstrumentedTest.class</p>\n<pre><code>@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n</code></pre><p>其中<strong>onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());</strong>选择界面中的输入框，并输入“helo world”，<strong>onView(withId(R.id.btn)).perform(click());</strong>选择界面中的按钮并点击。</p>\n<p><a href=\"https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md\" target=\"_blank\" rel=\"noopener\">更多操作方式-1</a><br><a href=\"http://blog.csdn.net/eclipsexys/article/details/45622813\" target=\"_blank\" rel=\"noopener\">更多操作方式-2</a></p>\n<h4 id=\"标签解析\"><a href=\"#标签解析\" class=\"headerlink\" title=\"标签解析\"></a>标签解析</h4><pre><code>@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n</code></pre><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n</code></pre><p>Android自动化测试</p>\n<p>enter image description here</p>\n<p>Android自动化测试<br>摘要<br>Monkey测试<br>简介<br>使用方式<br>效果展示<br>更多参数介绍<br>可能会遇到的问题<br>单元测试<br>简介<br>使用方式<br>Junit标签解析<br>Mockito使用方式<br>UI测试<br>简介<br>使用方式<br>标签解析<br>总结<br>摘要</p>\n<p>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。<br>Monkey测试</p>\n<p>简介</p>\n<p>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。<br>使用方式</p>\n<p>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；<br>（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；<br>（3）Monkey 命令启动方式：  </p>\n<pre><code>- 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n- 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n- 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><p>效果展示</p>\n<p>部分输出数据如下所示：</p>\n<p>输出数据</p>\n<p>更多参数介绍</p>\n<p>点击查看</p>\n<p>可能会遇到的问题</p>\n<p>（1）“’adb’ 不是内部或外部命令，也不是可运行的程序或批处理文件。”<br>点击查看解决方案</p>\n<p>单元测试</p>\n<p>简介</p>\n<p>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。<br>使用方式</p>\n<p>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：</p>\n<p>dependencies {<br>    testCompile ‘junit:junit:4.12’<br>}<br>而后在test文件下写单元测试类</p>\n<p>enter image description here</p>\n<p>被测试类如下</p>\n<p>public class Calculator {<br>    public static int add(int a, int b) {<br>        return a + b;<br>    }<br>}<br>单元测试类如下</p>\n<p>public class ExampleUnitTest {<br>    @Test<br>    public void addition_isCorrect() throws Exception {<br>        assertEquals(4, Calculator.add(2,2));<br>    }<br>}<br>最后运行单元测试类，结果如下：</p>\n<p>enter image description here</p>\n<p>Junit标签解析</p>\n<p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<p>@Test： 将方法（函数）标记为测试用例<br>@Before： 每一个使用@Test标记的方法运行之前都要运行一次<br>@After： 每一个使用@Test标记的方法运行之后都要运行一次<br>@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次<br>@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次<br>以如下代码为例：</p>\n<p>public class ExampleUnitTest {</p>\n<pre><code>@Test\npublic void addition_isCorrect() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n\n@Test\npublic void addition_isErr() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n@Before\npublic void before() throws Exception {\n    System.out.println(&quot;@Before&quot;);\n}\n\n@After\npublic void after() throws Exception {\n    System.out.println(&quot;@After&quot;);\n}\n\n\n@AfterClass\npublic static void afterClass() throws Exception {\n    System.out.println(&quot;@AfterClass&quot;);\n}\n\n@BeforeClass\npublic static void beforeClass() throws Exception {\n    System.out.println(&quot;@BeforeClass&quot;);\n}\n</code></pre><p>}<br>相应的执行顺序如下：</p>\n<p>enter image description here</p>\n<p>Mockito使用方式</p>\n<p>简介：</p>\n<p>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。<br>先体验以下Mockito的使用：</p>\n<p>1.添加依赖</p>\n<p>testCompile ‘org.mockito:mockito-core:2.8.47’<br>2.被依赖类</p>\n<p>public interface IMathUtils {<br>    public int abs(int num); // 求绝对值<br>}<br>3.依赖类</p>\n<p>@RunWith(MockitoJUnitRunner.class)<br>public class MockTest {<br>    @Mock<br>    IMathUtils mathUtils;</p>\n<pre><code>@Test\npublic void mockTest() {\n\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<p>public class MockTest {</p>\n<pre><code>@Mock\nIMathUtils iMathUtils ; \n\n@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n@Test\npublic void mockTest()  {\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似</p>\n<p>Mock配置</p>\n<p>Mock有多种配置方式，如下所示：</p>\n<p>@Test<br>public void test1()  {<br>        //  创建 mock<br>        MyClass test = Mockito.mock(MyClass.class);</p>\n<pre><code>// 自定义 getUniqueId() 的返回值\nwhen(test.getUniqueId()).thenReturn(43);\n\n// 在测试中使用mock对象\nassertEquals(test.getUniqueId(), 43);\n</code></pre><p>}</p>\n<p>// 返回多个值<br>@Test<br>public void testMoreThanOneReturnValue()  {<br>        Iterator i= mock(Iterator.class);<br>        when(i.next()).thenReturn(“Mockito”).thenReturn(“rocks”);<br>        String result=i.next()+” “+i.next();<br>        // 断言<br>        assertEquals(“Mockito rocks”, result);<br>}</p>\n<p>// 如何根据输入来返回值<br>@Test<br>public void testReturnValueDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(“Mockito”)).thenReturn(1);<br>        when(c.compareTo(“Eclipse”)).thenReturn(2);<br>        // 断言<br>        assertEquals(1,c.compareTo(“Mockito”));<br>}</p>\n<p>// 如何让返回值不依赖于输入<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(anyInt())).thenReturn(-1);<br>        // 断言<br>        assertEquals(-1 ,c.compareTo(9));<br>}</p>\n<p>// 根据参数类型来返回值<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(isA(Todo.class))).thenReturn(0);<br>        // 断言<br>        Todo todo = new Todo(5);<br>        assertEquals(todo ,c.compareTo(new Todo(1)));<br>}<br>更多配置可以看下这个网站 点击链接</p>\n<p>UI测试</p>\n<p>简介</p>\n<p>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。<br>使用方式</p>\n<p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<p>testCompile ‘com.android.support.test.espresso:espresso-core:2.2.2’<br>testCompile ‘com.android.support.test:runner:0.4.1’<br>2.在androidTest目录下创建测试类</p>\n<p>enter image description here</p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<p>public class MainActivity extends AppCompatActivity implements View.OnClickListener{</p>\n<pre><code>private EditText mEt;\nprivate TextView mTv;\nprivate Button mBtn;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    mEt = (EditText) findViewById(R.id.et);\n    mTv = (TextView) findViewById(R.id.tv);\n    mBtn = (Button) findViewById(R.id.btn);\n\n    mBtn.setOnClickListener(this);\n}\n\n@Override\npublic void onClick(View v) {\n    mTv.setText(mEt.getText().toString());\n}\n</code></pre><p>}<br>activity_main.xml</p>\n<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>\n<relativelayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<textview android:id=\"@+id/tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margintop=\"15dp\" android:padding=\"10dp\" android:text=\"helo\">\n\n<edittext android:id=\"@+id/et\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:layout_alignparentleft=\"true\" android:layout_alignparentstart=\"true\" android:layout_alignparenttop=\"true\" android:layout_margintop=\"75dp\">\n\n<p><button android:id=\"@+id/btn\" android:layout_width=\"80dp\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/et\" android:layout_centerhorizontal=\"true\" android:layout_margintop=\"49dp\" android:text=\"sure\"><br></button></p></edittext></textview></relativelayout><br>测试类<br>ExampleInstrumentedTest.class<p></p>\n<p>@RunWith(AndroidJUnit4.class)<br>public class ExampleInstrumentedTest {<br>    @Rule<br>    public ActivityTestRule<mainactivity> mActivityRule = new ActivityTestRule&lt;&gt;(<br>            MainActivity.class);</mainactivity></p>\n<pre><code>@Test\npublic void useAppContext() throws Exception {\n    // Context of the app under test.\n    onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n            closeSoftKeyboard());\n    onView(withId(R.id.btn)).perform(click());\n}\n</code></pre><p>}<br>其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。</p>\n<p>更多操作方式-1<br>更多操作方式-2</p>\n<p>标签解析</p>\n<p>@Rule: 应用于成员变量<br>@ClassRule: 应用于测试类中的静态变量<br>两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。</p>\n<p>@RunWith（AndroidJUnit4.class）：  用于修改测试运行器<br>总结</p>\n<p>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。<br>     7539<br>qqq2830<br> 退出账号<br>当前文档<br> 恢复至上次同步状态<br> 删除文档<br> 导出…<br> 预览文档<br> 分享链接<br>系统<br> 设置<br> 使用说明<br> 快捷帮助<br> 常见问题<br> 关于</p>\n<p>搜索文件<br>杂物 Android自动化测试<br>杂物 SwipeToLoadLayout<br>检查Evernote中的笔记版本</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg\" alt=\"enter image description here\"></p>\n<hr>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><pre><code>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n</code></pre><h3 id=\"Monkey测试\"><a href=\"#Monkey测试\" class=\"headerlink\" title=\"Monkey测试\"></a>Monkey测试</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n</code></pre><h4 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><h4 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h4><p>部分输出数据如下所示：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png\" alt=\"输出数据\"></p>\n<h4 id=\"更多参数介绍\"><a href=\"#更多参数介绍\" class=\"headerlink\" title=\"更多参数介绍\"></a>更多参数介绍</h4><p><a href=\"http://blog.csdn.net/linghu_java/article/details/6732895\" target=\"_blank\" rel=\"noopener\">点击查看</a></p>\n<h4 id=\"可能会遇到的问题\"><a href=\"#可能会遇到的问题\" class=\"headerlink\" title=\"可能会遇到的问题\"></a>可能会遇到的问题</h4><pre><code>（1）“&apos;adb&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n</code></pre><p><a href=\"http://www.cnblogs.com/dwf07223/p/3228047.html\" target=\"_blank\" rel=\"noopener\">点击查看解决方案</a></p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n</code></pre><h4 id=\"使用方式-1\"><a href=\"#使用方式-1\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile &apos;junit:junit:4.12&apos;\n}\n</code></pre><p>而后在test文件下写单元测试类<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png\" alt=\"enter image description here\"></p>\n<p>被测试类如下</p>\n<pre><code>public class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n</code></pre><p>单元测试类如下</p>\n<pre><code>public class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n</code></pre><p>最后运行单元测试类，结果如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Junit标签解析\"><a href=\"#Junit标签解析\" class=\"headerlink\" title=\"Junit标签解析\"></a>Junit标签解析</h4><p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<pre><code>@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n</code></pre><p>以如下代码为例：</p>\n<pre><code>public class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(&quot;@Before&quot;);\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(&quot;@After&quot;);\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(&quot;@AfterClass&quot;);\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(&quot;@BeforeClass&quot;);\n    }\n}\n</code></pre><p>相应的执行顺序如下：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Mockito使用方式\"><a href=\"#Mockito使用方式\" class=\"headerlink\" title=\"Mockito使用方式\"></a>Mockito使用方式</h4><p>简介：</p>\n<pre><code>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n</code></pre><p><strong>先体验以下Mockito的使用：</strong></p>\n<p>1.添加依赖</p>\n<pre><code>testCompile &apos;org.mockito:mockito-core:2.8.47&apos;\n</code></pre><p>2.被依赖类</p>\n<pre><code>public interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n</code></pre><p>3.依赖类</p>\n<pre><code>@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>可以发现<strong>IMathUtils</strong>是一个接口，根本就没有实现，用<strong>Mockito</strong>框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！<strong>Mockito代理了IMathUtils.abs(num)的行为</strong>，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法<strong>when…thenReturn…</strong>相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<pre><code>public class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>其中<strong>@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();</strong> 用于初始化Mock对象，效果与在类前添加<strong>@RunWith(MockitoJUnitRunner.class)</strong>标签类似</p>\n<p><strong>Mock配置</strong></p>\n<p>Mock有多种配置方式，如下所示：</p>\n<pre><code>@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);\n        String result=i.next()+&quot; &quot;+i.next();\n        // 断言\n        assertEquals(&quot;Mockito rocks&quot;, result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);\n        when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(&quot;Mockito&quot;));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n</code></pre><p>更多配置可以看下这个网站  <a href=\"http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html\" target=\"_blank\" rel=\"noopener\">点击链接</a></p>\n<h3 id=\"UI测试\"><a href=\"#UI测试\" class=\"headerlink\" title=\"UI测试\"></a>UI测试</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n</code></pre><h4 id=\"使用方式-2\"><a href=\"#使用方式-2\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<pre><code>testCompile &apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;\ntestCompile &apos;com.android.support.test:runner:0.4.1&apos;\n</code></pre><p>2.在androidTest目录下创建测试类</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png\" alt=\"enter image description here\"></p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\n</code></pre><p>activity_main.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    tools:context=&quot;xgn.com.androidautotest.MainActivity&quot;&gt;\n\n&lt;TextView\n    android:id=&quot;@+id/tv&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_marginTop=&quot;15dp&quot;\n    android:padding=&quot;10dp&quot;\n    android:text=&quot;helo&quot; /&gt;\n\n&lt;EditText\n    android:id=&quot;@+id/et&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;40dp&quot;\n    android:layout_alignParentLeft=&quot;true&quot;\n    android:layout_alignParentStart=&quot;true&quot;\n    android:layout_alignParentTop=&quot;true&quot;\n    android:layout_marginTop=&quot;75dp&quot; /&gt;\n\n&lt;Button\n    android:id=&quot;@+id/btn&quot;\n    android:layout_width=&quot;80dp&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_below=&quot;@+id/et&quot;\n    android:layout_centerHorizontal=&quot;true&quot;\n    android:layout_marginTop=&quot;49dp&quot;\n    android:text=&quot;sure&quot; /&gt;\n&lt;/RelativeLayout&gt;\n</code></pre><p>测试类<br>ExampleInstrumentedTest.class</p>\n<pre><code>@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n</code></pre><p>其中<strong>onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());</strong>选择界面中的输入框，并输入“helo world”，<strong>onView(withId(R.id.btn)).perform(click());</strong>选择界面中的按钮并点击。</p>\n<p><a href=\"https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md\" target=\"_blank\" rel=\"noopener\">更多操作方式-1</a><br><a href=\"http://blog.csdn.net/eclipsexys/article/details/45622813\" target=\"_blank\" rel=\"noopener\">更多操作方式-2</a></p>\n<h4 id=\"标签解析\"><a href=\"#标签解析\" class=\"headerlink\" title=\"标签解析\"></a>标签解析</h4><pre><code>@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n</code></pre><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n</code></pre><p>Android自动化测试</p>\n<p>enter image description here</p>\n<p>Android自动化测试<br>摘要<br>Monkey测试<br>简介<br>使用方式<br>效果展示<br>更多参数介绍<br>可能会遇到的问题<br>单元测试<br>简介<br>使用方式<br>Junit标签解析<br>Mockito使用方式<br>UI测试<br>简介<br>使用方式<br>标签解析<br>总结<br>摘要</p>\n<p>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。<br>Monkey测试</p>\n<p>简介</p>\n<p>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。<br>使用方式</p>\n<p>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；<br>（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；<br>（3）Monkey 命令启动方式：  </p>\n<pre><code>- 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n- 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n- 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><p>效果展示</p>\n<p>部分输出数据如下所示：</p>\n<p>输出数据</p>\n<p>更多参数介绍</p>\n<p>点击查看</p>\n<p>可能会遇到的问题</p>\n<p>（1）“’adb’ 不是内部或外部命令，也不是可运行的程序或批处理文件。”<br>点击查看解决方案</p>\n<p>单元测试</p>\n<p>简介</p>\n<p>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。<br>使用方式</p>\n<p>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：</p>\n<p>dependencies {<br>    testCompile ‘junit:junit:4.12’<br>}<br>而后在test文件下写单元测试类</p>\n<p>enter image description here</p>\n<p>被测试类如下</p>\n<p>public class Calculator {<br>    public static int add(int a, int b) {<br>        return a + b;<br>    }<br>}<br>单元测试类如下</p>\n<p>public class ExampleUnitTest {<br>    @Test<br>    public void addition_isCorrect() throws Exception {<br>        assertEquals(4, Calculator.add(2,2));<br>    }<br>}<br>最后运行单元测试类，结果如下：</p>\n<p>enter image description here</p>\n<p>Junit标签解析</p>\n<p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<p>@Test： 将方法（函数）标记为测试用例<br>@Before： 每一个使用@Test标记的方法运行之前都要运行一次<br>@After： 每一个使用@Test标记的方法运行之后都要运行一次<br>@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次<br>@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次<br>以如下代码为例：</p>\n<p>public class ExampleUnitTest {</p>\n<pre><code>@Test\npublic void addition_isCorrect() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n\n@Test\npublic void addition_isErr() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n@Before\npublic void before() throws Exception {\n    System.out.println(&quot;@Before&quot;);\n}\n\n@After\npublic void after() throws Exception {\n    System.out.println(&quot;@After&quot;);\n}\n\n\n@AfterClass\npublic static void afterClass() throws Exception {\n    System.out.println(&quot;@AfterClass&quot;);\n}\n\n@BeforeClass\npublic static void beforeClass() throws Exception {\n    System.out.println(&quot;@BeforeClass&quot;);\n}\n</code></pre><p>}<br>相应的执行顺序如下：</p>\n<p>enter image description here</p>\n<p>Mockito使用方式</p>\n<p>简介：</p>\n<p>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。<br>先体验以下Mockito的使用：</p>\n<p>1.添加依赖</p>\n<p>testCompile ‘org.mockito:mockito-core:2.8.47’<br>2.被依赖类</p>\n<p>public interface IMathUtils {<br>    public int abs(int num); // 求绝对值<br>}<br>3.依赖类</p>\n<p>@RunWith(MockitoJUnitRunner.class)<br>public class MockTest {<br>    @Mock<br>    IMathUtils mathUtils;</p>\n<pre><code>@Test\npublic void mockTest() {\n\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<p>public class MockTest {</p>\n<pre><code>@Mock\nIMathUtils iMathUtils ; \n\n@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n@Test\npublic void mockTest()  {\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似</p>\n<p>Mock配置</p>\n<p>Mock有多种配置方式，如下所示：</p>\n<p>@Test<br>public void test1()  {<br>        //  创建 mock<br>        MyClass test = Mockito.mock(MyClass.class);</p>\n<pre><code>// 自定义 getUniqueId() 的返回值\nwhen(test.getUniqueId()).thenReturn(43);\n\n// 在测试中使用mock对象\nassertEquals(test.getUniqueId(), 43);\n</code></pre><p>}</p>\n<p>// 返回多个值<br>@Test<br>public void testMoreThanOneReturnValue()  {<br>        Iterator i= mock(Iterator.class);<br>        when(i.next()).thenReturn(“Mockito”).thenReturn(“rocks”);<br>        String result=i.next()+” “+i.next();<br>        // 断言<br>        assertEquals(“Mockito rocks”, result);<br>}</p>\n<p>// 如何根据输入来返回值<br>@Test<br>public void testReturnValueDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(“Mockito”)).thenReturn(1);<br>        when(c.compareTo(“Eclipse”)).thenReturn(2);<br>        // 断言<br>        assertEquals(1,c.compareTo(“Mockito”));<br>}</p>\n<p>// 如何让返回值不依赖于输入<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(anyInt())).thenReturn(-1);<br>        // 断言<br>        assertEquals(-1 ,c.compareTo(9));<br>}</p>\n<p>// 根据参数类型来返回值<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(isA(Todo.class))).thenReturn(0);<br>        // 断言<br>        Todo todo = new Todo(5);<br>        assertEquals(todo ,c.compareTo(new Todo(1)));<br>}<br>更多配置可以看下这个网站 点击链接</p>\n<p>UI测试</p>\n<p>简介</p>\n<p>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。<br>使用方式</p>\n<p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<p>testCompile ‘com.android.support.test.espresso:espresso-core:2.2.2’<br>testCompile ‘com.android.support.test:runner:0.4.1’<br>2.在androidTest目录下创建测试类</p>\n<p>enter image description here</p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<p>public class MainActivity extends AppCompatActivity implements View.OnClickListener{</p>\n<pre><code>private EditText mEt;\nprivate TextView mTv;\nprivate Button mBtn;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    mEt = (EditText) findViewById(R.id.et);\n    mTv = (TextView) findViewById(R.id.tv);\n    mBtn = (Button) findViewById(R.id.btn);\n\n    mBtn.setOnClickListener(this);\n}\n\n@Override\npublic void onClick(View v) {\n    mTv.setText(mEt.getText().toString());\n}\n</code></pre><p>}<br>activity_main.xml</p>\n<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>\n<relativelayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<textview android:id=\"@+id/tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margintop=\"15dp\" android:padding=\"10dp\" android:text=\"helo\">\n\n<edittext android:id=\"@+id/et\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:layout_alignparentleft=\"true\" android:layout_alignparentstart=\"true\" android:layout_alignparenttop=\"true\" android:layout_margintop=\"75dp\">\n\n<p><button android:id=\"@+id/btn\" android:layout_width=\"80dp\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/et\" android:layout_centerhorizontal=\"true\" android:layout_margintop=\"49dp\" android:text=\"sure\"><br></button></p></edittext></textview></relativelayout><br>测试类<br>ExampleInstrumentedTest.class<p></p>\n<p>@RunWith(AndroidJUnit4.class)<br>public class ExampleInstrumentedTest {<br>    @Rule<br>    public ActivityTestRule<mainactivity> mActivityRule = new ActivityTestRule&lt;&gt;(<br>            MainActivity.class);</mainactivity></p>\n<pre><code>@Test\npublic void useAppContext() throws Exception {\n    // Context of the app under test.\n    onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n            closeSoftKeyboard());\n    onView(withId(R.id.btn)).perform(click());\n}\n</code></pre><p>}<br>其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。</p>\n<p>更多操作方式-1<br>更多操作方式-2</p>\n<p>标签解析</p>\n<p>@Rule: 应用于成员变量<br>@ClassRule: 应用于测试类中的静态变量<br>两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。</p>\n<p>@RunWith（AndroidJUnit4.class）：  用于修改测试运行器<br>总结</p>\n<p>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。<br>     7539<br>qqq2830<br> 退出账号<br>当前文档<br> 恢复至上次同步状态<br> 删除文档<br> 导出…<br> 预览文档<br> 分享链接<br>系统<br> 设置<br> 使用说明<br> 快捷帮助<br> 常见问题<br> 关于</p>\n<p>搜索文件<br>杂物 Android自动化测试<br>杂物 SwipeToLoadLayout<br>检查Evernote中的笔记版本</p>\n"},{"title":"Dagger2全面解析","date":"2016-06-01T15:47:44.000Z","_content":"\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/timg.jpg)\n\n### Dagger2的好处\n\n- 依赖的注入和配置独立于组件之外。\n- 因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。\n- 依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。\n\n\n### 相关标签\n\n **@Inject、@Module、@Provide、@Component**\n\n- @Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。\n\n- @Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。\n\n- @Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。\n\n- @Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。\n\n\n### 标签使用方式\n\n**1.@Inject**  \n\n    public class User {  \n  \n\t    ....  \n\t    ....  \n\t    //在被依赖类中使用@Inject标记该类的构造方法\n\t    @Inject  \n\t    public User() {  \n\t    }  \n\t  \n\t    ....  \n\t    ....    \n\t}  \n\n--------------\n\n    public class MainActivity extends AppCompatActivity {  \n\t\t  \n\t    //在依赖类中使用@Inject来注入被依赖类实例\n\t    @Inject  \n\t    User user;  \n\t    @Inject  \n\t    User user2;  \n\t    private TextView tv;  \n\t    private TextView tv2;  \n\t  \n\t    @Override  \n\t    protected void onCreate(Bundle savedInstanceState) {  \n\t        super.onCreate(savedInstanceState);  \n\t        setContentView(R.layout.activity_main);  \n\t        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n\t        DaggerActivityComponent.builder().build().inject(this);  \n\t        tv = ((TextView) findViewById(R.id.tv));  \n\t        tv2 = ((TextView) findViewById(R.id.tv2));  \n\t        tv.setText(user.toString());  \n\t        tv2.setText(user2.toString());  \n\t    }  \n\t} \n\n**2.@Component**\n\t\t\n    @Component  \n\tpublic interface ActivityComponent {  \n\t    void inject(MainActivity activity);  \n\t}  \n\n**3.@Provider & @Module**\n\n    @Module  \n\tpublic class UserModule {  \n\t    @Provides\n\t    User providesUser() {  \n\t        return new User();  \n\t    }  \n\t}  \n\n\n\n### 注入方式\n- 构造方法注入：在类的构造方法前面注释@Inject\n- 成员变量注入：在类的成员变量（非私有）前面注释@Inject\n- 函数方法注入：在函数前面注释@Inject\n\n\n### 不同类的关系\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png)\n\n\n### 编译后的生成文件与原文件及关系图\n\n**原文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png)\n\n**生成文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png)\n\n**各文件对应关系**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png)\n\n\n###  注入路径\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png)\n\n\n\n### @Scope（用于划分作用域）\n\n**javax包中自带的@Singleton,其class如下：**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png)\n\n**用户自己写的**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png)\n\n***可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别***\n\n#### 各标签的意义\n\n**@Retention**\n\nRetention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:\n1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略\n2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略\n3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.\n\n**@Documented**\n\nDocumented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 \n\n\n**@Scope**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png)\n\n\n\n### @Singleton的单例模式是如何起作用的（我只是个栗子）\n\n该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png)\n\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png)\n\n\n### @Qualifier的巧用（指哪打哪）\n\n@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。\n\n两个@Qualifier\n\n    @Qualifier\n\tpublic @interface ThemeNight {\n\t\n\t}\n\t\n\t@Qualifier\n\tpublic @interface ThemeDay {\n\t}\n\n-----------------------\n\n    @Module\n\tpublic class ThemeModule {\n\t    @Provides\n\t    @ThemeDay\n\t    Theme provideDayTheme() {\n\t        return new Theme(\"day\");\n\t    }\n\n\t    @Provides\n\t    @ThemeNight\n\t    Theme provideNightTheme() {\n\t        return new Theme(\"night\");\n\t    }\n\t}\n\n------------------\n\n    @Component\n    public interface ThemeComponent{\n\t    void inject(ThemeTest themeTest);\n    }\n    \n\n--------------------\n\n    public class ThemeTest {\n\t    @Inject\n\t    @ThemeDay\n\t    Theme dayTheme;\n\t    @Inject\n\t    @ThemeNight\n\t    Theme nightTheme;\n\n\t    public static void main(String[] arg) {\n\t        ThemeTest themeTest = new ThemeTest();\n\t        DaggerThemeComponent.create().inject(themeTest);\n\t        System.out.println(themeTest.dayTheme.themeName);\n\t        System.out.println(themeTest.nightTheme.themeName);\n\t    }\n\t}\n\n\n\n","source":"_posts/Dagger2.md","raw":"---\ntitle: Dagger2全面解析\ndate: 2016-06-01 23:47:44\ncategories: \"Android基础学习\"\ntags:\n     - Android\n     - 三方框架\n     - 技术\n---\n\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/timg.jpg)\n\n### Dagger2的好处\n\n- 依赖的注入和配置独立于组件之外。\n- 因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。\n- 依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。\n\n\n### 相关标签\n\n **@Inject、@Module、@Provide、@Component**\n\n- @Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。\n\n- @Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。\n\n- @Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。\n\n- @Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。\n\n\n### 标签使用方式\n\n**1.@Inject**  \n\n    public class User {  \n  \n\t    ....  \n\t    ....  \n\t    //在被依赖类中使用@Inject标记该类的构造方法\n\t    @Inject  \n\t    public User() {  \n\t    }  \n\t  \n\t    ....  \n\t    ....    \n\t}  \n\n--------------\n\n    public class MainActivity extends AppCompatActivity {  \n\t\t  \n\t    //在依赖类中使用@Inject来注入被依赖类实例\n\t    @Inject  \n\t    User user;  \n\t    @Inject  \n\t    User user2;  \n\t    private TextView tv;  \n\t    private TextView tv2;  \n\t  \n\t    @Override  \n\t    protected void onCreate(Bundle savedInstanceState) {  \n\t        super.onCreate(savedInstanceState);  \n\t        setContentView(R.layout.activity_main);  \n\t        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n\t        DaggerActivityComponent.builder().build().inject(this);  \n\t        tv = ((TextView) findViewById(R.id.tv));  \n\t        tv2 = ((TextView) findViewById(R.id.tv2));  \n\t        tv.setText(user.toString());  \n\t        tv2.setText(user2.toString());  \n\t    }  \n\t} \n\n**2.@Component**\n\t\t\n    @Component  \n\tpublic interface ActivityComponent {  \n\t    void inject(MainActivity activity);  \n\t}  \n\n**3.@Provider & @Module**\n\n    @Module  \n\tpublic class UserModule {  \n\t    @Provides\n\t    User providesUser() {  \n\t        return new User();  \n\t    }  \n\t}  \n\n\n\n### 注入方式\n- 构造方法注入：在类的构造方法前面注释@Inject\n- 成员变量注入：在类的成员变量（非私有）前面注释@Inject\n- 函数方法注入：在函数前面注释@Inject\n\n\n### 不同类的关系\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png)\n\n\n### 编译后的生成文件与原文件及关系图\n\n**原文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png)\n\n**生成文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png)\n\n**各文件对应关系**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png)\n\n\n###  注入路径\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png)\n\n\n\n### @Scope（用于划分作用域）\n\n**javax包中自带的@Singleton,其class如下：**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png)\n\n**用户自己写的**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png)\n\n***可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别***\n\n#### 各标签的意义\n\n**@Retention**\n\nRetention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:\n1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略\n2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略\n3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.\n\n**@Documented**\n\nDocumented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 \n\n\n**@Scope**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png)\n\n\n\n### @Singleton的单例模式是如何起作用的（我只是个栗子）\n\n该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png)\n\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png)\n\n\n### @Qualifier的巧用（指哪打哪）\n\n@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。\n\n两个@Qualifier\n\n    @Qualifier\n\tpublic @interface ThemeNight {\n\t\n\t}\n\t\n\t@Qualifier\n\tpublic @interface ThemeDay {\n\t}\n\n-----------------------\n\n    @Module\n\tpublic class ThemeModule {\n\t    @Provides\n\t    @ThemeDay\n\t    Theme provideDayTheme() {\n\t        return new Theme(\"day\");\n\t    }\n\n\t    @Provides\n\t    @ThemeNight\n\t    Theme provideNightTheme() {\n\t        return new Theme(\"night\");\n\t    }\n\t}\n\n------------------\n\n    @Component\n    public interface ThemeComponent{\n\t    void inject(ThemeTest themeTest);\n    }\n    \n\n--------------------\n\n    public class ThemeTest {\n\t    @Inject\n\t    @ThemeDay\n\t    Theme dayTheme;\n\t    @Inject\n\t    @ThemeNight\n\t    Theme nightTheme;\n\n\t    public static void main(String[] arg) {\n\t        ThemeTest themeTest = new ThemeTest();\n\t        DaggerThemeComponent.create().inject(themeTest);\n\t        System.out.println(themeTest.dayTheme.themeName);\n\t        System.out.println(themeTest.nightTheme.themeName);\n\t    }\n\t}\n\n\n\n","slug":"Dagger2","published":1,"updated":"2018-02-06T03:24:54.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5igux100038giej7apd2do","content":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/timg.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"Dagger2的好处\"><a href=\"#Dagger2的好处\" class=\"headerlink\" title=\"Dagger2的好处\"></a>Dagger2的好处</h3><ul>\n<li>依赖的注入和配置独立于组件之外。</li>\n<li>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</li>\n<li>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</li>\n</ul>\n<h3 id=\"相关标签\"><a href=\"#相关标签\" class=\"headerlink\" title=\"相关标签\"></a>相关标签</h3><p> <strong>@Inject、@Module、@Provide、@Component</strong></p>\n<ul>\n<li><p>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</p>\n</li>\n<li><p>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</p>\n</li>\n<li><p>@Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</p>\n</li>\n<li><p>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。</p>\n</li>\n</ul>\n<h3 id=\"标签使用方式\"><a href=\"#标签使用方式\" class=\"headerlink\" title=\"标签使用方式\"></a>标签使用方式</h3><p><strong>1.@Inject</strong>  </p>\n<pre><code>public class User {  \n\n    ....  \n    ....  \n    //在被依赖类中使用@Inject标记该类的构造方法\n    @Inject  \n    public User() {  \n    }  \n\n    ....  \n    ....    \n}  \n</code></pre><hr>\n<pre><code>public class MainActivity extends AppCompatActivity {  \n\n    //在依赖类中使用@Inject来注入被依赖类实例\n    @Inject  \n    User user;  \n    @Inject  \n    User user2;  \n    private TextView tv;  \n    private TextView tv2;  \n\n    @Override  \n    protected void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.activity_main);  \n        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n        DaggerActivityComponent.builder().build().inject(this);  \n        tv = ((TextView) findViewById(R.id.tv));  \n        tv2 = ((TextView) findViewById(R.id.tv2));  \n        tv.setText(user.toString());  \n        tv2.setText(user2.toString());  \n    }  \n} \n</code></pre><p><strong>2.@Component</strong></p>\n<pre><code>@Component  \npublic interface ActivityComponent {  \n    void inject(MainActivity activity);  \n}  \n</code></pre><p><strong>3.@Provider &amp; @Module</strong></p>\n<pre><code>@Module  \npublic class UserModule {  \n    @Provides\n    User providesUser() {  \n        return new User();  \n    }  \n}  \n</code></pre><h3 id=\"注入方式\"><a href=\"#注入方式\" class=\"headerlink\" title=\"注入方式\"></a>注入方式</h3><ul>\n<li>构造方法注入：在类的构造方法前面注释@Inject</li>\n<li>成员变量注入：在类的成员变量（非私有）前面注释@Inject</li>\n<li>函数方法注入：在函数前面注释@Inject</li>\n</ul>\n<h3 id=\"不同类的关系\"><a href=\"#不同类的关系\" class=\"headerlink\" title=\"不同类的关系\"></a>不同类的关系</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png\" alt=\"enter image description here\"></p>\n<h3 id=\"编译后的生成文件与原文件及关系图\"><a href=\"#编译后的生成文件与原文件及关系图\" class=\"headerlink\" title=\"编译后的生成文件与原文件及关系图\"></a>编译后的生成文件与原文件及关系图</h3><p><strong>原文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png\" alt=\"enter image description here\"></p>\n<p><strong>生成文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png\" alt=\"enter image description here\"></p>\n<p><strong>各文件对应关系</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png\" alt=\"enter image description here\"></p>\n<h3 id=\"注入路径\"><a href=\"#注入路径\" class=\"headerlink\" title=\"注入路径\"></a>注入路径</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Scope（用于划分作用域）\"><a href=\"#Scope（用于划分作用域）\" class=\"headerlink\" title=\"@Scope（用于划分作用域）\"></a>@Scope（用于划分作用域）</h3><p><strong>javax包中自带的@Singleton,其class如下：</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png\" alt=\"enter image description here\"></p>\n<p><strong>用户自己写的</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png\" alt=\"enter image description here\"></p>\n<p><strong><em>可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别</em></strong></p>\n<h4 id=\"各标签的意义\"><a href=\"#各标签的意义\" class=\"headerlink\" title=\"各标签的意义\"></a>各标签的意义</h4><p><strong>@Retention</strong></p>\n<p>Retention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:<br>1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略<br>2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略<br>3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.</p>\n<p><strong>@Documented</strong></p>\n<p>Documented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 </p>\n<p><strong>@Scope</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Singleton的单例模式是如何起作用的（我只是个栗子）\"><a href=\"#Singleton的单例模式是如何起作用的（我只是个栗子）\" class=\"headerlink\" title=\"@Singleton的单例模式是如何起作用的（我只是个栗子）\"></a>@Singleton的单例模式是如何起作用的（我只是个栗子）</h3><p>该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Qualifier的巧用（指哪打哪）\"><a href=\"#Qualifier的巧用（指哪打哪）\" class=\"headerlink\" title=\"@Qualifier的巧用（指哪打哪）\"></a>@Qualifier的巧用（指哪打哪）</h3><p>@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。</p>\n<p>两个@Qualifier</p>\n<pre><code>@Qualifier\npublic @interface ThemeNight {\n\n}\n\n@Qualifier\npublic @interface ThemeDay {\n}\n</code></pre><hr>\n<pre><code>@Module\npublic class ThemeModule {\n    @Provides\n    @ThemeDay\n    Theme provideDayTheme() {\n        return new Theme(&quot;day&quot;);\n    }\n\n    @Provides\n    @ThemeNight\n    Theme provideNightTheme() {\n        return new Theme(&quot;night&quot;);\n    }\n}\n</code></pre><hr>\n<pre><code>@Component\npublic interface ThemeComponent{\n    void inject(ThemeTest themeTest);\n}\n</code></pre><hr>\n<pre><code>public class ThemeTest {\n    @Inject\n    @ThemeDay\n    Theme dayTheme;\n    @Inject\n    @ThemeNight\n    Theme nightTheme;\n\n    public static void main(String[] arg) {\n        ThemeTest themeTest = new ThemeTest();\n        DaggerThemeComponent.create().inject(themeTest);\n        System.out.println(themeTest.dayTheme.themeName);\n        System.out.println(themeTest.nightTheme.themeName);\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/timg.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"Dagger2的好处\"><a href=\"#Dagger2的好处\" class=\"headerlink\" title=\"Dagger2的好处\"></a>Dagger2的好处</h3><ul>\n<li>依赖的注入和配置独立于组件之外。</li>\n<li>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</li>\n<li>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</li>\n</ul>\n<h3 id=\"相关标签\"><a href=\"#相关标签\" class=\"headerlink\" title=\"相关标签\"></a>相关标签</h3><p> <strong>@Inject、@Module、@Provide、@Component</strong></p>\n<ul>\n<li><p>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</p>\n</li>\n<li><p>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</p>\n</li>\n<li><p>@Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</p>\n</li>\n<li><p>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。</p>\n</li>\n</ul>\n<h3 id=\"标签使用方式\"><a href=\"#标签使用方式\" class=\"headerlink\" title=\"标签使用方式\"></a>标签使用方式</h3><p><strong>1.@Inject</strong>  </p>\n<pre><code>public class User {  \n\n    ....  \n    ....  \n    //在被依赖类中使用@Inject标记该类的构造方法\n    @Inject  \n    public User() {  \n    }  \n\n    ....  \n    ....    \n}  \n</code></pre><hr>\n<pre><code>public class MainActivity extends AppCompatActivity {  \n\n    //在依赖类中使用@Inject来注入被依赖类实例\n    @Inject  \n    User user;  \n    @Inject  \n    User user2;  \n    private TextView tv;  \n    private TextView tv2;  \n\n    @Override  \n    protected void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.activity_main);  \n        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n        DaggerActivityComponent.builder().build().inject(this);  \n        tv = ((TextView) findViewById(R.id.tv));  \n        tv2 = ((TextView) findViewById(R.id.tv2));  \n        tv.setText(user.toString());  \n        tv2.setText(user2.toString());  \n    }  \n} \n</code></pre><p><strong>2.@Component</strong></p>\n<pre><code>@Component  \npublic interface ActivityComponent {  \n    void inject(MainActivity activity);  \n}  \n</code></pre><p><strong>3.@Provider &amp; @Module</strong></p>\n<pre><code>@Module  \npublic class UserModule {  \n    @Provides\n    User providesUser() {  \n        return new User();  \n    }  \n}  \n</code></pre><h3 id=\"注入方式\"><a href=\"#注入方式\" class=\"headerlink\" title=\"注入方式\"></a>注入方式</h3><ul>\n<li>构造方法注入：在类的构造方法前面注释@Inject</li>\n<li>成员变量注入：在类的成员变量（非私有）前面注释@Inject</li>\n<li>函数方法注入：在函数前面注释@Inject</li>\n</ul>\n<h3 id=\"不同类的关系\"><a href=\"#不同类的关系\" class=\"headerlink\" title=\"不同类的关系\"></a>不同类的关系</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png\" alt=\"enter image description here\"></p>\n<h3 id=\"编译后的生成文件与原文件及关系图\"><a href=\"#编译后的生成文件与原文件及关系图\" class=\"headerlink\" title=\"编译后的生成文件与原文件及关系图\"></a>编译后的生成文件与原文件及关系图</h3><p><strong>原文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png\" alt=\"enter image description here\"></p>\n<p><strong>生成文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png\" alt=\"enter image description here\"></p>\n<p><strong>各文件对应关系</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png\" alt=\"enter image description here\"></p>\n<h3 id=\"注入路径\"><a href=\"#注入路径\" class=\"headerlink\" title=\"注入路径\"></a>注入路径</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Scope（用于划分作用域）\"><a href=\"#Scope（用于划分作用域）\" class=\"headerlink\" title=\"@Scope（用于划分作用域）\"></a>@Scope（用于划分作用域）</h3><p><strong>javax包中自带的@Singleton,其class如下：</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png\" alt=\"enter image description here\"></p>\n<p><strong>用户自己写的</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png\" alt=\"enter image description here\"></p>\n<p><strong><em>可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别</em></strong></p>\n<h4 id=\"各标签的意义\"><a href=\"#各标签的意义\" class=\"headerlink\" title=\"各标签的意义\"></a>各标签的意义</h4><p><strong>@Retention</strong></p>\n<p>Retention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:<br>1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略<br>2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略<br>3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.</p>\n<p><strong>@Documented</strong></p>\n<p>Documented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 </p>\n<p><strong>@Scope</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Singleton的单例模式是如何起作用的（我只是个栗子）\"><a href=\"#Singleton的单例模式是如何起作用的（我只是个栗子）\" class=\"headerlink\" title=\"@Singleton的单例模式是如何起作用的（我只是个栗子）\"></a>@Singleton的单例模式是如何起作用的（我只是个栗子）</h3><p>该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Qualifier的巧用（指哪打哪）\"><a href=\"#Qualifier的巧用（指哪打哪）\" class=\"headerlink\" title=\"@Qualifier的巧用（指哪打哪）\"></a>@Qualifier的巧用（指哪打哪）</h3><p>@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。</p>\n<p>两个@Qualifier</p>\n<pre><code>@Qualifier\npublic @interface ThemeNight {\n\n}\n\n@Qualifier\npublic @interface ThemeDay {\n}\n</code></pre><hr>\n<pre><code>@Module\npublic class ThemeModule {\n    @Provides\n    @ThemeDay\n    Theme provideDayTheme() {\n        return new Theme(&quot;day&quot;);\n    }\n\n    @Provides\n    @ThemeNight\n    Theme provideNightTheme() {\n        return new Theme(&quot;night&quot;);\n    }\n}\n</code></pre><hr>\n<pre><code>@Component\npublic interface ThemeComponent{\n    void inject(ThemeTest themeTest);\n}\n</code></pre><hr>\n<pre><code>public class ThemeTest {\n    @Inject\n    @ThemeDay\n    Theme dayTheme;\n    @Inject\n    @ThemeNight\n    Theme nightTheme;\n\n    public static void main(String[] arg) {\n        ThemeTest themeTest = new ThemeTest();\n        DaggerThemeComponent.create().inject(themeTest);\n        System.out.println(themeTest.dayTheme.themeName);\n        System.out.println(themeTest.nightTheme.themeName);\n    }\n}\n</code></pre>"},{"_content":"1.Dalvik虚拟机与java虚拟机的区别\n\t1.java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。\n\n\t2.Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。\n\n\t3.java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.\n\n2.object的方法 \n\n\twheng fcnt\n\n3.sleep和wait的区别有\n\n\t其实两者都可以让线程暂停一段时间,但是本质的区别是一个线程的运行状态控制,一个是线程之间的通讯的问题\n\n\t在java.lang.Thread类中，提供了sleep()，\n\t而java.lang.Object类中提供了wait()， notify()和notifyAll()方法来操作线程\n\tsleep()可以将一个线程睡眠，参数可以指定一个时间。\n\t而wait()可以将一个线程挂起，直到超时或者该线程被唤醒。\n\n\t1，这两个方法来自不同的类分别是Thread和Object\n\t2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。\n\t3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用\n\n\tsynchronized(x){\n      x.notify()\n     //或者wait()\n   \t}\n\n   \t4,sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常\n\n\n4. Android事件分发机制完全解析\n\n\tonTouch在onClick之前，onTouch返回true则onClick不响应\n\n\tpublic boolean dispatchTouchEvent(MotionEvent event) {  \n\t    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&  \n\t            mOnTouchListener.onTouch(this, event)) {  \n\t        return true;  \n\t    }  \n\t    return onTouchEvent(event);  \n\t}  \n\n\n\tonTouchEvent方法中会调用onClick方法\n\n\tonTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。\n\n\t问题1：为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\n\n\t\t当时我在图片轮播器里使用Button，主要就是因为Button是可点击的，而ImageView是不可点击的。如果想要使用ImageView，可以有两种改法。第一，在ImageView的onTouch方法里返回true，这样可以保证ACTION_DOWN之后的其它action都能得到执行，才能实现图片滚动的效果。第二，在布局文件里面给ImageView增加一个android:clickable=\"true\"的属性，这样ImageView变成可点击的之后，即使在onTouch里返回了false，ACTION_DOWN之后的其它action也是可以得到执行的。\n\n\n\tViewGroup中有一个onInterceptTouchEvent方法，默认返回false，该方法在dispatchTouchEvent中调用。\n\n\n\t事件传递机制  activity  -> window ->顶层容器(decorView) ->view  如果所有view都不处理事件，则事件会传递给activity的onTouchEvent方法\n\n\t1.View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，onTouchEvent就会被执行。\n\t2.正常情况下，一个事件序列只能被一个View拦截且消耗。\n\t3.当一个View决定拦截一个事件后，那么系统会把后序事件给它处理，并且他的onInterceptTouchEvent不会再被调用。\n\t4.某个View一旦开始处理事件，但是不消耗ACTION_DOWN事件（onTouchEvent返回了 false），那么同一事件序列中的其他事件都不会交给它来处理。\n\t5.如果View不消耗ACTION_DOWN之外的其他事件，娜美这个点击事件会消失，父元素的onTouchEvent不会被调用，且当前View可以持续受到后序的事件，最后这些消失的点击事件会传递给Activity处理。\n\t6.ViewGroup默认不拦截任何事件\n\t7.View没有onInterceptTouchEvent方法\n\t8.View的onTouchEvent默认都会消耗事件。除非它是不可点击的（clickable和longClickable同时为false）\n\t9.View的enable属性不影响onTouchEvent的默认返回值。\n\t10.requestDisallowInterceptTouchEvent方法可在子元素中干预父元素的时间分发过程，但是ACTION_DOWN事件除外\n\t11.事件重写一般就写：onInterceptTouchEvent和onTouchEvent方法。\n\n\n5.js与webView交互\n\t <script type=\"text/javascript\">  \n    var result = JavaScriptInterface.jsontohtml();  \n    var obj = eval(\"(\"+result+\")\");//解析json字符串  \n    function showAndroidToast(toast)   \n    {          \n        JavaScriptInterface.showToast(toast);   \n    }  \n    function getjsonData(){  \n        var result = JavaScriptInterface.jsontohtml();  \n        var obj = eval(\"(\"+result+\")\");//解析json字符串  \n        for(i=0;i<obj.length;i++){  \n            var user=obj[i];  \n            document.write(\"<p>姓名:\"+user.name+\"</p>\");  \n            document.write(\"<p>年龄:\"+user.age+\"</p>\");  \n            document.write(\"<p>地址:\"+user.address+\"</p>\");  \n            if(user.phone!=null){  \n                document.write(\"<p>手机号码:\"+user.address+\"</p>\");  \n            }  \n        }  \n    }     \n    function list(){  \n        document.write(\"<div data-role='header'><p>another</p></div>\");  \n    }  \n    </script>  \n\n","source":"_posts/面试题4.md","raw":"1.Dalvik虚拟机与java虚拟机的区别\n\t1.java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。\n\n\t2.Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。\n\n\t3.java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.\n\n2.object的方法 \n\n\twheng fcnt\n\n3.sleep和wait的区别有\n\n\t其实两者都可以让线程暂停一段时间,但是本质的区别是一个线程的运行状态控制,一个是线程之间的通讯的问题\n\n\t在java.lang.Thread类中，提供了sleep()，\n\t而java.lang.Object类中提供了wait()， notify()和notifyAll()方法来操作线程\n\tsleep()可以将一个线程睡眠，参数可以指定一个时间。\n\t而wait()可以将一个线程挂起，直到超时或者该线程被唤醒。\n\n\t1，这两个方法来自不同的类分别是Thread和Object\n\t2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。\n\t3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用\n\n\tsynchronized(x){\n      x.notify()\n     //或者wait()\n   \t}\n\n   \t4,sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常\n\n\n4. Android事件分发机制完全解析\n\n\tonTouch在onClick之前，onTouch返回true则onClick不响应\n\n\tpublic boolean dispatchTouchEvent(MotionEvent event) {  \n\t    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&  \n\t            mOnTouchListener.onTouch(this, event)) {  \n\t        return true;  \n\t    }  \n\t    return onTouchEvent(event);  \n\t}  \n\n\n\tonTouchEvent方法中会调用onClick方法\n\n\tonTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。\n\n\t问题1：为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\n\n\t\t当时我在图片轮播器里使用Button，主要就是因为Button是可点击的，而ImageView是不可点击的。如果想要使用ImageView，可以有两种改法。第一，在ImageView的onTouch方法里返回true，这样可以保证ACTION_DOWN之后的其它action都能得到执行，才能实现图片滚动的效果。第二，在布局文件里面给ImageView增加一个android:clickable=\"true\"的属性，这样ImageView变成可点击的之后，即使在onTouch里返回了false，ACTION_DOWN之后的其它action也是可以得到执行的。\n\n\n\tViewGroup中有一个onInterceptTouchEvent方法，默认返回false，该方法在dispatchTouchEvent中调用。\n\n\n\t事件传递机制  activity  -> window ->顶层容器(decorView) ->view  如果所有view都不处理事件，则事件会传递给activity的onTouchEvent方法\n\n\t1.View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，onTouchEvent就会被执行。\n\t2.正常情况下，一个事件序列只能被一个View拦截且消耗。\n\t3.当一个View决定拦截一个事件后，那么系统会把后序事件给它处理，并且他的onInterceptTouchEvent不会再被调用。\n\t4.某个View一旦开始处理事件，但是不消耗ACTION_DOWN事件（onTouchEvent返回了 false），那么同一事件序列中的其他事件都不会交给它来处理。\n\t5.如果View不消耗ACTION_DOWN之外的其他事件，娜美这个点击事件会消失，父元素的onTouchEvent不会被调用，且当前View可以持续受到后序的事件，最后这些消失的点击事件会传递给Activity处理。\n\t6.ViewGroup默认不拦截任何事件\n\t7.View没有onInterceptTouchEvent方法\n\t8.View的onTouchEvent默认都会消耗事件。除非它是不可点击的（clickable和longClickable同时为false）\n\t9.View的enable属性不影响onTouchEvent的默认返回值。\n\t10.requestDisallowInterceptTouchEvent方法可在子元素中干预父元素的时间分发过程，但是ACTION_DOWN事件除外\n\t11.事件重写一般就写：onInterceptTouchEvent和onTouchEvent方法。\n\n\n5.js与webView交互\n\t <script type=\"text/javascript\">  \n    var result = JavaScriptInterface.jsontohtml();  \n    var obj = eval(\"(\"+result+\")\");//解析json字符串  \n    function showAndroidToast(toast)   \n    {          \n        JavaScriptInterface.showToast(toast);   \n    }  \n    function getjsonData(){  \n        var result = JavaScriptInterface.jsontohtml();  \n        var obj = eval(\"(\"+result+\")\");//解析json字符串  \n        for(i=0;i<obj.length;i++){  \n            var user=obj[i];  \n            document.write(\"<p>姓名:\"+user.name+\"</p>\");  \n            document.write(\"<p>年龄:\"+user.age+\"</p>\");  \n            document.write(\"<p>地址:\"+user.address+\"</p>\");  \n            if(user.phone!=null){  \n                document.write(\"<p>手机号码:\"+user.address+\"</p>\");  \n            }  \n        }  \n    }     \n    function list(){  \n        document.write(\"<div data-role='header'><p>another</p></div>\");  \n    }  \n    </script>  \n\n","slug":"面试题4","published":1,"date":"2018-02-27T10:29:44.184Z","updated":"2018-02-27T09:26:47.484Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5igux500068gieexbptimb","content":"<p>1.Dalvik虚拟机与java虚拟机的区别<br>    1.java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。</p>\n<pre><code>2.Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。\n\n3.java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.\n</code></pre><p>2.object的方法 </p>\n<pre><code>wheng fcnt\n</code></pre><p>3.sleep和wait的区别有</p>\n<pre><code>其实两者都可以让线程暂停一段时间,但是本质的区别是一个线程的运行状态控制,一个是线程之间的通讯的问题\n\n在java.lang.Thread类中，提供了sleep()，\n而java.lang.Object类中提供了wait()， notify()和notifyAll()方法来操作线程\nsleep()可以将一个线程睡眠，参数可以指定一个时间。\n而wait()可以将一个线程挂起，直到超时或者该线程被唤醒。\n\n1，这两个方法来自不同的类分别是Thread和Object\n2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。\n3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用\n\nsynchronized(x){\n  x.notify()\n //或者wait()\n   }\n\n   4,sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常\n</code></pre><ol>\n<li><p>Android事件分发机制完全解析</p>\n<p> onTouch在onClick之前，onTouch返回true则onClick不响应</p>\n<p> public boolean dispatchTouchEvent(MotionEvent event) {  </p>\n<pre><code>if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  \n        mOnTouchListener.onTouch(this, event)) {  \n    return true;  \n}  \nreturn onTouchEvent(event);  \n</code></pre><p> }  </p>\n</li>\n</ol>\n<pre><code>onTouchEvent方法中会调用onClick方法\n\nonTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。\n\n问题1：为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\n\n    当时我在图片轮播器里使用Button，主要就是因为Button是可点击的，而ImageView是不可点击的。如果想要使用ImageView，可以有两种改法。第一，在ImageView的onTouch方法里返回true，这样可以保证ACTION_DOWN之后的其它action都能得到执行，才能实现图片滚动的效果。第二，在布局文件里面给ImageView增加一个android:clickable=&quot;true&quot;的属性，这样ImageView变成可点击的之后，即使在onTouch里返回了false，ACTION_DOWN之后的其它action也是可以得到执行的。\n\n\nViewGroup中有一个onInterceptTouchEvent方法，默认返回false，该方法在dispatchTouchEvent中调用。\n\n\n事件传递机制  activity  -&gt; window -&gt;顶层容器(decorView) -&gt;view  如果所有view都不处理事件，则事件会传递给activity的onTouchEvent方法\n\n1.View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，onTouchEvent就会被执行。\n2.正常情况下，一个事件序列只能被一个View拦截且消耗。\n3.当一个View决定拦截一个事件后，那么系统会把后序事件给它处理，并且他的onInterceptTouchEvent不会再被调用。\n4.某个View一旦开始处理事件，但是不消耗ACTION_DOWN事件（onTouchEvent返回了 false），那么同一事件序列中的其他事件都不会交给它来处理。\n5.如果View不消耗ACTION_DOWN之外的其他事件，娜美这个点击事件会消失，父元素的onTouchEvent不会被调用，且当前View可以持续受到后序的事件，最后这些消失的点击事件会传递给Activity处理。\n6.ViewGroup默认不拦截任何事件\n7.View没有onInterceptTouchEvent方法\n8.View的onTouchEvent默认都会消耗事件。除非它是不可点击的（clickable和longClickable同时为false）\n9.View的enable属性不影响onTouchEvent的默认返回值。\n10.requestDisallowInterceptTouchEvent方法可在子元素中干预父元素的时间分发过程，但是ACTION_DOWN事件除外\n11.事件重写一般就写：onInterceptTouchEvent和onTouchEvent方法。\n</code></pre><p>5.js与webView交互<br>     <script type=\"text/javascript\"><br>    var result = JavaScriptInterface.jsontohtml();<br>    var obj = eval(“(“+result+”)”);//解析json字符串<br>    function showAndroidToast(toast)<br>    {<br>        JavaScriptInterface.showToast(toast);<br>    }<br>    function getjsonData(){<br>        var result = JavaScriptInterface.jsontohtml();<br>        var obj = eval(“(“+result+”)”);//解析json字符串<br>        for(i=0;i&lt;obj.length;i++){<br>            var user=obj[i];<br>            document.write(“<p>姓名:”+user.name+”</p>“);<br>            document.write(“<p>年龄:”+user.age+”</p>“);<br>            document.write(“<p>地址:”+user.address+”</p>“);<br>            if(user.phone!=null){<br>                document.write(“<p>手机号码:”+user.address+”</p>“);<br>            }<br>        }<br>    }<br>    function list(){<br>        document.write(“<div data-role='header'><p>another</p></div>“);<br>    }<br>    </script>  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.Dalvik虚拟机与java虚拟机的区别<br>    1.java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。</p>\n<pre><code>2.Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。\n\n3.java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.\n</code></pre><p>2.object的方法 </p>\n<pre><code>wheng fcnt\n</code></pre><p>3.sleep和wait的区别有</p>\n<pre><code>其实两者都可以让线程暂停一段时间,但是本质的区别是一个线程的运行状态控制,一个是线程之间的通讯的问题\n\n在java.lang.Thread类中，提供了sleep()，\n而java.lang.Object类中提供了wait()， notify()和notifyAll()方法来操作线程\nsleep()可以将一个线程睡眠，参数可以指定一个时间。\n而wait()可以将一个线程挂起，直到超时或者该线程被唤醒。\n\n1，这两个方法来自不同的类分别是Thread和Object\n2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。\n3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用\n\nsynchronized(x){\n  x.notify()\n //或者wait()\n   }\n\n   4,sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常\n</code></pre><ol>\n<li><p>Android事件分发机制完全解析</p>\n<p> onTouch在onClick之前，onTouch返回true则onClick不响应</p>\n<p> public boolean dispatchTouchEvent(MotionEvent event) {  </p>\n<pre><code>if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  \n        mOnTouchListener.onTouch(this, event)) {  \n    return true;  \n}  \nreturn onTouchEvent(event);  \n</code></pre><p> }  </p>\n</li>\n</ol>\n<pre><code>onTouchEvent方法中会调用onClick方法\n\nonTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。\n\n问题1：为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？\n\n    当时我在图片轮播器里使用Button，主要就是因为Button是可点击的，而ImageView是不可点击的。如果想要使用ImageView，可以有两种改法。第一，在ImageView的onTouch方法里返回true，这样可以保证ACTION_DOWN之后的其它action都能得到执行，才能实现图片滚动的效果。第二，在布局文件里面给ImageView增加一个android:clickable=&quot;true&quot;的属性，这样ImageView变成可点击的之后，即使在onTouch里返回了false，ACTION_DOWN之后的其它action也是可以得到执行的。\n\n\nViewGroup中有一个onInterceptTouchEvent方法，默认返回false，该方法在dispatchTouchEvent中调用。\n\n\n事件传递机制  activity  -&gt; window -&gt;顶层容器(decorView) -&gt;view  如果所有view都不处理事件，则事件会传递给activity的onTouchEvent方法\n\n1.View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，onTouchEvent就会被执行。\n2.正常情况下，一个事件序列只能被一个View拦截且消耗。\n3.当一个View决定拦截一个事件后，那么系统会把后序事件给它处理，并且他的onInterceptTouchEvent不会再被调用。\n4.某个View一旦开始处理事件，但是不消耗ACTION_DOWN事件（onTouchEvent返回了 false），那么同一事件序列中的其他事件都不会交给它来处理。\n5.如果View不消耗ACTION_DOWN之外的其他事件，娜美这个点击事件会消失，父元素的onTouchEvent不会被调用，且当前View可以持续受到后序的事件，最后这些消失的点击事件会传递给Activity处理。\n6.ViewGroup默认不拦截任何事件\n7.View没有onInterceptTouchEvent方法\n8.View的onTouchEvent默认都会消耗事件。除非它是不可点击的（clickable和longClickable同时为false）\n9.View的enable属性不影响onTouchEvent的默认返回值。\n10.requestDisallowInterceptTouchEvent方法可在子元素中干预父元素的时间分发过程，但是ACTION_DOWN事件除外\n11.事件重写一般就写：onInterceptTouchEvent和onTouchEvent方法。\n</code></pre><p>5.js与webView交互<br>     <script type=\"text/javascript\"><br>    var result = JavaScriptInterface.jsontohtml();<br>    var obj = eval(“(“+result+”)”);//解析json字符串<br>    function showAndroidToast(toast)<br>    {<br>        JavaScriptInterface.showToast(toast);<br>    }<br>    function getjsonData(){<br>        var result = JavaScriptInterface.jsontohtml();<br>        var obj = eval(“(“+result+”)”);//解析json字符串<br>        for(i=0;i&lt;obj.length;i++){<br>            var user=obj[i];<br>            document.write(“<p>姓名:”+user.name+”</p>“);<br>            document.write(“<p>年龄:”+user.age+”</p>“);<br>            document.write(“<p>地址:”+user.address+”</p>“);<br>            if(user.phone!=null){<br>                document.write(“<p>手机号码:”+user.address+”</p>“);<br>            }<br>        }<br>    }<br>    function list(){<br>        document.write(“<div data-role='header'><p>another</p></div>“);<br>    }<br>    </script>  </p>\n"},{"_content":"1.Context\n\tActivity、Service、Application都是Context的子类\n\tAndroid系统的角度来理解：Context是一个场景，代表与操作系统的交互的一种过程。\n\tApplication和Service、ContentProvider、BroadcastReceiver无法进行一下操作：\n\t1.show a Dialog\n\t2.start an Activity\n\t3.Layout Inflation\n\n\t启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐\n\n\t在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用\n\n\tContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。\n\n\n\t凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。\n\n2.JNI\n\t那么怎么使用JNI呢，一般情况下我们首先是将写好的C/C++代码编译成对应平台的动态库(windows一般是dll文件，linux一般是so文件等)，这里我们是针对Android平台，所以只讨论so库。\n\n\t1.Java的native方法怎么与C/C++中的函数链接起来?\n\n\t2.JNI定义了与Java对应的数据类型，用于JNI编程?\n\n\t3.描述符－用于描述类名或者数据类型，我们在C/C++层为了获取Java层的对象、变量以及描述Java的方法，需要用字符串来描述需要获取对象的类名、变量类型以及方法。\n\n\n\tpublic class AndroidJni {\n\n\t    static{\n\t        System.loadLibrary(\"main\");\n\t    }\n\n\t    public native void dynamicLog();\n\n\t    public native void staticLog();\n\n\t}\n\n\t这里我们定义了两个声明为native的方法，并声明了一块静态区域，在该静态区域类加载名为libmain.so的库，这里我们说是libmain.so库，但是加载的时候却只写了“main”，其实大家只要知道这是约定的就可以了。\n\n\n\t静态注册native方法\n\t\tJNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog \n\t\tJNIEXPORT和JNICALL两个关键字是两个宏定义,他主要的作用就是说明该函数为JNI函数,在Java虚拟机加载的时候会链接对应的native方法\n\n\t\tJava_PkgName_ClassName_NativeMethodName(包名+类名)\n\n\t\t两个固定的参数变量，分别是JNIEnv和jobject\n\t\tJNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog (JNIEnv *env, jobject obj)\n\n\t\tjobject就是当前与之链接的native方法隶属的类对象(类似于Java中的this)。这两个变量都是Java虚拟机生成并在调用时传递进来的。\n\n\t动态注册\n\t\tJNI_OnLoad函数\n\n\t\tJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {}\n\t\t该函数返回的int表示当前使用的JNI的版本\n\t\t该函数会有两个参数，其中*jvm为Java虚拟机实例，JavaVM结构体定义了以下函数：\n\t\t\tDestroyJavaVM\n\t\t\tAttachCurrentThread\n\t\t\tDetachCurrentThread\n\t\t\tGetEnv\n\t\t这里我们使用了GetEnv函数获取JNIEnv变量，上面的JNI_OnLoad函数中有如下代码：\n\t\t\tJNIEnv *env;\n\t\t\tif (jvm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {\n\n\t\t\t    return -1;\n\t\t\t}\n\t\t这里调用了GetEnv函数获取JNIEnv结构体指针，其实JNIEnv结构体是指向一个函数表的，该函数表指向了对应的JNI函数，我们通过调用这些JNI函数实现JNI编程，在后面我们还会对其进行介绍。\n\n\t\t获取Java对象，完成动态注册\n\n\t\t\t上面介绍了如何获取JNIEnv结构体指针，得到这个结构体指针后我们就可以调用JNIEnv中的RegisterNatives函数完成动态注册native方法了。该方法如下：\n\n\t\t\tjint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods)\n\n\t\t\t第一个参数是Java层对应包含native方法的对象(这里就是AndroidJni对象)，通过调用JNIEnv对应的函数获取class对象(FindClass函数的参数为需要获取class对象的类描述符)：\n\n\t\t\tjclass clz = env->FindClass(\"com/github/songnick/jni/AndroidJni\");\n\n\t\t\t第二个参数是JNINativeMethod结构体指针，这里的JNINativeMethod结构体是描述Java层native方法的，它的定义如下：\n\n\t\t\ttypedef struct {\n\t\t\t    const char* name;//Java层native方法的名字\n\t\t\t    const char* signature;//Java层native方法的描述符\n\t\t\t    void*       fnPtr;//对应JNI函数的指针\n\t\t\t} JNINativeMethod;\n\n\t\t\tJNINativeMethod nativeMethod[] = {{\"dynamicLog\", \"()V\", (void*)nativeDynamicLog}};\n\n\t\t\t最后调用RegisterNative函数完成动态注册：\n\n\t\t\tenv->RegisterNatives(clz, nativeMethod, sizeof(nativeMethod)/sizeof(nativeMethod[0]));\n\n\n\tJNIEnv结构体\n\n\t\t上面提到JNIEnv这个结构体，它就老厉害了，指向一个函数表，该函数表指向一系列的JNI函数，我们通过调用这些JNI函数可以实现与Java层的交互，这里简单的看看几个定义的函数：\n\n\t\t..........\n\t\tjfieldID GetFieldID(jclass clazz, const char* name, const char* sig)\n\t\tjboolean GetBooleanField(jobject obj, jfieldID fieldID)\n\t\tjmethodID GetMethodID(jclass clazz, const char* name, const char* sig)\n\t\tCallVoidMethod(jobject obj, jmethodID methodID, ...)\n\t\tCallBooleanMethod(jobject obj, jmethodID methodID, ...)\n\t\t..........\n\n\n","source":"_posts/面试题3.md","raw":"1.Context\n\tActivity、Service、Application都是Context的子类\n\tAndroid系统的角度来理解：Context是一个场景，代表与操作系统的交互的一种过程。\n\tApplication和Service、ContentProvider、BroadcastReceiver无法进行一下操作：\n\t1.show a Dialog\n\t2.start an Activity\n\t3.Layout Inflation\n\n\t启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐\n\n\t在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用\n\n\tContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。\n\n\n\t凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。\n\n2.JNI\n\t那么怎么使用JNI呢，一般情况下我们首先是将写好的C/C++代码编译成对应平台的动态库(windows一般是dll文件，linux一般是so文件等)，这里我们是针对Android平台，所以只讨论so库。\n\n\t1.Java的native方法怎么与C/C++中的函数链接起来?\n\n\t2.JNI定义了与Java对应的数据类型，用于JNI编程?\n\n\t3.描述符－用于描述类名或者数据类型，我们在C/C++层为了获取Java层的对象、变量以及描述Java的方法，需要用字符串来描述需要获取对象的类名、变量类型以及方法。\n\n\n\tpublic class AndroidJni {\n\n\t    static{\n\t        System.loadLibrary(\"main\");\n\t    }\n\n\t    public native void dynamicLog();\n\n\t    public native void staticLog();\n\n\t}\n\n\t这里我们定义了两个声明为native的方法，并声明了一块静态区域，在该静态区域类加载名为libmain.so的库，这里我们说是libmain.so库，但是加载的时候却只写了“main”，其实大家只要知道这是约定的就可以了。\n\n\n\t静态注册native方法\n\t\tJNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog \n\t\tJNIEXPORT和JNICALL两个关键字是两个宏定义,他主要的作用就是说明该函数为JNI函数,在Java虚拟机加载的时候会链接对应的native方法\n\n\t\tJava_PkgName_ClassName_NativeMethodName(包名+类名)\n\n\t\t两个固定的参数变量，分别是JNIEnv和jobject\n\t\tJNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog (JNIEnv *env, jobject obj)\n\n\t\tjobject就是当前与之链接的native方法隶属的类对象(类似于Java中的this)。这两个变量都是Java虚拟机生成并在调用时传递进来的。\n\n\t动态注册\n\t\tJNI_OnLoad函数\n\n\t\tJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {}\n\t\t该函数返回的int表示当前使用的JNI的版本\n\t\t该函数会有两个参数，其中*jvm为Java虚拟机实例，JavaVM结构体定义了以下函数：\n\t\t\tDestroyJavaVM\n\t\t\tAttachCurrentThread\n\t\t\tDetachCurrentThread\n\t\t\tGetEnv\n\t\t这里我们使用了GetEnv函数获取JNIEnv变量，上面的JNI_OnLoad函数中有如下代码：\n\t\t\tJNIEnv *env;\n\t\t\tif (jvm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {\n\n\t\t\t    return -1;\n\t\t\t}\n\t\t这里调用了GetEnv函数获取JNIEnv结构体指针，其实JNIEnv结构体是指向一个函数表的，该函数表指向了对应的JNI函数，我们通过调用这些JNI函数实现JNI编程，在后面我们还会对其进行介绍。\n\n\t\t获取Java对象，完成动态注册\n\n\t\t\t上面介绍了如何获取JNIEnv结构体指针，得到这个结构体指针后我们就可以调用JNIEnv中的RegisterNatives函数完成动态注册native方法了。该方法如下：\n\n\t\t\tjint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods)\n\n\t\t\t第一个参数是Java层对应包含native方法的对象(这里就是AndroidJni对象)，通过调用JNIEnv对应的函数获取class对象(FindClass函数的参数为需要获取class对象的类描述符)：\n\n\t\t\tjclass clz = env->FindClass(\"com/github/songnick/jni/AndroidJni\");\n\n\t\t\t第二个参数是JNINativeMethod结构体指针，这里的JNINativeMethod结构体是描述Java层native方法的，它的定义如下：\n\n\t\t\ttypedef struct {\n\t\t\t    const char* name;//Java层native方法的名字\n\t\t\t    const char* signature;//Java层native方法的描述符\n\t\t\t    void*       fnPtr;//对应JNI函数的指针\n\t\t\t} JNINativeMethod;\n\n\t\t\tJNINativeMethod nativeMethod[] = {{\"dynamicLog\", \"()V\", (void*)nativeDynamicLog}};\n\n\t\t\t最后调用RegisterNative函数完成动态注册：\n\n\t\t\tenv->RegisterNatives(clz, nativeMethod, sizeof(nativeMethod)/sizeof(nativeMethod[0]));\n\n\n\tJNIEnv结构体\n\n\t\t上面提到JNIEnv这个结构体，它就老厉害了，指向一个函数表，该函数表指向一系列的JNI函数，我们通过调用这些JNI函数可以实现与Java层的交互，这里简单的看看几个定义的函数：\n\n\t\t..........\n\t\tjfieldID GetFieldID(jclass clazz, const char* name, const char* sig)\n\t\tjboolean GetBooleanField(jobject obj, jfieldID fieldID)\n\t\tjmethodID GetMethodID(jclass clazz, const char* name, const char* sig)\n\t\tCallVoidMethod(jobject obj, jmethodID methodID, ...)\n\t\tCallBooleanMethod(jobject obj, jmethodID methodID, ...)\n\t\t..........\n\n\n","slug":"面试题3","published":1,"date":"2018-02-27T10:29:44.179Z","updated":"2018-02-27T07:33:45.805Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5igux600078giebyqg1z83","content":"<p>1.Context<br>    Activity、Service、Application都是Context的子类<br>    Android系统的角度来理解：Context是一个场景，代表与操作系统的交互的一种过程。<br>    Application和Service、ContentProvider、BroadcastReceiver无法进行一下操作：<br>    1.show a Dialog<br>    2.start an Activity<br>    3.Layout Inflation</p>\n<pre><code>启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐\n\n在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用\n\nContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。\n\n\n凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。\n</code></pre><p>2.JNI<br>    那么怎么使用JNI呢，一般情况下我们首先是将写好的C/C++代码编译成对应平台的动态库(windows一般是dll文件，linux一般是so文件等)，这里我们是针对Android平台，所以只讨论so库。</p>\n<pre><code>1.Java的native方法怎么与C/C++中的函数链接起来?\n\n2.JNI定义了与Java对应的数据类型，用于JNI编程?\n\n3.描述符－用于描述类名或者数据类型，我们在C/C++层为了获取Java层的对象、变量以及描述Java的方法，需要用字符串来描述需要获取对象的类名、变量类型以及方法。\n\n\npublic class AndroidJni {\n\n    static{\n        System.loadLibrary(&quot;main&quot;);\n    }\n\n    public native void dynamicLog();\n\n    public native void staticLog();\n\n}\n\n这里我们定义了两个声明为native的方法，并声明了一块静态区域，在该静态区域类加载名为libmain.so的库，这里我们说是libmain.so库，但是加载的时候却只写了“main”，其实大家只要知道这是约定的就可以了。\n\n\n静态注册native方法\n    JNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog \n    JNIEXPORT和JNICALL两个关键字是两个宏定义,他主要的作用就是说明该函数为JNI函数,在Java虚拟机加载的时候会链接对应的native方法\n\n    Java_PkgName_ClassName_NativeMethodName(包名+类名)\n\n    两个固定的参数变量，分别是JNIEnv和jobject\n    JNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog (JNIEnv *env, jobject obj)\n\n    jobject就是当前与之链接的native方法隶属的类对象(类似于Java中的this)。这两个变量都是Java虚拟机生成并在调用时传递进来的。\n\n动态注册\n    JNI_OnLoad函数\n\n    JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {}\n    该函数返回的int表示当前使用的JNI的版本\n    该函数会有两个参数，其中*jvm为Java虚拟机实例，JavaVM结构体定义了以下函数：\n        DestroyJavaVM\n        AttachCurrentThread\n        DetachCurrentThread\n        GetEnv\n    这里我们使用了GetEnv函数获取JNIEnv变量，上面的JNI_OnLoad函数中有如下代码：\n        JNIEnv *env;\n        if (jvm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {\n\n            return -1;\n        }\n    这里调用了GetEnv函数获取JNIEnv结构体指针，其实JNIEnv结构体是指向一个函数表的，该函数表指向了对应的JNI函数，我们通过调用这些JNI函数实现JNI编程，在后面我们还会对其进行介绍。\n\n    获取Java对象，完成动态注册\n\n        上面介绍了如何获取JNIEnv结构体指针，得到这个结构体指针后我们就可以调用JNIEnv中的RegisterNatives函数完成动态注册native方法了。该方法如下：\n\n        jint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods)\n\n        第一个参数是Java层对应包含native方法的对象(这里就是AndroidJni对象)，通过调用JNIEnv对应的函数获取class对象(FindClass函数的参数为需要获取class对象的类描述符)：\n\n        jclass clz = env-&gt;FindClass(&quot;com/github/songnick/jni/AndroidJni&quot;);\n\n        第二个参数是JNINativeMethod结构体指针，这里的JNINativeMethod结构体是描述Java层native方法的，它的定义如下：\n\n        typedef struct {\n            const char* name;//Java层native方法的名字\n            const char* signature;//Java层native方法的描述符\n            void*       fnPtr;//对应JNI函数的指针\n        } JNINativeMethod;\n\n        JNINativeMethod nativeMethod[] = {{\"dynamicLog\", \"()V\", (void*)nativeDynamicLog}};\n\n        最后调用RegisterNative函数完成动态注册：\n\n        env-&gt;RegisterNatives(clz, nativeMethod, sizeof(nativeMethod)/sizeof(nativeMethod[0]));\n\n\nJNIEnv结构体\n\n    上面提到JNIEnv这个结构体，它就老厉害了，指向一个函数表，该函数表指向一系列的JNI函数，我们通过调用这些JNI函数可以实现与Java层的交互，这里简单的看看几个定义的函数：\n\n    ..........\n    jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)\n    jboolean GetBooleanField(jobject obj, jfieldID fieldID)\n    jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)\n    CallVoidMethod(jobject obj, jmethodID methodID, ...)\n    CallBooleanMethod(jobject obj, jmethodID methodID, ...)\n    ..........\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>1.Context<br>    Activity、Service、Application都是Context的子类<br>    Android系统的角度来理解：Context是一个场景，代表与操作系统的交互的一种过程。<br>    Application和Service、ContentProvider、BroadcastReceiver无法进行一下操作：<br>    1.show a Dialog<br>    2.start an Activity<br>    3.Layout Inflation</p>\n<pre><code>启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐\n\n在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用\n\nContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。\n\n\n凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。\n</code></pre><p>2.JNI<br>    那么怎么使用JNI呢，一般情况下我们首先是将写好的C/C++代码编译成对应平台的动态库(windows一般是dll文件，linux一般是so文件等)，这里我们是针对Android平台，所以只讨论so库。</p>\n<pre><code>1.Java的native方法怎么与C/C++中的函数链接起来?\n\n2.JNI定义了与Java对应的数据类型，用于JNI编程?\n\n3.描述符－用于描述类名或者数据类型，我们在C/C++层为了获取Java层的对象、变量以及描述Java的方法，需要用字符串来描述需要获取对象的类名、变量类型以及方法。\n\n\npublic class AndroidJni {\n\n    static{\n        System.loadLibrary(&quot;main&quot;);\n    }\n\n    public native void dynamicLog();\n\n    public native void staticLog();\n\n}\n\n这里我们定义了两个声明为native的方法，并声明了一块静态区域，在该静态区域类加载名为libmain.so的库，这里我们说是libmain.so库，但是加载的时候却只写了“main”，其实大家只要知道这是约定的就可以了。\n\n\n静态注册native方法\n    JNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog \n    JNIEXPORT和JNICALL两个关键字是两个宏定义,他主要的作用就是说明该函数为JNI函数,在Java虚拟机加载的时候会链接对应的native方法\n\n    Java_PkgName_ClassName_NativeMethodName(包名+类名)\n\n    两个固定的参数变量，分别是JNIEnv和jobject\n    JNIEXPORT void JNICALL Java_com_github_songnick_jni_AndroidJni_staticLog (JNIEnv *env, jobject obj)\n\n    jobject就是当前与之链接的native方法隶属的类对象(类似于Java中的this)。这两个变量都是Java虚拟机生成并在调用时传递进来的。\n\n动态注册\n    JNI_OnLoad函数\n\n    JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {}\n    该函数返回的int表示当前使用的JNI的版本\n    该函数会有两个参数，其中*jvm为Java虚拟机实例，JavaVM结构体定义了以下函数：\n        DestroyJavaVM\n        AttachCurrentThread\n        DetachCurrentThread\n        GetEnv\n    这里我们使用了GetEnv函数获取JNIEnv变量，上面的JNI_OnLoad函数中有如下代码：\n        JNIEnv *env;\n        if (jvm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {\n\n            return -1;\n        }\n    这里调用了GetEnv函数获取JNIEnv结构体指针，其实JNIEnv结构体是指向一个函数表的，该函数表指向了对应的JNI函数，我们通过调用这些JNI函数实现JNI编程，在后面我们还会对其进行介绍。\n\n    获取Java对象，完成动态注册\n\n        上面介绍了如何获取JNIEnv结构体指针，得到这个结构体指针后我们就可以调用JNIEnv中的RegisterNatives函数完成动态注册native方法了。该方法如下：\n\n        jint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods)\n\n        第一个参数是Java层对应包含native方法的对象(这里就是AndroidJni对象)，通过调用JNIEnv对应的函数获取class对象(FindClass函数的参数为需要获取class对象的类描述符)：\n\n        jclass clz = env-&gt;FindClass(&quot;com/github/songnick/jni/AndroidJni&quot;);\n\n        第二个参数是JNINativeMethod结构体指针，这里的JNINativeMethod结构体是描述Java层native方法的，它的定义如下：\n\n        typedef struct {\n            const char* name;//Java层native方法的名字\n            const char* signature;//Java层native方法的描述符\n            void*       fnPtr;//对应JNI函数的指针\n        } JNINativeMethod;\n\n        JNINativeMethod nativeMethod[] = {{\"dynamicLog\", \"()V\", (void*)nativeDynamicLog}};\n\n        最后调用RegisterNative函数完成动态注册：\n\n        env-&gt;RegisterNatives(clz, nativeMethod, sizeof(nativeMethod)/sizeof(nativeMethod[0]));\n\n\nJNIEnv结构体\n\n    上面提到JNIEnv这个结构体，它就老厉害了，指向一个函数表，该函数表指向一系列的JNI函数，我们通过调用这些JNI函数可以实现与Java层的交互，这里简单的看看几个定义的函数：\n\n    ..........\n    jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)\n    jboolean GetBooleanField(jobject obj, jfieldID fieldID)\n    jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)\n    CallVoidMethod(jobject obj, jmethodID methodID, ...)\n    CallBooleanMethod(jobject obj, jmethodID methodID, ...)\n    ..........\n</code></pre>"},{"title":"compileSdkVersion, minSdkVersion， targetSdkVersion的关系","date":"2016-06-01T15:47:44.000Z","_content":"\n\n![这里写图片描述](http://img.blog.csdn.net/20161130141617130)\n\n**选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion**\n-----------------------------------------------------------------------\n\n当你将一个App发布出去之后，也许马上Google又发布了一个新的Android版本。那这是否就意味着你发布的App会出现一些版本上的问题。\n\n当然这并不会困扰我们，因为Android是**向前兼容**的---向前兼容即旧版本能够适应新版本的应用---对Android而言就是在旧版上开发的应用当我们将手机的版本升级之后一样可以使用。这就是**compileSdkVersion**,  **minSdkVersion**,  **targetSdkVersion**这三者的由来，它们分别控制可用API的版本号，需要的API版本号和使用何种兼容模式。\n\n**compileSdkVersion**\n-----------------\n通过compileSdkVersion你可以告诉Gradle使用何种SDK版本来编译你的App。当你在代码中使用了一些新的API时，你就需要使用相应新的Android SDK。\n\n需要重点声明的是，**改变compileSdkVersion并不会改变运行时的行为，也就是说当在手机上跑的时候，使用的还是你手机上的SDK**，也就是你手机的Android版本号。当你改变compileSdkVersion时，会报出一些新的编译错误，但是你的compileSdkVersion并不会被包含在你的APK中：它仅仅用在编译期间。（虽然如此，但是你最好修复这些error---因为事出必定有因）\n\n在此**强烈建议你使用最新的SDK进行编译**。对现有代码进行最新SDK的编译检查时，你可以获得的好处是：避免一些在新版本中不赞成使用的API，并且及时使用最新的API。\n\n需要注意的是，当你使用 **Support Library**（兼容库）时，若要使用最新发布的兼容包，那么就必须使用最新版本的SDK进行编译。例：如果在gradle中添加compile 'com.android.support:design:23.0.1'那么相应的就需要将compileSdkVersion设置为23及以上。一般来讲，新版本的兼容库总是伴随新平台版本的发布，为新的API和特性提供兼容。\n\n**minSdkVersion**\n-------------\n如果说compileSdkVersion是设置你可用的最新API，**那么minSdkVersion就是为你的app设置最低门槛**，低于这个门槛就不要装了。Google Play Store通过这个标记来决定你的机子是否可以安装相应的app。\n\n该属性在开发过程中同样有着很重要的作用：默认情况下当你在开发的过程中，IDE可以通过这个标示来提醒你使用的API是否是在这个版本之后发布的，以此来帮助我们避免在运行时调用一些在手机的SDK中不存在的API。能够实现相同功能的是在代码中添加一些检查标示，来检查系统的版本来确定是否调用相应的API。\n\n需要注意的是：当我们使用也许第三方的库时如: **Support Libraries**或者 **Google Play services**这些类型的库，这些库有他们自己相应的minSdkVersion，我们需要确保我们自己app中使用的minSdkVersion必须要大于等于第三方库的minSdkVersion。**当然也存在一些个别情况**，当我们相应使用一个第三方库，该库的minSdkVersion要高于我们app的minSdkVersion，在我们不改变我们app的minSdkVersion前提下，任然想要使用这个第三方库，那么我们需要做的是使用**tools:overrideLibrary** 标示，但是我们必须要进行彻底的测试。以防止意外的发生。\n\n当我们要设定minSdkVersion时，可以到Google Play Store上查看最近7天的设备访问情况，这些就是你的潜在客户了。这其实最终是一个商业的决定，在于你是想要增加一定百分比的潜在客户量，还是使你的app有更好的用户体验和性能。\n\n当然如果有一个API在你的app中很关键，那么这个决定的过程就变的很简单了。需要知道的是，即使是0.7%的潜在用户量，那也是一个很大的数字了，因为在Google Play Store的设备数是以十亿为单位的。\n\n**targetSdkVersion**\n----------------\n\n这个版本号是这三者本文中最有趣的一个。**targetSdkVersion是Android提供向前兼容最主要的方式**，当targetSdkVersion不改变时，那么就不采取任何行为上的改变。\n\n大多数由于targetSdkVersion改变而造成的行为改变都被记录在 VERSION_CODES中，所有细节都被列在每个发布的版本上，同时在API Levels table中有相应的链接进行说明。\n\n例如，在Android6.0中讨论了如何针对过度到API 23的之后，如何对你的app进行运行时的权限分配模式。\n\n由于一些行为上的改变对用户来说是可视的（取消了menu按钮，运行时权限，等），**更新到最新的SDK对多有的app都是有利的**。这并不以为这你必须使用所有的新特性或者盲目的提高你的targetSdkVersion而将测试抛在一边。----**请注意，在你提高你的targetSdkVersion之前一定要进行相应的测试**，这是提高软件质量所必须的，同时，你的用户会感激你的（也许没有感激，但是至少责骂会少很多）。\n\n**Gradle and SDK versions**\n-----------------------\n\n基于以上内容让我们知道设置正确的 compileSdkVersion, minSdkVersion , targetSdkVersion是相当重要的。也许你会想，如果在Android Studio和Gradle中，这些值都相应的整合进了工具系统中，如在模块的buile.gradle文件中设置好了。如下面这样：\n\n```\nandroid {\n  compileSdkVersion 23\n  buildToolsVersion “23.0.1”\n\n  defaultConfig {\n    applicationId “com.example.checkyourtargetsdk\"\n    minSdkVersion 7\n    targetSdkVersion 23\n    versionCode 1\n    versionName “1.0”\n  }\n}\n```\n\n在外面的两个：compileSdkVersion 和buildToolsVersion 一个是编译时SDK的版本号，一个是编译时编译器的版本号，这个我在我的领一篇文章中有详细介绍[链接地址](http://blog.csdn.net/qqq2830/article/details/53405699)。\n\n在**defaultConfig**中的内容则是项目构建的基础设置。\n\n在这当中 compileSdkVersion是和编译时有关，而minSdkVersion， targetSdkVersion这两者最终会放假APK中。你可以在生成的AndroidManifest.xml文件中看到：\n\n```\n<uses-sdk android:targetSdkVersion=”23\" android:minSdkVersion=”7\" />\n```\n\n你会发现当你手动将这些设置进你的manifest中后，如果你使用Gradle进行build，那么它会忽略你的设置。\n\n**总的来说三者的关系**\n----\n\n```\nminSdkVersion <= targetSdkVersion <= compileSdkVersion\n```\n**理想化来说应该是这样：**\n\n```\nminSdkVersion (lowest possible) <= \n    targetSdkVersion == compileSdkVersion (latest SDK)\n```\n\n通过这样，你就可以获得最多的潜在用户数，同时使app性能更好，同时界面更酷炫。\n\n期待您的加入 [Google+ post](https://plus.google.com/+AndroidDevelopers/posts/4TRW8SztAHv?utm_campaign=adp_series_sdkversion_010616&utm_source=medium&utm_medium=blog) 和[ Android Development Patterns Collection](https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_sdkversion_010616&utm_source=medium&utm_medium=blog)","source":"_posts/compileSdkVersion, minSdkVersion， targetSdkVersion这三兄弟.md","raw":"\n---\ntitle: compileSdkVersion, minSdkVersion， targetSdkVersion的关系\ndate: 2016-06-01 23:47:44\ncategories: \"Android基础学习\"\ntags:\n     - Android\n---\n\n\n![这里写图片描述](http://img.blog.csdn.net/20161130141617130)\n\n**选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion**\n-----------------------------------------------------------------------\n\n当你将一个App发布出去之后，也许马上Google又发布了一个新的Android版本。那这是否就意味着你发布的App会出现一些版本上的问题。\n\n当然这并不会困扰我们，因为Android是**向前兼容**的---向前兼容即旧版本能够适应新版本的应用---对Android而言就是在旧版上开发的应用当我们将手机的版本升级之后一样可以使用。这就是**compileSdkVersion**,  **minSdkVersion**,  **targetSdkVersion**这三者的由来，它们分别控制可用API的版本号，需要的API版本号和使用何种兼容模式。\n\n**compileSdkVersion**\n-----------------\n通过compileSdkVersion你可以告诉Gradle使用何种SDK版本来编译你的App。当你在代码中使用了一些新的API时，你就需要使用相应新的Android SDK。\n\n需要重点声明的是，**改变compileSdkVersion并不会改变运行时的行为，也就是说当在手机上跑的时候，使用的还是你手机上的SDK**，也就是你手机的Android版本号。当你改变compileSdkVersion时，会报出一些新的编译错误，但是你的compileSdkVersion并不会被包含在你的APK中：它仅仅用在编译期间。（虽然如此，但是你最好修复这些error---因为事出必定有因）\n\n在此**强烈建议你使用最新的SDK进行编译**。对现有代码进行最新SDK的编译检查时，你可以获得的好处是：避免一些在新版本中不赞成使用的API，并且及时使用最新的API。\n\n需要注意的是，当你使用 **Support Library**（兼容库）时，若要使用最新发布的兼容包，那么就必须使用最新版本的SDK进行编译。例：如果在gradle中添加compile 'com.android.support:design:23.0.1'那么相应的就需要将compileSdkVersion设置为23及以上。一般来讲，新版本的兼容库总是伴随新平台版本的发布，为新的API和特性提供兼容。\n\n**minSdkVersion**\n-------------\n如果说compileSdkVersion是设置你可用的最新API，**那么minSdkVersion就是为你的app设置最低门槛**，低于这个门槛就不要装了。Google Play Store通过这个标记来决定你的机子是否可以安装相应的app。\n\n该属性在开发过程中同样有着很重要的作用：默认情况下当你在开发的过程中，IDE可以通过这个标示来提醒你使用的API是否是在这个版本之后发布的，以此来帮助我们避免在运行时调用一些在手机的SDK中不存在的API。能够实现相同功能的是在代码中添加一些检查标示，来检查系统的版本来确定是否调用相应的API。\n\n需要注意的是：当我们使用也许第三方的库时如: **Support Libraries**或者 **Google Play services**这些类型的库，这些库有他们自己相应的minSdkVersion，我们需要确保我们自己app中使用的minSdkVersion必须要大于等于第三方库的minSdkVersion。**当然也存在一些个别情况**，当我们相应使用一个第三方库，该库的minSdkVersion要高于我们app的minSdkVersion，在我们不改变我们app的minSdkVersion前提下，任然想要使用这个第三方库，那么我们需要做的是使用**tools:overrideLibrary** 标示，但是我们必须要进行彻底的测试。以防止意外的发生。\n\n当我们要设定minSdkVersion时，可以到Google Play Store上查看最近7天的设备访问情况，这些就是你的潜在客户了。这其实最终是一个商业的决定，在于你是想要增加一定百分比的潜在客户量，还是使你的app有更好的用户体验和性能。\n\n当然如果有一个API在你的app中很关键，那么这个决定的过程就变的很简单了。需要知道的是，即使是0.7%的潜在用户量，那也是一个很大的数字了，因为在Google Play Store的设备数是以十亿为单位的。\n\n**targetSdkVersion**\n----------------\n\n这个版本号是这三者本文中最有趣的一个。**targetSdkVersion是Android提供向前兼容最主要的方式**，当targetSdkVersion不改变时，那么就不采取任何行为上的改变。\n\n大多数由于targetSdkVersion改变而造成的行为改变都被记录在 VERSION_CODES中，所有细节都被列在每个发布的版本上，同时在API Levels table中有相应的链接进行说明。\n\n例如，在Android6.0中讨论了如何针对过度到API 23的之后，如何对你的app进行运行时的权限分配模式。\n\n由于一些行为上的改变对用户来说是可视的（取消了menu按钮，运行时权限，等），**更新到最新的SDK对多有的app都是有利的**。这并不以为这你必须使用所有的新特性或者盲目的提高你的targetSdkVersion而将测试抛在一边。----**请注意，在你提高你的targetSdkVersion之前一定要进行相应的测试**，这是提高软件质量所必须的，同时，你的用户会感激你的（也许没有感激，但是至少责骂会少很多）。\n\n**Gradle and SDK versions**\n-----------------------\n\n基于以上内容让我们知道设置正确的 compileSdkVersion, minSdkVersion , targetSdkVersion是相当重要的。也许你会想，如果在Android Studio和Gradle中，这些值都相应的整合进了工具系统中，如在模块的buile.gradle文件中设置好了。如下面这样：\n\n```\nandroid {\n  compileSdkVersion 23\n  buildToolsVersion “23.0.1”\n\n  defaultConfig {\n    applicationId “com.example.checkyourtargetsdk\"\n    minSdkVersion 7\n    targetSdkVersion 23\n    versionCode 1\n    versionName “1.0”\n  }\n}\n```\n\n在外面的两个：compileSdkVersion 和buildToolsVersion 一个是编译时SDK的版本号，一个是编译时编译器的版本号，这个我在我的领一篇文章中有详细介绍[链接地址](http://blog.csdn.net/qqq2830/article/details/53405699)。\n\n在**defaultConfig**中的内容则是项目构建的基础设置。\n\n在这当中 compileSdkVersion是和编译时有关，而minSdkVersion， targetSdkVersion这两者最终会放假APK中。你可以在生成的AndroidManifest.xml文件中看到：\n\n```\n<uses-sdk android:targetSdkVersion=”23\" android:minSdkVersion=”7\" />\n```\n\n你会发现当你手动将这些设置进你的manifest中后，如果你使用Gradle进行build，那么它会忽略你的设置。\n\n**总的来说三者的关系**\n----\n\n```\nminSdkVersion <= targetSdkVersion <= compileSdkVersion\n```\n**理想化来说应该是这样：**\n\n```\nminSdkVersion (lowest possible) <= \n    targetSdkVersion == compileSdkVersion (latest SDK)\n```\n\n通过这样，你就可以获得最多的潜在用户数，同时使app性能更好，同时界面更酷炫。\n\n期待您的加入 [Google+ post](https://plus.google.com/+AndroidDevelopers/posts/4TRW8SztAHv?utm_campaign=adp_series_sdkversion_010616&utm_source=medium&utm_medium=blog) 和[ Android Development Patterns Collection](https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_sdkversion_010616&utm_source=medium&utm_medium=blog)","slug":"compileSdkVersion, minSdkVersion， targetSdkVersion这三兄弟","published":1,"updated":"2018-02-06T03:39:20.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5igux700088gieb58p22qv","content":"<p><img src=\"http://img.blog.csdn.net/20161130141617130\" alt=\"这里写图片描述\"></p>\n<h2 id=\"选择你自己的-compileSdkVersion-minSdkVersion-and-targetSdkVersion\"><a href=\"#选择你自己的-compileSdkVersion-minSdkVersion-and-targetSdkVersion\" class=\"headerlink\" title=\"选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion\"></a><strong>选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion</strong></h2><p>当你将一个App发布出去之后，也许马上Google又发布了一个新的Android版本。那这是否就意味着你发布的App会出现一些版本上的问题。</p>\n<p>当然这并不会困扰我们，因为Android是<strong>向前兼容</strong>的—向前兼容即旧版本能够适应新版本的应用—对Android而言就是在旧版上开发的应用当我们将手机的版本升级之后一样可以使用。这就是<strong>compileSdkVersion</strong>,  <strong>minSdkVersion</strong>,  <strong>targetSdkVersion</strong>这三者的由来，它们分别控制可用API的版本号，需要的API版本号和使用何种兼容模式。</p>\n<h2 id=\"compileSdkVersion\"><a href=\"#compileSdkVersion\" class=\"headerlink\" title=\"compileSdkVersion\"></a><strong>compileSdkVersion</strong></h2><p>通过compileSdkVersion你可以告诉Gradle使用何种SDK版本来编译你的App。当你在代码中使用了一些新的API时，你就需要使用相应新的Android SDK。</p>\n<p>需要重点声明的是，<strong>改变compileSdkVersion并不会改变运行时的行为，也就是说当在手机上跑的时候，使用的还是你手机上的SDK</strong>，也就是你手机的Android版本号。当你改变compileSdkVersion时，会报出一些新的编译错误，但是你的compileSdkVersion并不会被包含在你的APK中：它仅仅用在编译期间。（虽然如此，但是你最好修复这些error—因为事出必定有因）</p>\n<p>在此<strong>强烈建议你使用最新的SDK进行编译</strong>。对现有代码进行最新SDK的编译检查时，你可以获得的好处是：避免一些在新版本中不赞成使用的API，并且及时使用最新的API。</p>\n<p>需要注意的是，当你使用 <strong>Support Library</strong>（兼容库）时，若要使用最新发布的兼容包，那么就必须使用最新版本的SDK进行编译。例：如果在gradle中添加compile ‘com.android.support:design:23.0.1’那么相应的就需要将compileSdkVersion设置为23及以上。一般来讲，新版本的兼容库总是伴随新平台版本的发布，为新的API和特性提供兼容。</p>\n<h2 id=\"minSdkVersion\"><a href=\"#minSdkVersion\" class=\"headerlink\" title=\"minSdkVersion\"></a><strong>minSdkVersion</strong></h2><p>如果说compileSdkVersion是设置你可用的最新API，<strong>那么minSdkVersion就是为你的app设置最低门槛</strong>，低于这个门槛就不要装了。Google Play Store通过这个标记来决定你的机子是否可以安装相应的app。</p>\n<p>该属性在开发过程中同样有着很重要的作用：默认情况下当你在开发的过程中，IDE可以通过这个标示来提醒你使用的API是否是在这个版本之后发布的，以此来帮助我们避免在运行时调用一些在手机的SDK中不存在的API。能够实现相同功能的是在代码中添加一些检查标示，来检查系统的版本来确定是否调用相应的API。</p>\n<p>需要注意的是：当我们使用也许第三方的库时如: <strong>Support Libraries</strong>或者 <strong>Google Play services</strong>这些类型的库，这些库有他们自己相应的minSdkVersion，我们需要确保我们自己app中使用的minSdkVersion必须要大于等于第三方库的minSdkVersion。<strong>当然也存在一些个别情况</strong>，当我们相应使用一个第三方库，该库的minSdkVersion要高于我们app的minSdkVersion，在我们不改变我们app的minSdkVersion前提下，任然想要使用这个第三方库，那么我们需要做的是使用<strong>tools:overrideLibrary</strong> 标示，但是我们必须要进行彻底的测试。以防止意外的发生。</p>\n<p>当我们要设定minSdkVersion时，可以到Google Play Store上查看最近7天的设备访问情况，这些就是你的潜在客户了。这其实最终是一个商业的决定，在于你是想要增加一定百分比的潜在客户量，还是使你的app有更好的用户体验和性能。</p>\n<p>当然如果有一个API在你的app中很关键，那么这个决定的过程就变的很简单了。需要知道的是，即使是0.7%的潜在用户量，那也是一个很大的数字了，因为在Google Play Store的设备数是以十亿为单位的。</p>\n<h2 id=\"targetSdkVersion\"><a href=\"#targetSdkVersion\" class=\"headerlink\" title=\"targetSdkVersion\"></a><strong>targetSdkVersion</strong></h2><p>这个版本号是这三者本文中最有趣的一个。<strong>targetSdkVersion是Android提供向前兼容最主要的方式</strong>，当targetSdkVersion不改变时，那么就不采取任何行为上的改变。</p>\n<p>大多数由于targetSdkVersion改变而造成的行为改变都被记录在 VERSION_CODES中，所有细节都被列在每个发布的版本上，同时在API Levels table中有相应的链接进行说明。</p>\n<p>例如，在Android6.0中讨论了如何针对过度到API 23的之后，如何对你的app进行运行时的权限分配模式。</p>\n<p>由于一些行为上的改变对用户来说是可视的（取消了menu按钮，运行时权限，等），<strong>更新到最新的SDK对多有的app都是有利的</strong>。这并不以为这你必须使用所有的新特性或者盲目的提高你的targetSdkVersion而将测试抛在一边。—-<strong>请注意，在你提高你的targetSdkVersion之前一定要进行相应的测试</strong>，这是提高软件质量所必须的，同时，你的用户会感激你的（也许没有感激，但是至少责骂会少很多）。</p>\n<h2 id=\"Gradle-and-SDK-versions\"><a href=\"#Gradle-and-SDK-versions\" class=\"headerlink\" title=\"Gradle and SDK versions\"></a><strong>Gradle and SDK versions</strong></h2><p>基于以上内容让我们知道设置正确的 compileSdkVersion, minSdkVersion , targetSdkVersion是相当重要的。也许你会想，如果在Android Studio和Gradle中，这些值都相应的整合进了工具系统中，如在模块的buile.gradle文件中设置好了。如下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  compileSdkVersion 23</span><br><span class=\"line\">  buildToolsVersion “23.0.1”</span><br><span class=\"line\"></span><br><span class=\"line\">  defaultConfig &#123;</span><br><span class=\"line\">    applicationId “com.example.checkyourtargetsdk&quot;</span><br><span class=\"line\">    minSdkVersion 7</span><br><span class=\"line\">    targetSdkVersion 23</span><br><span class=\"line\">    versionCode 1</span><br><span class=\"line\">    versionName “1.0”</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在外面的两个：compileSdkVersion 和buildToolsVersion 一个是编译时SDK的版本号，一个是编译时编译器的版本号，这个我在我的领一篇文章中有详细介绍<a href=\"http://blog.csdn.net/qqq2830/article/details/53405699\" target=\"_blank\" rel=\"noopener\">链接地址</a>。</p>\n<p>在<strong>defaultConfig</strong>中的内容则是项目构建的基础设置。</p>\n<p>在这当中 compileSdkVersion是和编译时有关，而minSdkVersion， targetSdkVersion这两者最终会放假APK中。你可以在生成的AndroidManifest.xml文件中看到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-sdk android:targetSdkVersion=”23&quot; android:minSdkVersion=”7&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>你会发现当你手动将这些设置进你的manifest中后，如果你使用Gradle进行build，那么它会忽略你的设置。</p>\n<h2 id=\"总的来说三者的关系\"><a href=\"#总的来说三者的关系\" class=\"headerlink\" title=\"总的来说三者的关系\"></a><strong>总的来说三者的关系</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</span><br></pre></td></tr></table></figure>\n<p><strong>理想化来说应该是这样：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minSdkVersion (lowest possible) &lt;= </span><br><span class=\"line\">    targetSdkVersion == compileSdkVersion (latest SDK)</span><br></pre></td></tr></table></figure>\n<p>通过这样，你就可以获得最多的潜在用户数，同时使app性能更好，同时界面更酷炫。</p>\n<p>期待您的加入 <a href=\"https://plus.google.com/+AndroidDevelopers/posts/4TRW8SztAHv?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog\" target=\"_blank\" rel=\"noopener\">Google+ post</a> 和<a href=\"https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog\" target=\"_blank\" rel=\"noopener\"> Android Development Patterns Collection</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://img.blog.csdn.net/20161130141617130\" alt=\"这里写图片描述\"></p>\n<h2 id=\"选择你自己的-compileSdkVersion-minSdkVersion-and-targetSdkVersion\"><a href=\"#选择你自己的-compileSdkVersion-minSdkVersion-and-targetSdkVersion\" class=\"headerlink\" title=\"选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion\"></a><strong>选择你自己的 compileSdkVersion, minSdkVersion, and targetSdkVersion</strong></h2><p>当你将一个App发布出去之后，也许马上Google又发布了一个新的Android版本。那这是否就意味着你发布的App会出现一些版本上的问题。</p>\n<p>当然这并不会困扰我们，因为Android是<strong>向前兼容</strong>的—向前兼容即旧版本能够适应新版本的应用—对Android而言就是在旧版上开发的应用当我们将手机的版本升级之后一样可以使用。这就是<strong>compileSdkVersion</strong>,  <strong>minSdkVersion</strong>,  <strong>targetSdkVersion</strong>这三者的由来，它们分别控制可用API的版本号，需要的API版本号和使用何种兼容模式。</p>\n<h2 id=\"compileSdkVersion\"><a href=\"#compileSdkVersion\" class=\"headerlink\" title=\"compileSdkVersion\"></a><strong>compileSdkVersion</strong></h2><p>通过compileSdkVersion你可以告诉Gradle使用何种SDK版本来编译你的App。当你在代码中使用了一些新的API时，你就需要使用相应新的Android SDK。</p>\n<p>需要重点声明的是，<strong>改变compileSdkVersion并不会改变运行时的行为，也就是说当在手机上跑的时候，使用的还是你手机上的SDK</strong>，也就是你手机的Android版本号。当你改变compileSdkVersion时，会报出一些新的编译错误，但是你的compileSdkVersion并不会被包含在你的APK中：它仅仅用在编译期间。（虽然如此，但是你最好修复这些error—因为事出必定有因）</p>\n<p>在此<strong>强烈建议你使用最新的SDK进行编译</strong>。对现有代码进行最新SDK的编译检查时，你可以获得的好处是：避免一些在新版本中不赞成使用的API，并且及时使用最新的API。</p>\n<p>需要注意的是，当你使用 <strong>Support Library</strong>（兼容库）时，若要使用最新发布的兼容包，那么就必须使用最新版本的SDK进行编译。例：如果在gradle中添加compile ‘com.android.support:design:23.0.1’那么相应的就需要将compileSdkVersion设置为23及以上。一般来讲，新版本的兼容库总是伴随新平台版本的发布，为新的API和特性提供兼容。</p>\n<h2 id=\"minSdkVersion\"><a href=\"#minSdkVersion\" class=\"headerlink\" title=\"minSdkVersion\"></a><strong>minSdkVersion</strong></h2><p>如果说compileSdkVersion是设置你可用的最新API，<strong>那么minSdkVersion就是为你的app设置最低门槛</strong>，低于这个门槛就不要装了。Google Play Store通过这个标记来决定你的机子是否可以安装相应的app。</p>\n<p>该属性在开发过程中同样有着很重要的作用：默认情况下当你在开发的过程中，IDE可以通过这个标示来提醒你使用的API是否是在这个版本之后发布的，以此来帮助我们避免在运行时调用一些在手机的SDK中不存在的API。能够实现相同功能的是在代码中添加一些检查标示，来检查系统的版本来确定是否调用相应的API。</p>\n<p>需要注意的是：当我们使用也许第三方的库时如: <strong>Support Libraries</strong>或者 <strong>Google Play services</strong>这些类型的库，这些库有他们自己相应的minSdkVersion，我们需要确保我们自己app中使用的minSdkVersion必须要大于等于第三方库的minSdkVersion。<strong>当然也存在一些个别情况</strong>，当我们相应使用一个第三方库，该库的minSdkVersion要高于我们app的minSdkVersion，在我们不改变我们app的minSdkVersion前提下，任然想要使用这个第三方库，那么我们需要做的是使用<strong>tools:overrideLibrary</strong> 标示，但是我们必须要进行彻底的测试。以防止意外的发生。</p>\n<p>当我们要设定minSdkVersion时，可以到Google Play Store上查看最近7天的设备访问情况，这些就是你的潜在客户了。这其实最终是一个商业的决定，在于你是想要增加一定百分比的潜在客户量，还是使你的app有更好的用户体验和性能。</p>\n<p>当然如果有一个API在你的app中很关键，那么这个决定的过程就变的很简单了。需要知道的是，即使是0.7%的潜在用户量，那也是一个很大的数字了，因为在Google Play Store的设备数是以十亿为单位的。</p>\n<h2 id=\"targetSdkVersion\"><a href=\"#targetSdkVersion\" class=\"headerlink\" title=\"targetSdkVersion\"></a><strong>targetSdkVersion</strong></h2><p>这个版本号是这三者本文中最有趣的一个。<strong>targetSdkVersion是Android提供向前兼容最主要的方式</strong>，当targetSdkVersion不改变时，那么就不采取任何行为上的改变。</p>\n<p>大多数由于targetSdkVersion改变而造成的行为改变都被记录在 VERSION_CODES中，所有细节都被列在每个发布的版本上，同时在API Levels table中有相应的链接进行说明。</p>\n<p>例如，在Android6.0中讨论了如何针对过度到API 23的之后，如何对你的app进行运行时的权限分配模式。</p>\n<p>由于一些行为上的改变对用户来说是可视的（取消了menu按钮，运行时权限，等），<strong>更新到最新的SDK对多有的app都是有利的</strong>。这并不以为这你必须使用所有的新特性或者盲目的提高你的targetSdkVersion而将测试抛在一边。—-<strong>请注意，在你提高你的targetSdkVersion之前一定要进行相应的测试</strong>，这是提高软件质量所必须的，同时，你的用户会感激你的（也许没有感激，但是至少责骂会少很多）。</p>\n<h2 id=\"Gradle-and-SDK-versions\"><a href=\"#Gradle-and-SDK-versions\" class=\"headerlink\" title=\"Gradle and SDK versions\"></a><strong>Gradle and SDK versions</strong></h2><p>基于以上内容让我们知道设置正确的 compileSdkVersion, minSdkVersion , targetSdkVersion是相当重要的。也许你会想，如果在Android Studio和Gradle中，这些值都相应的整合进了工具系统中，如在模块的buile.gradle文件中设置好了。如下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">  compileSdkVersion 23</span><br><span class=\"line\">  buildToolsVersion “23.0.1”</span><br><span class=\"line\"></span><br><span class=\"line\">  defaultConfig &#123;</span><br><span class=\"line\">    applicationId “com.example.checkyourtargetsdk&quot;</span><br><span class=\"line\">    minSdkVersion 7</span><br><span class=\"line\">    targetSdkVersion 23</span><br><span class=\"line\">    versionCode 1</span><br><span class=\"line\">    versionName “1.0”</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在外面的两个：compileSdkVersion 和buildToolsVersion 一个是编译时SDK的版本号，一个是编译时编译器的版本号，这个我在我的领一篇文章中有详细介绍<a href=\"http://blog.csdn.net/qqq2830/article/details/53405699\" target=\"_blank\" rel=\"noopener\">链接地址</a>。</p>\n<p>在<strong>defaultConfig</strong>中的内容则是项目构建的基础设置。</p>\n<p>在这当中 compileSdkVersion是和编译时有关，而minSdkVersion， targetSdkVersion这两者最终会放假APK中。你可以在生成的AndroidManifest.xml文件中看到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-sdk android:targetSdkVersion=”23&quot; android:minSdkVersion=”7&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>你会发现当你手动将这些设置进你的manifest中后，如果你使用Gradle进行build，那么它会忽略你的设置。</p>\n<h2 id=\"总的来说三者的关系\"><a href=\"#总的来说三者的关系\" class=\"headerlink\" title=\"总的来说三者的关系\"></a><strong>总的来说三者的关系</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</span><br></pre></td></tr></table></figure>\n<p><strong>理想化来说应该是这样：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minSdkVersion (lowest possible) &lt;= </span><br><span class=\"line\">    targetSdkVersion == compileSdkVersion (latest SDK)</span><br></pre></td></tr></table></figure>\n<p>通过这样，你就可以获得最多的潜在用户数，同时使app性能更好，同时界面更酷炫。</p>\n<p>期待您的加入 <a href=\"https://plus.google.com/+AndroidDevelopers/posts/4TRW8SztAHv?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog\" target=\"_blank\" rel=\"noopener\">Google+ post</a> 和<a href=\"https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog\" target=\"_blank\" rel=\"noopener\"> Android Development Patterns Collection</a></p>\n"},{"title":"python爬虫scrapy的使用","date":"2018-02-06T09:13:44.000Z","_content":"\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/helo005.jpg)\n\n### 简介\n**本文将记录一次使用scrapy进行网页数据爬取的经历。**\n\n### 环境与安装\n**环境**\n\npython -- 3.6.1（区别python2和python3就行了，两者的语法在有些地方有区别）\nscrapy -- 1.5.0 （这个是根据你的python版本来选择的）\ntwisted\nwheel\npywin32\n\n\n**安装python**\n这里就不再赘述了，无非就是到python的官方网站下载相应安装包安装。如果要看的话，可以看blog里的另外一篇文章，也就是《python爬妹子》这一篇，或者可以看这个网址[python安装](https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000)\n\n**安装scrapy**\n一般使用windows电脑安装时会出现安装失败的情况，故而我们需要到[这个网站](https://pypi.python.org/pypi/Scrapy/1.5.0)下载相应的版本，来进行安装在安装之前我们还需要先安装wheel只需要在cmd中敲入：\n\n    pip install wheel\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153010.png)\n\n而后我们到https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153247.png)\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153547.png)\n经过上面两部我们就将scrapy安装到了本地，但是有没有发现还是无法运行，因为还有**pywin32 和twisted没有安装**故而我们继续到https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装\n![pywin32](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153939.png)\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207154852.png)\n同样使用命令行进行安装\n\n    pip install pywin32-222-cp36-cp36m-win_amd64.whl\n    pip install Twisted-17.9.0-cp27-cp27m-win_amd64.whl\n\n\n安装好这些之后我们就可以来看下scrapy了\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207155127.png)\n\n### scrapy初涉\n之前没有接触过的小伙伴可以先看下这个网站的内容https://doc.scrapy.org/en/latest/intro/tutorial.html\n\n我们先通过下面命令行创建一个scrapy项目\n\n    scrapy startproject heloScrapy\n\n相应的文件结构如下图所示\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207161524.png)\n\n而后我们在spiders文件夹下创建一个demo.py文件，之后的主要代码都将在该文件内完成。\n引入scrapy以及相应的request，并命名为demo\n\n    import scrapy\n\tfrom tutorial.items import TutorialItem\n\tfrom scrapy.http import Request\n\t\n\tclass DmozSpider(scrapy.Spider):\n\t    name = \"demo\"\n\t    allowed_domains = [\"blog.csdn.net\", \"baidu.com\"]\n\t    start_urls = [\n        \"http://blog.csdn.net/u013687632/article/details/57075514\"\n\t    ]\n\n此处在start_urls中设置了相应的初始网址http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains 的设置使我们只爬取这个域名内的网页。\n\n在设置好以上内容之后，scrapy会将start_urls 网页的内容以response的形式传递给parse函数，下面我们就将对parse函数进行定义\n\n        def parse(self, response):\n\t        filename = response.url.split(\"/\")[-2]\n\t        with open(filename, 'wb') as f:\n\t            f.write(response.body)\n\t        for sel in response.xpath('//ul/li'):\n\t            item = TutorialItem()\n\t            item['title'] = sel.xpath('a/text()').extract()\n\t            item['link'] = sel.xpath('a/@href').extract()\n\t            item['desc'] = sel.xpath('text()').extract()\n\t            yield item\n\n\t            if sel.xpath('a/@href').extract() == '':\n\t                print('empty')\n\t            else:\n\t                if len(sel.xpath('a/@href').extract()) > 0:\n\t                    self.num = self.num + 1\n\n\t                    print('helo%s' % (self.num))\n\t                    yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)\n\n从以上内容可以看出我们的是对网页内人title、link、desc进行了抽取，同时根据link中的内容来进行接下去的网页爬取，其中需要注意的方法有一下几个：\n\n        with open(filename, 'wb') as f:\n            f.write(response.body)\n\nwith as的语法是对于有_enter_()和_exit_()方法的对象使用的，这样可以减少我们代码的书写，不让像上面的内容我们就要写出如下的形式：\n\n    file = open(\"/tmp/foo.txt\")\n\ttry:\n\t    data = file.read()\n\tfinally:\n\t    file.close()\n\n然后就是TutorialItem这个类了，该类我们定义在items.py中\n\n    import scrapy\n    \n\tclass TutorialItem(scrapy.Item):\n\t    # define the fields for your item here like:\n\t    # name = scrapy.Field()\n\t    title = scrapy.Field()\n\t    link = scrapy.Field()\n\t    desc = scrapy.Field()\n\t    pass\n\n至于sel.xpath('a/text()')就是用来过滤出我们需要的xml对象了，这个方法是lxml包中的，这个包我们在上一篇文章中已经安装过滤，也就是pip instll lxml，而该方法中的表达式该如何写，这个就要靠自己了，人总是要靠自己的。当然我们也可以看下这篇blog的内容https://www.cnblogs.com/lei0213/p/7506130.html\n\n最后你是不是对yield这个语法很困惑，这个就和生成器相关了，详细内容可以看这个blog http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return, 不同之处在于，yield返回的是一个生成器。\n\n\n最后的最后就是下面这段代码了\n\n     yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)\n\n它发起了对新的url的请求，并将返回的内容传递给parse进行处理，这就实现了新url的爬取效果。\n\n最后我们可以通过cmd输入一些命令来运行程序\n\n    scrapy crawl demo\n\n\n运行结果如下\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207164936.png)\n\n\n### 总结\n使用scrapy能够为我们提供很大的便利，如待爬取队里的建立，以及url去重等都不需要我们去做了，当然最棒的是它有一个扩展包scrapy-redis，通过使用这个包我们可以实现分布式爬取，到时候我们的爬取速度就能够有指数级的提升了（在有多台硬件设备的情况下），而后通过这大量的数据我们就可以进行一些如数据挖掘、机器学习的工作了，是不是很心动。\n","source":"_posts/python爬虫scrapy的使用.md","raw":"---\ntitle: python爬虫scrapy的使用\ndate: 2018-02-06 17:13:44\ncategories: \"python\"\ntags:\n     - python\n     - 爬虫\n     - 技术\n---\n\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/helo005.jpg)\n\n### 简介\n**本文将记录一次使用scrapy进行网页数据爬取的经历。**\n\n### 环境与安装\n**环境**\n\npython -- 3.6.1（区别python2和python3就行了，两者的语法在有些地方有区别）\nscrapy -- 1.5.0 （这个是根据你的python版本来选择的）\ntwisted\nwheel\npywin32\n\n\n**安装python**\n这里就不再赘述了，无非就是到python的官方网站下载相应安装包安装。如果要看的话，可以看blog里的另外一篇文章，也就是《python爬妹子》这一篇，或者可以看这个网址[python安装](https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000)\n\n**安装scrapy**\n一般使用windows电脑安装时会出现安装失败的情况，故而我们需要到[这个网站](https://pypi.python.org/pypi/Scrapy/1.5.0)下载相应的版本，来进行安装在安装之前我们还需要先安装wheel只需要在cmd中敲入：\n\n    pip install wheel\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153010.png)\n\n而后我们到https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153247.png)\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153547.png)\n经过上面两部我们就将scrapy安装到了本地，但是有没有发现还是无法运行，因为还有**pywin32 和twisted没有安装**故而我们继续到https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装\n![pywin32](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153939.png)\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207154852.png)\n同样使用命令行进行安装\n\n    pip install pywin32-222-cp36-cp36m-win_amd64.whl\n    pip install Twisted-17.9.0-cp27-cp27m-win_amd64.whl\n\n\n安装好这些之后我们就可以来看下scrapy了\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207155127.png)\n\n### scrapy初涉\n之前没有接触过的小伙伴可以先看下这个网站的内容https://doc.scrapy.org/en/latest/intro/tutorial.html\n\n我们先通过下面命令行创建一个scrapy项目\n\n    scrapy startproject heloScrapy\n\n相应的文件结构如下图所示\n\n![|center](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207161524.png)\n\n而后我们在spiders文件夹下创建一个demo.py文件，之后的主要代码都将在该文件内完成。\n引入scrapy以及相应的request，并命名为demo\n\n    import scrapy\n\tfrom tutorial.items import TutorialItem\n\tfrom scrapy.http import Request\n\t\n\tclass DmozSpider(scrapy.Spider):\n\t    name = \"demo\"\n\t    allowed_domains = [\"blog.csdn.net\", \"baidu.com\"]\n\t    start_urls = [\n        \"http://blog.csdn.net/u013687632/article/details/57075514\"\n\t    ]\n\n此处在start_urls中设置了相应的初始网址http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains 的设置使我们只爬取这个域名内的网页。\n\n在设置好以上内容之后，scrapy会将start_urls 网页的内容以response的形式传递给parse函数，下面我们就将对parse函数进行定义\n\n        def parse(self, response):\n\t        filename = response.url.split(\"/\")[-2]\n\t        with open(filename, 'wb') as f:\n\t            f.write(response.body)\n\t        for sel in response.xpath('//ul/li'):\n\t            item = TutorialItem()\n\t            item['title'] = sel.xpath('a/text()').extract()\n\t            item['link'] = sel.xpath('a/@href').extract()\n\t            item['desc'] = sel.xpath('text()').extract()\n\t            yield item\n\n\t            if sel.xpath('a/@href').extract() == '':\n\t                print('empty')\n\t            else:\n\t                if len(sel.xpath('a/@href').extract()) > 0:\n\t                    self.num = self.num + 1\n\n\t                    print('helo%s' % (self.num))\n\t                    yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)\n\n从以上内容可以看出我们的是对网页内人title、link、desc进行了抽取，同时根据link中的内容来进行接下去的网页爬取，其中需要注意的方法有一下几个：\n\n        with open(filename, 'wb') as f:\n            f.write(response.body)\n\nwith as的语法是对于有_enter_()和_exit_()方法的对象使用的，这样可以减少我们代码的书写，不让像上面的内容我们就要写出如下的形式：\n\n    file = open(\"/tmp/foo.txt\")\n\ttry:\n\t    data = file.read()\n\tfinally:\n\t    file.close()\n\n然后就是TutorialItem这个类了，该类我们定义在items.py中\n\n    import scrapy\n    \n\tclass TutorialItem(scrapy.Item):\n\t    # define the fields for your item here like:\n\t    # name = scrapy.Field()\n\t    title = scrapy.Field()\n\t    link = scrapy.Field()\n\t    desc = scrapy.Field()\n\t    pass\n\n至于sel.xpath('a/text()')就是用来过滤出我们需要的xml对象了，这个方法是lxml包中的，这个包我们在上一篇文章中已经安装过滤，也就是pip instll lxml，而该方法中的表达式该如何写，这个就要靠自己了，人总是要靠自己的。当然我们也可以看下这篇blog的内容https://www.cnblogs.com/lei0213/p/7506130.html\n\n最后你是不是对yield这个语法很困惑，这个就和生成器相关了，详细内容可以看这个blog http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return, 不同之处在于，yield返回的是一个生成器。\n\n\n最后的最后就是下面这段代码了\n\n     yield Request(response.urljoin(sel.xpath('a/@href').extract()[0]), callback=self.parse)\n\n它发起了对新的url的请求，并将返回的内容传递给parse进行处理，这就实现了新url的爬取效果。\n\n最后我们可以通过cmd输入一些命令来运行程序\n\n    scrapy crawl demo\n\n\n运行结果如下\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207164936.png)\n\n\n### 总结\n使用scrapy能够为我们提供很大的便利，如待爬取队里的建立，以及url去重等都不需要我们去做了，当然最棒的是它有一个扩展包scrapy-redis，通过使用这个包我们可以实现分布式爬取，到时候我们的爬取速度就能够有指数级的提升了（在有多台硬件设备的情况下），而后通过这大量的数据我们就可以进行一些如数据挖掘、机器学习的工作了，是不是很心动。\n","slug":"python爬虫scrapy的使用","published":1,"updated":"2018-02-07T08:57:24.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5iguxa000b8gieovnvej7b","content":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/helo005.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><strong>本文将记录一次使用scrapy进行网页数据爬取的经历。</strong></p>\n<h3 id=\"环境与安装\"><a href=\"#环境与安装\" class=\"headerlink\" title=\"环境与安装\"></a>环境与安装</h3><p><strong>环境</strong></p>\n<p>python – 3.6.1（区别python2和python3就行了，两者的语法在有些地方有区别）<br>scrapy – 1.5.0 （这个是根据你的python版本来选择的）<br>twisted<br>wheel<br>pywin32</p>\n<p><strong>安装python</strong><br>这里就不再赘述了，无非就是到python的官方网站下载相应安装包安装。如果要看的话，可以看blog里的另外一篇文章，也就是《python爬妹子》这一篇，或者可以看这个网址<a href=\"https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000\" target=\"_blank\" rel=\"noopener\">python安装</a></p>\n<p><strong>安装scrapy</strong><br>一般使用windows电脑安装时会出现安装失败的情况，故而我们需要到<a href=\"https://pypi.python.org/pypi/Scrapy/1.5.0\" target=\"_blank\" rel=\"noopener\">这个网站</a>下载相应的版本，来进行安装在安装之前我们还需要先安装wheel只需要在cmd中敲入：</p>\n<pre><code>pip install wheel\n</code></pre><p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153010.png\" alt=\"|center\"></p>\n<p>而后我们到<a href=\"https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件</a><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153247.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153547.png\" alt=\"|center\"><br>经过上面两部我们就将scrapy安装到了本地，但是有没有发现还是无法运行，因为还有<strong>pywin32 和twisted没有安装</strong>故而我们继续到<a href=\"https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装</a><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153939.png\" alt=\"pywin32\"><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207154852.png\" alt=\"|center\"><br>同样使用命令行进行安装</p>\n<pre><code>pip install pywin32-222-cp36-cp36m-win_amd64.whl\npip install Twisted-17.9.0-cp27-cp27m-win_amd64.whl\n</code></pre><p>安装好这些之后我们就可以来看下scrapy了<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207155127.png\" alt=\"|center\"></p>\n<h3 id=\"scrapy初涉\"><a href=\"#scrapy初涉\" class=\"headerlink\" title=\"scrapy初涉\"></a>scrapy初涉</h3><p>之前没有接触过的小伙伴可以先看下这个网站的内容<a href=\"https://doc.scrapy.org/en/latest/intro/tutorial.html\" target=\"_blank\" rel=\"noopener\">https://doc.scrapy.org/en/latest/intro/tutorial.html</a></p>\n<p>我们先通过下面命令行创建一个scrapy项目</p>\n<pre><code>scrapy startproject heloScrapy\n</code></pre><p>相应的文件结构如下图所示</p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207161524.png\" alt=\"|center\"></p>\n<p>而后我们在spiders文件夹下创建一个demo.py文件，之后的主要代码都将在该文件内完成。<br>引入scrapy以及相应的request，并命名为demo</p>\n<pre><code>import scrapy\nfrom tutorial.items import TutorialItem\nfrom scrapy.http import Request\n\nclass DmozSpider(scrapy.Spider):\n    name = &quot;demo&quot;\n    allowed_domains = [&quot;blog.csdn.net&quot;, &quot;baidu.com&quot;]\n    start_urls = [\n    &quot;http://blog.csdn.net/u013687632/article/details/57075514&quot;\n    ]\n</code></pre><p>此处在start_urls中设置了相应的初始网址<a href=\"http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains</a> 的设置使我们只爬取这个域名内的网页。</p>\n<p>在设置好以上内容之后，scrapy会将start_urls 网页的内容以response的形式传递给parse函数，下面我们就将对parse函数进行定义</p>\n<pre><code>def parse(self, response):\n    filename = response.url.split(&quot;/&quot;)[-2]\n    with open(filename, &apos;wb&apos;) as f:\n        f.write(response.body)\n    for sel in response.xpath(&apos;//ul/li&apos;):\n        item = TutorialItem()\n        item[&apos;title&apos;] = sel.xpath(&apos;a/text()&apos;).extract()\n        item[&apos;link&apos;] = sel.xpath(&apos;a/@href&apos;).extract()\n        item[&apos;desc&apos;] = sel.xpath(&apos;text()&apos;).extract()\n        yield item\n\n        if sel.xpath(&apos;a/@href&apos;).extract() == &apos;&apos;:\n            print(&apos;empty&apos;)\n        else:\n            if len(sel.xpath(&apos;a/@href&apos;).extract()) &gt; 0:\n                self.num = self.num + 1\n\n                print(&apos;helo%s&apos; % (self.num))\n                yield Request(response.urljoin(sel.xpath(&apos;a/@href&apos;).extract()[0]), callback=self.parse)\n</code></pre><p>从以上内容可以看出我们的是对网页内人title、link、desc进行了抽取，同时根据link中的内容来进行接下去的网页爬取，其中需要注意的方法有一下几个：</p>\n<pre><code>with open(filename, &apos;wb&apos;) as f:\n    f.write(response.body)\n</code></pre><p>with as的语法是对于有<em>enter</em>()和<em>exit</em>()方法的对象使用的，这样可以减少我们代码的书写，不让像上面的内容我们就要写出如下的形式：</p>\n<pre><code>file = open(&quot;/tmp/foo.txt&quot;)\ntry:\n    data = file.read()\nfinally:\n    file.close()\n</code></pre><p>然后就是TutorialItem这个类了，该类我们定义在items.py中</p>\n<pre><code>import scrapy\n\nclass TutorialItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    title = scrapy.Field()\n    link = scrapy.Field()\n    desc = scrapy.Field()\n    pass\n</code></pre><p>至于sel.xpath(‘a/text()’)就是用来过滤出我们需要的xml对象了，这个方法是lxml包中的，这个包我们在上一篇文章中已经安装过滤，也就是pip instll lxml，而该方法中的表达式该如何写，这个就要靠自己了，人总是要靠自己的。当然我们也可以看下这篇blog的内容<a href=\"https://www.cnblogs.com/lei0213/p/7506130.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lei0213/p/7506130.html</a></p>\n<p>最后你是不是对yield这个语法很困惑，这个就和生成器相关了，详细内容可以看这个blog <a href=\"http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return</a>, 不同之处在于，yield返回的是一个生成器。</p>\n<p>最后的最后就是下面这段代码了</p>\n<pre><code>yield Request(response.urljoin(sel.xpath(&apos;a/@href&apos;).extract()[0]), callback=self.parse)\n</code></pre><p>它发起了对新的url的请求，并将返回的内容传递给parse进行处理，这就实现了新url的爬取效果。</p>\n<p>最后我们可以通过cmd输入一些命令来运行程序</p>\n<pre><code>scrapy crawl demo\n</code></pre><p>运行结果如下<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207164936.png\" alt=\"enter image description here\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用scrapy能够为我们提供很大的便利，如待爬取队里的建立，以及url去重等都不需要我们去做了，当然最棒的是它有一个扩展包scrapy-redis，通过使用这个包我们可以实现分布式爬取，到时候我们的爬取速度就能够有指数级的提升了（在有多台硬件设备的情况下），而后通过这大量的数据我们就可以进行一些如数据挖掘、机器学习的工作了，是不是很心动。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/helo005.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><strong>本文将记录一次使用scrapy进行网页数据爬取的经历。</strong></p>\n<h3 id=\"环境与安装\"><a href=\"#环境与安装\" class=\"headerlink\" title=\"环境与安装\"></a>环境与安装</h3><p><strong>环境</strong></p>\n<p>python – 3.6.1（区别python2和python3就行了，两者的语法在有些地方有区别）<br>scrapy – 1.5.0 （这个是根据你的python版本来选择的）<br>twisted<br>wheel<br>pywin32</p>\n<p><strong>安装python</strong><br>这里就不再赘述了，无非就是到python的官方网站下载相应安装包安装。如果要看的话，可以看blog里的另外一篇文章，也就是《python爬妹子》这一篇，或者可以看这个网址<a href=\"https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000\" target=\"_blank\" rel=\"noopener\">python安装</a></p>\n<p><strong>安装scrapy</strong><br>一般使用windows电脑安装时会出现安装失败的情况，故而我们需要到<a href=\"https://pypi.python.org/pypi/Scrapy/1.5.0\" target=\"_blank\" rel=\"noopener\">这个网站</a>下载相应的版本，来进行安装在安装之前我们还需要先安装wheel只需要在cmd中敲入：</p>\n<pre><code>pip install wheel\n</code></pre><p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153010.png\" alt=\"|center\"></p>\n<p>而后我们到<a href=\"https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/Scrapy/1.5.0下载相应的scrapy的.whl文件</a><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153247.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153547.png\" alt=\"|center\"><br>经过上面两部我们就将scrapy安装到了本地，但是有没有发现还是无法运行，因为还有<strong>pywin32 和twisted没有安装</strong>故而我们继续到<a href=\"https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/pywin32/222下载相应的的.whl文件进行安装</a><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207153939.png\" alt=\"pywin32\"><br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207154852.png\" alt=\"|center\"><br>同样使用命令行进行安装</p>\n<pre><code>pip install pywin32-222-cp36-cp36m-win_amd64.whl\npip install Twisted-17.9.0-cp27-cp27m-win_amd64.whl\n</code></pre><p>安装好这些之后我们就可以来看下scrapy了<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207155127.png\" alt=\"|center\"></p>\n<h3 id=\"scrapy初涉\"><a href=\"#scrapy初涉\" class=\"headerlink\" title=\"scrapy初涉\"></a>scrapy初涉</h3><p>之前没有接触过的小伙伴可以先看下这个网站的内容<a href=\"https://doc.scrapy.org/en/latest/intro/tutorial.html\" target=\"_blank\" rel=\"noopener\">https://doc.scrapy.org/en/latest/intro/tutorial.html</a></p>\n<p>我们先通过下面命令行创建一个scrapy项目</p>\n<pre><code>scrapy startproject heloScrapy\n</code></pre><p>相应的文件结构如下图所示</p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207161524.png\" alt=\"|center\"></p>\n<p>而后我们在spiders文件夹下创建一个demo.py文件，之后的主要代码都将在该文件内完成。<br>引入scrapy以及相应的request，并命名为demo</p>\n<pre><code>import scrapy\nfrom tutorial.items import TutorialItem\nfrom scrapy.http import Request\n\nclass DmozSpider(scrapy.Spider):\n    name = &quot;demo&quot;\n    allowed_domains = [&quot;blog.csdn.net&quot;, &quot;baidu.com&quot;]\n    start_urls = [\n    &quot;http://blog.csdn.net/u013687632/article/details/57075514&quot;\n    ]\n</code></pre><p>此处在start_urls中设置了相应的初始网址<a href=\"http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u013687632/article/details/57075514，也就是我们将从该网址出发来爬取相应网页内容，同时我们对于allowed_domains</a> 的设置使我们只爬取这个域名内的网页。</p>\n<p>在设置好以上内容之后，scrapy会将start_urls 网页的内容以response的形式传递给parse函数，下面我们就将对parse函数进行定义</p>\n<pre><code>def parse(self, response):\n    filename = response.url.split(&quot;/&quot;)[-2]\n    with open(filename, &apos;wb&apos;) as f:\n        f.write(response.body)\n    for sel in response.xpath(&apos;//ul/li&apos;):\n        item = TutorialItem()\n        item[&apos;title&apos;] = sel.xpath(&apos;a/text()&apos;).extract()\n        item[&apos;link&apos;] = sel.xpath(&apos;a/@href&apos;).extract()\n        item[&apos;desc&apos;] = sel.xpath(&apos;text()&apos;).extract()\n        yield item\n\n        if sel.xpath(&apos;a/@href&apos;).extract() == &apos;&apos;:\n            print(&apos;empty&apos;)\n        else:\n            if len(sel.xpath(&apos;a/@href&apos;).extract()) &gt; 0:\n                self.num = self.num + 1\n\n                print(&apos;helo%s&apos; % (self.num))\n                yield Request(response.urljoin(sel.xpath(&apos;a/@href&apos;).extract()[0]), callback=self.parse)\n</code></pre><p>从以上内容可以看出我们的是对网页内人title、link、desc进行了抽取，同时根据link中的内容来进行接下去的网页爬取，其中需要注意的方法有一下几个：</p>\n<pre><code>with open(filename, &apos;wb&apos;) as f:\n    f.write(response.body)\n</code></pre><p>with as的语法是对于有<em>enter</em>()和<em>exit</em>()方法的对象使用的，这样可以减少我们代码的书写，不让像上面的内容我们就要写出如下的形式：</p>\n<pre><code>file = open(&quot;/tmp/foo.txt&quot;)\ntry:\n    data = file.read()\nfinally:\n    file.close()\n</code></pre><p>然后就是TutorialItem这个类了，该类我们定义在items.py中</p>\n<pre><code>import scrapy\n\nclass TutorialItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    title = scrapy.Field()\n    link = scrapy.Field()\n    desc = scrapy.Field()\n    pass\n</code></pre><p>至于sel.xpath(‘a/text()’)就是用来过滤出我们需要的xml对象了，这个方法是lxml包中的，这个包我们在上一篇文章中已经安装过滤，也就是pip instll lxml，而该方法中的表达式该如何写，这个就要靠自己了，人总是要靠自己的。当然我们也可以看下这篇blog的内容<a href=\"https://www.cnblogs.com/lei0213/p/7506130.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lei0213/p/7506130.html</a></p>\n<p>最后你是不是对yield这个语法很困惑，这个就和生成器相关了，详细内容可以看这个blog <a href=\"http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/83610/，简单来将呢，yield就是一个关键词，类似return</a>, 不同之处在于，yield返回的是一个生成器。</p>\n<p>最后的最后就是下面这段代码了</p>\n<pre><code>yield Request(response.urljoin(sel.xpath(&apos;a/@href&apos;).extract()[0]), callback=self.parse)\n</code></pre><p>它发起了对新的url的请求，并将返回的内容传递给parse进行处理，这就实现了新url的爬取效果。</p>\n<p>最后我们可以通过cmd输入一些命令来运行程序</p>\n<pre><code>scrapy crawl demo\n</code></pre><p>运行结果如下<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180207164936.png\" alt=\"enter image description here\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用scrapy能够为我们提供很大的便利，如待爬取队里的建立，以及url去重等都不需要我们去做了，当然最棒的是它有一个扩展包scrapy-redis，通过使用这个包我们可以实现分布式爬取，到时候我们的爬取速度就能够有指数级的提升了（在有多台硬件设备的情况下），而后通过这大量的数据我们就可以进行一些如数据挖掘、机器学习的工作了，是不是很心动。</p>\n"},{"title":"点击图标启动activity的过程","date":"2018-02-26T04:02:30.000Z","_content":"\n![enter image description here](http://hi.csdn.net/attachment/201108/14/0_1313305334OkCc.gif)\n\n**1.在ActivityStack.startActivityLocked（创建ActivityRecord）**\n\n**2.在ActivityStack.startActivityUncheckedLocked（创建TaskRecord）**\n\n3.startActivityLocked -->  \nstartActivityUncheckedLocked --> \nstartActivityLocked --> \nresumeTopActivityLocked --> \nstartPausingLocked \n**-binder->** \n**ApplicationThreadProxy.schedulePauseActivity -->** \n\n**（下面的两行是message的传递）**\nActivityThread.queueOrSendMessage --> \nH.handleMessage --> \n\n**ActivityThread.handlePauseActivity（真正执行pause）** \n\n**-binder->** \n**ActivityManagerProxy.activityPaused -->** \n**ActivityStack.activityPaused（在stack中做一些pause之后的处理） -->**\nActivityStack.completePauseLocked --> \n\nActivityStack.resumeTopActivityLocked(launcer已停止，需启动mainactivity) -->  \n\nActivityStack.startSpecificActivityLocked --> \n**ActivityManagerService.startProcessLocked(开始创建进程，并将ActivityThread添入其中)**\n\nProcessRecord app = getProcessRecordLocked(processName, info.uid);  \nint pid = Process.start(\"android.app.ActivityThread\",  \n                mSimpleProcessManagement ? app.processName : null, uid, uid,  \n                gids, debugFlags, null); \n\n**ActivityThread.main（启动ActivityThread）** \n**-binder->** \nActivityManagerProxy.attachApplication \n\n通过pid将processRecord取回，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作\n\n**ActivityStack.realStartActivityLocked** \n**-binder->** \n**ApplicationThreadProxy.scheduleLaunchActivity -->** \n\nActivityThread.queueOrSendMessage --> \n**ActivityThread.handleLaunchActivity（真正launcher new Activity）** \n\n这里首先调用performLaunchActivity函数来加载这个Activity类，即shy.luo.activity.MainActivity，然后调用它的onCreate函数，最后回到handleLaunchActivity函数时，再调用handleResumeActivity函数来使这个Activity进入Resumed状态，即会调用这个Activity的onResume函数，这是遵循Activity的生命周期的。\n\n**ActivityThread.performLaunchActivity -->**\n\n**1函数前面是收集要启动的Activity的相关信息，主要package和component信息**\n**2然后通过ClassLoader将shy.luo.activity.MainActivity类加载进来**\n**3接下来是创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的**\n**4后面的代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到MainActivity中去**\n**5最后还要调用MainActivity的onCreate函数**\n\n这里不是直接调用MainActivity的onCreate函数，而是通过mInstrumentation的callActivityOnCreate函数来间接调用，前面我们说过，mInstrumentation在这里的作用是监控Activity与系统的交互操作，相当于是系统运行日志。\n\n\n\n 一. Step1 - Step 11：Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；\n\n二. Step 12 - Step 16：ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；\n\n三. Step 17 - Step 24：Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；\n\n四. Step 25 - Step 27：ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；\n\n五. Step 28 - Step 35：ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。 ","source":"_posts/点击图标启动activity的过程.md","raw":"---\ntitle: 点击图标启动activity的过程\ndate: 2018-02-26 12:02:30\ncategories: \"android\"\ntags:\n     - android\n     - 源码\n     - 技术\n---\n\n![enter image description here](http://hi.csdn.net/attachment/201108/14/0_1313305334OkCc.gif)\n\n**1.在ActivityStack.startActivityLocked（创建ActivityRecord）**\n\n**2.在ActivityStack.startActivityUncheckedLocked（创建TaskRecord）**\n\n3.startActivityLocked -->  \nstartActivityUncheckedLocked --> \nstartActivityLocked --> \nresumeTopActivityLocked --> \nstartPausingLocked \n**-binder->** \n**ApplicationThreadProxy.schedulePauseActivity -->** \n\n**（下面的两行是message的传递）**\nActivityThread.queueOrSendMessage --> \nH.handleMessage --> \n\n**ActivityThread.handlePauseActivity（真正执行pause）** \n\n**-binder->** \n**ActivityManagerProxy.activityPaused -->** \n**ActivityStack.activityPaused（在stack中做一些pause之后的处理） -->**\nActivityStack.completePauseLocked --> \n\nActivityStack.resumeTopActivityLocked(launcer已停止，需启动mainactivity) -->  \n\nActivityStack.startSpecificActivityLocked --> \n**ActivityManagerService.startProcessLocked(开始创建进程，并将ActivityThread添入其中)**\n\nProcessRecord app = getProcessRecordLocked(processName, info.uid);  \nint pid = Process.start(\"android.app.ActivityThread\",  \n                mSimpleProcessManagement ? app.processName : null, uid, uid,  \n                gids, debugFlags, null); \n\n**ActivityThread.main（启动ActivityThread）** \n**-binder->** \nActivityManagerProxy.attachApplication \n\n通过pid将processRecord取回，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作\n\n**ActivityStack.realStartActivityLocked** \n**-binder->** \n**ApplicationThreadProxy.scheduleLaunchActivity -->** \n\nActivityThread.queueOrSendMessage --> \n**ActivityThread.handleLaunchActivity（真正launcher new Activity）** \n\n这里首先调用performLaunchActivity函数来加载这个Activity类，即shy.luo.activity.MainActivity，然后调用它的onCreate函数，最后回到handleLaunchActivity函数时，再调用handleResumeActivity函数来使这个Activity进入Resumed状态，即会调用这个Activity的onResume函数，这是遵循Activity的生命周期的。\n\n**ActivityThread.performLaunchActivity -->**\n\n**1函数前面是收集要启动的Activity的相关信息，主要package和component信息**\n**2然后通过ClassLoader将shy.luo.activity.MainActivity类加载进来**\n**3接下来是创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的**\n**4后面的代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到MainActivity中去**\n**5最后还要调用MainActivity的onCreate函数**\n\n这里不是直接调用MainActivity的onCreate函数，而是通过mInstrumentation的callActivityOnCreate函数来间接调用，前面我们说过，mInstrumentation在这里的作用是监控Activity与系统的交互操作，相当于是系统运行日志。\n\n\n\n 一. Step1 - Step 11：Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；\n\n二. Step 12 - Step 16：ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；\n\n三. Step 17 - Step 24：Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；\n\n四. Step 25 - Step 27：ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；\n\n五. Step 28 - Step 35：ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。 ","slug":"点击图标启动activity的过程","published":1,"updated":"2018-02-26T04:07:49.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5iguxc000d8giegz6bajps","content":"<p><img src=\"http://hi.csdn.net/attachment/201108/14/0_1313305334OkCc.gif\" alt=\"enter image description here\"></p>\n<p><strong>1.在ActivityStack.startActivityLocked（创建ActivityRecord）</strong></p>\n<p><strong>2.在ActivityStack.startActivityUncheckedLocked（创建TaskRecord）</strong></p>\n<p>3.startActivityLocked –&gt;<br>startActivityUncheckedLocked –&gt;<br>startActivityLocked –&gt;<br>resumeTopActivityLocked –&gt;<br>startPausingLocked<br><strong>-binder-&gt;</strong><br><strong>ApplicationThreadProxy.schedulePauseActivity –&gt;</strong> </p>\n<p><strong>（下面的两行是message的传递）</strong><br>ActivityThread.queueOrSendMessage –&gt;<br>H.handleMessage –&gt; </p>\n<p><strong>ActivityThread.handlePauseActivity（真正执行pause）</strong> </p>\n<p><strong>-binder-&gt;</strong><br><strong>ActivityManagerProxy.activityPaused –&gt;</strong><br><strong>ActivityStack.activityPaused（在stack中做一些pause之后的处理） –&gt;</strong><br>ActivityStack.completePauseLocked –&gt; </p>\n<p>ActivityStack.resumeTopActivityLocked(launcer已停止，需启动mainactivity) –&gt;  </p>\n<p>ActivityStack.startSpecificActivityLocked –&gt;<br><strong>ActivityManagerService.startProcessLocked(开始创建进程，并将ActivityThread添入其中)</strong></p>\n<p>ProcessRecord app = getProcessRecordLocked(processName, info.uid);<br>int pid = Process.start(“android.app.ActivityThread”,<br>                mSimpleProcessManagement ? app.processName : null, uid, uid,<br>                gids, debugFlags, null); </p>\n<p><strong>ActivityThread.main（启动ActivityThread）</strong><br><strong>-binder-&gt;</strong><br>ActivityManagerProxy.attachApplication </p>\n<p>通过pid将processRecord取回，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作</p>\n<p><strong>ActivityStack.realStartActivityLocked</strong><br><strong>-binder-&gt;</strong><br><strong>ApplicationThreadProxy.scheduleLaunchActivity –&gt;</strong> </p>\n<p>ActivityThread.queueOrSendMessage –&gt;<br><strong>ActivityThread.handleLaunchActivity（真正launcher new Activity）</strong> </p>\n<p>这里首先调用performLaunchActivity函数来加载这个Activity类，即shy.luo.activity.MainActivity，然后调用它的onCreate函数，最后回到handleLaunchActivity函数时，再调用handleResumeActivity函数来使这个Activity进入Resumed状态，即会调用这个Activity的onResume函数，这是遵循Activity的生命周期的。</p>\n<p><strong>ActivityThread.performLaunchActivity –&gt;</strong></p>\n<p><strong>1函数前面是收集要启动的Activity的相关信息，主要package和component信息</strong><br><strong>2然后通过ClassLoader将shy.luo.activity.MainActivity类加载进来</strong><br><strong>3接下来是创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的</strong><br><strong>4后面的代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到MainActivity中去</strong><br><strong>5最后还要调用MainActivity的onCreate函数</strong></p>\n<p>这里不是直接调用MainActivity的onCreate函数，而是通过mInstrumentation的callActivityOnCreate函数来间接调用，前面我们说过，mInstrumentation在这里的作用是监控Activity与系统的交互操作，相当于是系统运行日志。</p>\n<p> 一. Step1 - Step 11：Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；</p>\n<p>二. Step 12 - Step 16：ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</p>\n<p>三. Step 17 - Step 24：Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</p>\n<p>四. Step 25 - Step 27：ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</p>\n<p>五. Step 28 - Step 35：ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://hi.csdn.net/attachment/201108/14/0_1313305334OkCc.gif\" alt=\"enter image description here\"></p>\n<p><strong>1.在ActivityStack.startActivityLocked（创建ActivityRecord）</strong></p>\n<p><strong>2.在ActivityStack.startActivityUncheckedLocked（创建TaskRecord）</strong></p>\n<p>3.startActivityLocked –&gt;<br>startActivityUncheckedLocked –&gt;<br>startActivityLocked –&gt;<br>resumeTopActivityLocked –&gt;<br>startPausingLocked<br><strong>-binder-&gt;</strong><br><strong>ApplicationThreadProxy.schedulePauseActivity –&gt;</strong> </p>\n<p><strong>（下面的两行是message的传递）</strong><br>ActivityThread.queueOrSendMessage –&gt;<br>H.handleMessage –&gt; </p>\n<p><strong>ActivityThread.handlePauseActivity（真正执行pause）</strong> </p>\n<p><strong>-binder-&gt;</strong><br><strong>ActivityManagerProxy.activityPaused –&gt;</strong><br><strong>ActivityStack.activityPaused（在stack中做一些pause之后的处理） –&gt;</strong><br>ActivityStack.completePauseLocked –&gt; </p>\n<p>ActivityStack.resumeTopActivityLocked(launcer已停止，需启动mainactivity) –&gt;  </p>\n<p>ActivityStack.startSpecificActivityLocked –&gt;<br><strong>ActivityManagerService.startProcessLocked(开始创建进程，并将ActivityThread添入其中)</strong></p>\n<p>ProcessRecord app = getProcessRecordLocked(processName, info.uid);<br>int pid = Process.start(“android.app.ActivityThread”,<br>                mSimpleProcessManagement ? app.processName : null, uid, uid,<br>                gids, debugFlags, null); </p>\n<p><strong>ActivityThread.main（启动ActivityThread）</strong><br><strong>-binder-&gt;</strong><br>ActivityManagerProxy.attachApplication </p>\n<p>通过pid将processRecord取回，放在app变量中，然后对app的其它成员进行初始化，最后调用mMainStack.realStartActivityLocked执行真正的Activity启动操作</p>\n<p><strong>ActivityStack.realStartActivityLocked</strong><br><strong>-binder-&gt;</strong><br><strong>ApplicationThreadProxy.scheduleLaunchActivity –&gt;</strong> </p>\n<p>ActivityThread.queueOrSendMessage –&gt;<br><strong>ActivityThread.handleLaunchActivity（真正launcher new Activity）</strong> </p>\n<p>这里首先调用performLaunchActivity函数来加载这个Activity类，即shy.luo.activity.MainActivity，然后调用它的onCreate函数，最后回到handleLaunchActivity函数时，再调用handleResumeActivity函数来使这个Activity进入Resumed状态，即会调用这个Activity的onResume函数，这是遵循Activity的生命周期的。</p>\n<p><strong>ActivityThread.performLaunchActivity –&gt;</strong></p>\n<p><strong>1函数前面是收集要启动的Activity的相关信息，主要package和component信息</strong><br><strong>2然后通过ClassLoader将shy.luo.activity.MainActivity类加载进来</strong><br><strong>3接下来是创建Application对象，这是根据AndroidManifest.xml配置文件中的Application标签的信息来创建的</strong><br><strong>4后面的代码主要创建Activity的上下文信息，并通过attach方法将这些上下文信息设置到MainActivity中去</strong><br><strong>5最后还要调用MainActivity的onCreate函数</strong></p>\n<p>这里不是直接调用MainActivity的onCreate函数，而是通过mInstrumentation的callActivityOnCreate函数来间接调用，前面我们说过，mInstrumentation在这里的作用是监控Activity与系统的交互操作，相当于是系统运行日志。</p>\n<p> 一. Step1 - Step 11：Launcher通过Binder进程间通信机制通知ActivityManagerService，它要启动一个Activity；</p>\n<p>二. Step 12 - Step 16：ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</p>\n<p>三. Step 17 - Step 24：Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</p>\n<p>四. Step 25 - Step 27：ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</p>\n<p>五. Step 28 - Step 35：ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。 </p>\n"},{"title":"python爬虫初涉","date":"2018-02-06T06:17:44.000Z","_content":"\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/helo004.jpg)\n\n### 文章简介\n\n**本文将介绍如何使用python对www.mzitu.com中所有的图片的爬取以及存储到本地最后我们会得到如下图1所示**\n\n\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206142745.png)\n\n是不是很心动，接下来就让我们开始python爬虫之旅，本期内容将会从单线程使用到多线程，从自己写python到使用scrapy包，以及分布式redis的使用，当然这些都是后话了，当前我们的目标是要爬去这个网站上的美图。\n\n### 环境介绍\n\n废话少说接下来就是我们的基础环境部分\n**1.Python -- 3.6.1**（这个版本其实要区别的就是python2和python3啦，我使用的python3）\n\n**2.Requests** （看名字就知道这个是用来进行网络请求用的，这里的request是rllib包中的，之后我们要学的scrapy中也有自己想要的request，到时候两个不要搞混了）\n\n**3.beautifulsoup** （当然数据获取到了之后，我们要对数据进行提取，解析就是通过beautifulsoup来进行，当然我们自己也可通过正则表达式来对数据进行过滤，如果你的正则水平不错的情况下） \n\n**4.LXML** 一个HTML解析包 用于辅助beautifulsoup解析网页  \n\n--------------\n**上面的模块需要 单独安装，下面几个就不用啦。**\n\n--------------\n**5.OS 系统内置模块** （这个玩意是系统内置的，在本文中我们通过它来将图片存储在本地）\n\n**6.PyCharm**   一个草鸡好用的PythonIDE工具 、真滴。\n\n\n### 模块的安装\n\n再使用pip指令之前我们需要安装python。（如果我们安装python时选择**不将**python写入环境变量的话，那么我们还需要将“文件夹\\python36”和“文件夹\\python36\\Scripts”写入path中，这样我们才能在控制台中使用python和pip指令）\n\n**接下来就用指令安装模块**\n    \n     pip install requests   \n     pip install beautifulsoup4  \n     pip install lxml\n\n大致结果就如下图所示\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206150606.png)\n\n当python + 3个模块 + PyCharm安装完成之后我们就可以开始我们本次抓取的代码编写了。\n\n### 爬虫编写\n**首先我们先整理一下爬图片的步骤：**\n\n1.我们需要一个目标网站（www.mzitu.com）\n2.我们需要从一个网页中找出接下来要去的网页的链接地址，通过beautifulsoup来获取\n3.获取网页中的图片地址\n4.下载图片到本地\n\n\n**步骤1：**\nwww.mzitu.com网站的截图如下，这里选择了www.mzitu.com/all作为起始网页，因为在该网页中包含了网站中所有图片组图的链接链接地址\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160047.png)\n\n\n**步骤2：**\n推荐使用chrome浏览器来进行网页源码的查看\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160522.png)\n\n通过观察我们可以发现接下来的链接地址在所在的**href**是被**div class=all**所包含着的，所有我们可以使用这一点来找到所有的url地址\n\n**步骤3：**\n接下来我们就进入到某个链接里面去看图了\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161232.png)\n相应图片的地址被包含在**div class='main-image'**中\n\n\n注意着个有一套图（一般她们拍写真都有很多张的），所以呢我们就看下接下来的这张图\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161358.png)\n着张图里的**href**就是套图里其他图片所在网页的地址了，有了这个我们就可以获取接下来的图片了，其中通过观察可以发现**href**被包在**div class=‘pagenavi’**中\n\n**步骤4：**\n**开始代码编写**\n\n我们需要在代码中引入相应的模块\n\n    import requests\n\tfrom bs4 import BeautifulSoup\n\timport os\n\n获取起始网页内容\n\n    html = self.request(url)\n    \n这里的request是下面的这个方法\n\n        def request(self, url):  ##这个函数获取网页的response 然后返回\n\t        headers = {\n            'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}\n\t        content = requests.get(url, headers=headers)\n\n\t        return content\n\n获取步骤1中内容（也就是所有套图的地址），并进一步发送请求获取到套图首张图片所在网页\n\n    all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')\n    for a in all_a:       \n\t    title = a.get_text() #取出a标签的文本       \n\t    href = a['href'] #取出a标签的href 属性，也就是套图地址\n\t    self.html(href, \"e:\\\\pic\\\\\" + path)\n\t\n相应的html方法\n\n        def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n\t        html = self.request(href)\n\t        helo = BeautifulSoup(html.text, 'lxml').find_all('span')\n\t        if len(helo) < 10:\n\t            return\n\t        max_span = helo[10].get_text()\n\t        for page in range(1, int(max_span) + 1):\n\t            page_url = href + '/' + str(page)\n\t            self.img(page_url, path)  ##调用img函数\n\n上面的html方法中的后半截是执行了步骤3中的后半部分，也就是遍历了套图中其他图片所在的网页，相应的img方法如下\n\n        def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n\t        img_html = self.request(page_url)\n\t        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')\n\t        if helo is not None:\n\t            helo1 = helo.find('img')\n\t            if helo1 is not None:\n\t                # do some thing you need\n\t                img_url = helo1['src']\n\t                self.saveImg(img_url, path)\n\n        def saveImg(self, url, path):\n\t        getHeaders = {\n\t            'Host': 'i.meizitu.net',\n\t            'Connection': 'Keep-Alive',\n\t            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',\n\t            'Referer': 'http://www.mzitu.com/',\n\t            'Accept-Encoding': 'gzip, deflate',\n\t            'Accept-Language': 'zh-CN,zh;q=0.9'\n\t        }\n\t        response = requests.get(url, headers=getHeaders)\n\t        \n\t        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n\t            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n\t            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n\t                name = url[-9:-4]\n\t                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址\n\t                response = requests.get(redirectUrl)\n\t                fp = open(name + \".jpg\", 'ab')\n\t                fp.write(response.content)\n\t                fp.close()\n\t        else:\n\t            os.chdir(path)\n\t            name = url[-9:-4]\n\t            fp = open(name + \".jpg\", 'ab')\n\t            fp.write(response.content)\n\t            fp.close()\n\t            self.picNum = self.picNum + 1\n\t            print(self.picNum)\n\t            \n方法saveImg执行了步骤4，也就是将图片保存在了本地。\n\n\n\n### 总结\n\n本片文字是在之前微信上看到的一篇文章改写的，当时照着那篇文字将代码写了一遍之后发现，保存在本地的图片都被篡改了，也就是被防盗链了，而后就只能修改request中的一些参数来确保准确性。在上面这些完成后，发现对爬虫有了一点的了解之后想着是不是可以使用多线程的方式来爬去，就又看了多线程的写法，下面贴出多线程的代码，这里使用的线程池。\n\n**多线程代码**\n\n    import requests\n\tfrom bs4 import BeautifulSoup\n\timport os\n\timport threading\n\timport threadpool\n\t\n\t\n\tclass mzitu():\n\t    num = 0\n\t    picNum = 0\n\n\t    def all_url(self, url):\n\t        self.cv = threading.Condition()\n\t        html = self.request(url)  ##调用request函数把套图地址传进去会返回给我们一个response\n\t        all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')\n\t\n\t        task_pool = threadpool.ThreadPool(50)\n\t        requests = threadpool.makeRequests(self.nice, all_a)\n\t        for req in requests:\n\t            task_pool.putRequest(req)\n\t        task_pool.wait()\n\n\t    def nice(self, a):\n\t        title = a.get_text()\n\t        path = str(title).replace(\"?\", '_')  ##我注意到有个标题带有 ？  这个符号Windows系统是不能创建文件夹的所以要替换掉\n\t        if self.mkdir(path):  ##调用mkdir函数创建文件夹！这儿path代表的是标题title哦！！！！！不要糊涂了哦！\n\t            os.chdir(\"e:\\\\pic\\\\\" + path)  ##切换到目录\n\t            href = a['href']\n\t            self.html(href, \"e:\\\\pic\\\\\" + path)  ##调用html函数把href参数传递过去！href是啥还记的吧？ 就是套图的地址哦！！不要迷糊了哦！\n\n\t    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n\t        html = self.request(href)\n\t        helo = BeautifulSoup(html.text, 'lxml').find_all('span')\n\t        if len(helo) < 10:\n\t            return\n\t        max_span = helo[10].get_text()\n\t        for page in range(1, int(max_span) + 1):\n\t            page_url = href + '/' + str(page)\n\t            self.img(page_url, path)  ##调用img函数\n\n\t    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n\t        img_html = self.request(page_url)\n\t        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')\n\t        if helo is not None:\n\t            helo1 = helo.find('img')\n\t            if helo1 is not None:\n\t                # do some thing you need\n\t                img_url = helo1['src']\n\t                self.saveImg(img_url, path)\n\t\n\t    def mkdir(self, path):  ##这个函数创建文件夹\n\t        path = path.strip()\n\t        if path.__contains__(\"妲己\"):\n\t            return False\n\t        isExists = os.path.exists(os.path.join(\"e:\\\\pic\\\\\", path))\n\t        if not isExists:\n\t            os.makedirs(os.path.join(\"e:\\\\pic\\\\\", path))\n\t            return True\n\t        else:\n\t            return False\n\t\n\t    def request(self, url):  ##这个函数获取网页的response 然后返回\n\t        headers = {\n\t            'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}\n\t        content = requests.get(url, headers=headers)\n\t\n\t        return content\n\t\n\t    def saveImg(self, url, path):\n\t        getHeaders = {\n\t            'Host': 'i.meizitu.net',\n\t            'Connection': 'Keep-Alive',\n\t            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',\n\t            'Referer': 'http://www.mzitu.com/',\n\t            'Accept-Encoding': 'gzip, deflate',\n\t            'Accept-Language': 'zh-CN,zh;q=0.9'\n\t        }\n\t\n\t        response = requests.get(url, headers=getHeaders)\n\t        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n\t            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n\t            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n\t                name = url[-9:-4]\n\t                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址\n\t                response = requests.get(redirectUrl)\n\t                fp = open(name + \".jpg\", 'ab')\n\t                fp.write(response.content)\n\t                fp.close()\n\t        else:\n\t            os.chdir(path)\n\t            name = url[-9:-4]\n\t            fp = open(name + \".jpg\", 'ab')\n\t            fp.write(response.content)\n\t            fp.close()\n\t            self.picNum = self.picNum + 1\n\t            print(self.picNum)\n\t            \n\tMzitu = mzitu()  ##实例化\n\tMzitu.all_url('http://www.mzitu.com/all')  ##给函数all_url传入参数  你可以当作启动爬虫（就是入口）\n\n\n\n\n\n\n\n       \n\n\n\n\n","source":"_posts/python抓妹子.md","raw":"---\ntitle: python爬虫初涉\ndate: 2018-02-06 14:17:44\ncategories: \"python\"\ntags:\n     - python\n     - 爬虫\n     - 技术\n---\n\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/helo004.jpg)\n\n### 文章简介\n\n**本文将介绍如何使用python对www.mzitu.com中所有的图片的爬取以及存储到本地最后我们会得到如下图1所示**\n\n\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206142745.png)\n\n是不是很心动，接下来就让我们开始python爬虫之旅，本期内容将会从单线程使用到多线程，从自己写python到使用scrapy包，以及分布式redis的使用，当然这些都是后话了，当前我们的目标是要爬去这个网站上的美图。\n\n### 环境介绍\n\n废话少说接下来就是我们的基础环境部分\n**1.Python -- 3.6.1**（这个版本其实要区别的就是python2和python3啦，我使用的python3）\n\n**2.Requests** （看名字就知道这个是用来进行网络请求用的，这里的request是rllib包中的，之后我们要学的scrapy中也有自己想要的request，到时候两个不要搞混了）\n\n**3.beautifulsoup** （当然数据获取到了之后，我们要对数据进行提取，解析就是通过beautifulsoup来进行，当然我们自己也可通过正则表达式来对数据进行过滤，如果你的正则水平不错的情况下） \n\n**4.LXML** 一个HTML解析包 用于辅助beautifulsoup解析网页  \n\n--------------\n**上面的模块需要 单独安装，下面几个就不用啦。**\n\n--------------\n**5.OS 系统内置模块** （这个玩意是系统内置的，在本文中我们通过它来将图片存储在本地）\n\n**6.PyCharm**   一个草鸡好用的PythonIDE工具 、真滴。\n\n\n### 模块的安装\n\n再使用pip指令之前我们需要安装python。（如果我们安装python时选择**不将**python写入环境变量的话，那么我们还需要将“文件夹\\python36”和“文件夹\\python36\\Scripts”写入path中，这样我们才能在控制台中使用python和pip指令）\n\n**接下来就用指令安装模块**\n    \n     pip install requests   \n     pip install beautifulsoup4  \n     pip install lxml\n\n大致结果就如下图所示\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206150606.png)\n\n当python + 3个模块 + PyCharm安装完成之后我们就可以开始我们本次抓取的代码编写了。\n\n### 爬虫编写\n**首先我们先整理一下爬图片的步骤：**\n\n1.我们需要一个目标网站（www.mzitu.com）\n2.我们需要从一个网页中找出接下来要去的网页的链接地址，通过beautifulsoup来获取\n3.获取网页中的图片地址\n4.下载图片到本地\n\n\n**步骤1：**\nwww.mzitu.com网站的截图如下，这里选择了www.mzitu.com/all作为起始网页，因为在该网页中包含了网站中所有图片组图的链接链接地址\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160047.png)\n\n\n**步骤2：**\n推荐使用chrome浏览器来进行网页源码的查看\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160522.png)\n\n通过观察我们可以发现接下来的链接地址在所在的**href**是被**div class=all**所包含着的，所有我们可以使用这一点来找到所有的url地址\n\n**步骤3：**\n接下来我们就进入到某个链接里面去看图了\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161232.png)\n相应图片的地址被包含在**div class='main-image'**中\n\n\n注意着个有一套图（一般她们拍写真都有很多张的），所以呢我们就看下接下来的这张图\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161358.png)\n着张图里的**href**就是套图里其他图片所在网页的地址了，有了这个我们就可以获取接下来的图片了，其中通过观察可以发现**href**被包在**div class=‘pagenavi’**中\n\n**步骤4：**\n**开始代码编写**\n\n我们需要在代码中引入相应的模块\n\n    import requests\n\tfrom bs4 import BeautifulSoup\n\timport os\n\n获取起始网页内容\n\n    html = self.request(url)\n    \n这里的request是下面的这个方法\n\n        def request(self, url):  ##这个函数获取网页的response 然后返回\n\t        headers = {\n            'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}\n\t        content = requests.get(url, headers=headers)\n\n\t        return content\n\n获取步骤1中内容（也就是所有套图的地址），并进一步发送请求获取到套图首张图片所在网页\n\n    all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')\n    for a in all_a:       \n\t    title = a.get_text() #取出a标签的文本       \n\t    href = a['href'] #取出a标签的href 属性，也就是套图地址\n\t    self.html(href, \"e:\\\\pic\\\\\" + path)\n\t\n相应的html方法\n\n        def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n\t        html = self.request(href)\n\t        helo = BeautifulSoup(html.text, 'lxml').find_all('span')\n\t        if len(helo) < 10:\n\t            return\n\t        max_span = helo[10].get_text()\n\t        for page in range(1, int(max_span) + 1):\n\t            page_url = href + '/' + str(page)\n\t            self.img(page_url, path)  ##调用img函数\n\n上面的html方法中的后半截是执行了步骤3中的后半部分，也就是遍历了套图中其他图片所在的网页，相应的img方法如下\n\n        def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n\t        img_html = self.request(page_url)\n\t        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')\n\t        if helo is not None:\n\t            helo1 = helo.find('img')\n\t            if helo1 is not None:\n\t                # do some thing you need\n\t                img_url = helo1['src']\n\t                self.saveImg(img_url, path)\n\n        def saveImg(self, url, path):\n\t        getHeaders = {\n\t            'Host': 'i.meizitu.net',\n\t            'Connection': 'Keep-Alive',\n\t            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',\n\t            'Referer': 'http://www.mzitu.com/',\n\t            'Accept-Encoding': 'gzip, deflate',\n\t            'Accept-Language': 'zh-CN,zh;q=0.9'\n\t        }\n\t        response = requests.get(url, headers=getHeaders)\n\t        \n\t        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n\t            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n\t            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n\t                name = url[-9:-4]\n\t                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址\n\t                response = requests.get(redirectUrl)\n\t                fp = open(name + \".jpg\", 'ab')\n\t                fp.write(response.content)\n\t                fp.close()\n\t        else:\n\t            os.chdir(path)\n\t            name = url[-9:-4]\n\t            fp = open(name + \".jpg\", 'ab')\n\t            fp.write(response.content)\n\t            fp.close()\n\t            self.picNum = self.picNum + 1\n\t            print(self.picNum)\n\t            \n方法saveImg执行了步骤4，也就是将图片保存在了本地。\n\n\n\n### 总结\n\n本片文字是在之前微信上看到的一篇文章改写的，当时照着那篇文字将代码写了一遍之后发现，保存在本地的图片都被篡改了，也就是被防盗链了，而后就只能修改request中的一些参数来确保准确性。在上面这些完成后，发现对爬虫有了一点的了解之后想着是不是可以使用多线程的方式来爬去，就又看了多线程的写法，下面贴出多线程的代码，这里使用的线程池。\n\n**多线程代码**\n\n    import requests\n\tfrom bs4 import BeautifulSoup\n\timport os\n\timport threading\n\timport threadpool\n\t\n\t\n\tclass mzitu():\n\t    num = 0\n\t    picNum = 0\n\n\t    def all_url(self, url):\n\t        self.cv = threading.Condition()\n\t        html = self.request(url)  ##调用request函数把套图地址传进去会返回给我们一个response\n\t        all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a')\n\t\n\t        task_pool = threadpool.ThreadPool(50)\n\t        requests = threadpool.makeRequests(self.nice, all_a)\n\t        for req in requests:\n\t            task_pool.putRequest(req)\n\t        task_pool.wait()\n\n\t    def nice(self, a):\n\t        title = a.get_text()\n\t        path = str(title).replace(\"?\", '_')  ##我注意到有个标题带有 ？  这个符号Windows系统是不能创建文件夹的所以要替换掉\n\t        if self.mkdir(path):  ##调用mkdir函数创建文件夹！这儿path代表的是标题title哦！！！！！不要糊涂了哦！\n\t            os.chdir(\"e:\\\\pic\\\\\" + path)  ##切换到目录\n\t            href = a['href']\n\t            self.html(href, \"e:\\\\pic\\\\\" + path)  ##调用html函数把href参数传递过去！href是啥还记的吧？ 就是套图的地址哦！！不要迷糊了哦！\n\n\t    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n\t        html = self.request(href)\n\t        helo = BeautifulSoup(html.text, 'lxml').find_all('span')\n\t        if len(helo) < 10:\n\t            return\n\t        max_span = helo[10].get_text()\n\t        for page in range(1, int(max_span) + 1):\n\t            page_url = href + '/' + str(page)\n\t            self.img(page_url, path)  ##调用img函数\n\n\t    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n\t        img_html = self.request(page_url)\n\t        helo = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image')\n\t        if helo is not None:\n\t            helo1 = helo.find('img')\n\t            if helo1 is not None:\n\t                # do some thing you need\n\t                img_url = helo1['src']\n\t                self.saveImg(img_url, path)\n\t\n\t    def mkdir(self, path):  ##这个函数创建文件夹\n\t        path = path.strip()\n\t        if path.__contains__(\"妲己\"):\n\t            return False\n\t        isExists = os.path.exists(os.path.join(\"e:\\\\pic\\\\\", path))\n\t        if not isExists:\n\t            os.makedirs(os.path.join(\"e:\\\\pic\\\\\", path))\n\t            return True\n\t        else:\n\t            return False\n\t\n\t    def request(self, url):  ##这个函数获取网页的response 然后返回\n\t        headers = {\n\t            'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}\n\t        content = requests.get(url, headers=headers)\n\t\n\t        return content\n\t\n\t    def saveImg(self, url, path):\n\t        getHeaders = {\n\t            'Host': 'i.meizitu.net',\n\t            'Connection': 'Keep-Alive',\n\t            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36',\n\t            'Referer': 'http://www.mzitu.com/',\n\t            'Accept-Encoding': 'gzip, deflate',\n\t            'Accept-Language': 'zh-CN,zh;q=0.9'\n\t        }\n\t\n\t        response = requests.get(url, headers=getHeaders)\n\t        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n\t            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n\t            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n\t                name = url[-9:-4]\n\t                redirectUrl = response.headers['location']  # 因此需在响应头文件中获取重定向后地址\n\t                response = requests.get(redirectUrl)\n\t                fp = open(name + \".jpg\", 'ab')\n\t                fp.write(response.content)\n\t                fp.close()\n\t        else:\n\t            os.chdir(path)\n\t            name = url[-9:-4]\n\t            fp = open(name + \".jpg\", 'ab')\n\t            fp.write(response.content)\n\t            fp.close()\n\t            self.picNum = self.picNum + 1\n\t            print(self.picNum)\n\t            \n\tMzitu = mzitu()  ##实例化\n\tMzitu.all_url('http://www.mzitu.com/all')  ##给函数all_url传入参数  你可以当作启动爬虫（就是入口）\n\n\n\n\n\n\n\n       \n\n\n\n\n","slug":"python抓妹子","published":1,"updated":"2018-02-06T08:54:07.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje5iguxf000h8gietolj48bm","content":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/helo004.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"文章简介\"><a href=\"#文章简介\" class=\"headerlink\" title=\"文章简介\"></a>文章简介</h3><p><strong>本文将介绍如何使用python对www.mzitu.com中所有的图片的爬取以及存储到本地最后我们会得到如下图1所示</strong></p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206142745.png\" alt=\"enter image description here\"></p>\n<p>是不是很心动，接下来就让我们开始python爬虫之旅，本期内容将会从单线程使用到多线程，从自己写python到使用scrapy包，以及分布式redis的使用，当然这些都是后话了，当前我们的目标是要爬去这个网站上的美图。</p>\n<h3 id=\"环境介绍\"><a href=\"#环境介绍\" class=\"headerlink\" title=\"环境介绍\"></a>环境介绍</h3><p>废话少说接下来就是我们的基础环境部分<br><strong>1.Python – 3.6.1</strong>（这个版本其实要区别的就是python2和python3啦，我使用的python3）</p>\n<p><strong>2.Requests</strong> （看名字就知道这个是用来进行网络请求用的，这里的request是rllib包中的，之后我们要学的scrapy中也有自己想要的request，到时候两个不要搞混了）</p>\n<p><strong>3.beautifulsoup</strong> （当然数据获取到了之后，我们要对数据进行提取，解析就是通过beautifulsoup来进行，当然我们自己也可通过正则表达式来对数据进行过滤，如果你的正则水平不错的情况下） </p>\n<p><strong>4.LXML</strong> 一个HTML解析包 用于辅助beautifulsoup解析网页  </p>\n<hr>\n<p><strong>上面的模块需要 单独安装，下面几个就不用啦。</strong></p>\n<hr>\n<p><strong>5.OS 系统内置模块</strong> （这个玩意是系统内置的，在本文中我们通过它来将图片存储在本地）</p>\n<p><strong>6.PyCharm</strong>   一个草鸡好用的PythonIDE工具 、真滴。</p>\n<h3 id=\"模块的安装\"><a href=\"#模块的安装\" class=\"headerlink\" title=\"模块的安装\"></a>模块的安装</h3><p>再使用pip指令之前我们需要安装python。（如果我们安装python时选择<strong>不将</strong>python写入环境变量的话，那么我们还需要将“文件夹\\python36”和“文件夹\\python36\\Scripts”写入path中，这样我们才能在控制台中使用python和pip指令）</p>\n<p><strong>接下来就用指令安装模块</strong></p>\n<pre><code>pip install requests   \npip install beautifulsoup4  \npip install lxml\n</code></pre><p>大致结果就如下图所示<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206150606.png\" alt=\"enter image description here\"></p>\n<p>当python + 3个模块 + PyCharm安装完成之后我们就可以开始我们本次抓取的代码编写了。</p>\n<h3 id=\"爬虫编写\"><a href=\"#爬虫编写\" class=\"headerlink\" title=\"爬虫编写\"></a>爬虫编写</h3><p><strong>首先我们先整理一下爬图片的步骤：</strong></p>\n<p>1.我们需要一个目标网站（www.mzitu.com）<br>2.我们需要从一个网页中找出接下来要去的网页的链接地址，通过beautifulsoup来获取<br>3.获取网页中的图片地址<br>4.下载图片到本地</p>\n<p><strong>步骤1：</strong><br>www.mzitu.com网站的截图如下，这里选择了www.mzitu.com/all作为起始网页，因为在该网页中包含了网站中所有图片组图的链接链接地址<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160047.png\" alt=\"enter image description here\"></p>\n<p><strong>步骤2：</strong><br>推荐使用chrome浏览器来进行网页源码的查看<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160522.png\" alt=\"enter image description here\"></p>\n<p>通过观察我们可以发现接下来的链接地址在所在的<strong>href</strong>是被<strong>div class=all</strong>所包含着的，所有我们可以使用这一点来找到所有的url地址</p>\n<p><strong>步骤3：</strong><br>接下来我们就进入到某个链接里面去看图了<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161232.png\" alt=\"enter image description here\"><br>相应图片的地址被包含在<strong>div class=’main-image’</strong>中</p>\n<p>注意着个有一套图（一般她们拍写真都有很多张的），所以呢我们就看下接下来的这张图<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161358.png\" alt=\"enter image description here\"><br>着张图里的<strong>href</strong>就是套图里其他图片所在网页的地址了，有了这个我们就可以获取接下来的图片了，其中通过观察可以发现<strong>href</strong>被包在<strong>div class=‘pagenavi’</strong>中</p>\n<p><strong>步骤4：</strong><br><strong>开始代码编写</strong></p>\n<p>我们需要在代码中引入相应的模块</p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport os\n</code></pre><p>获取起始网页内容</p>\n<pre><code>html = self.request(url)\n</code></pre><p>这里的request是下面的这个方法</p>\n<pre><code>def request(self, url):  ##这个函数获取网页的response 然后返回\n    headers = {\n    &apos;User-Agent&apos;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}\n    content = requests.get(url, headers=headers)\n\n    return content\n</code></pre><p>获取步骤1中内容（也就是所有套图的地址），并进一步发送请求获取到套图首张图片所在网页</p>\n<pre><code>all_a = BeautifulSoup(html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;all&apos;).find_all(&apos;a&apos;)\nfor a in all_a:       \n    title = a.get_text() #取出a标签的文本       \n    href = a[&apos;href&apos;] #取出a标签的href 属性，也就是套图地址\n    self.html(href, &quot;e:\\\\pic\\\\&quot; + path)\n</code></pre><p>相应的html方法</p>\n<pre><code>def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n    html = self.request(href)\n    helo = BeautifulSoup(html.text, &apos;lxml&apos;).find_all(&apos;span&apos;)\n    if len(helo) &lt; 10:\n        return\n    max_span = helo[10].get_text()\n    for page in range(1, int(max_span) + 1):\n        page_url = href + &apos;/&apos; + str(page)\n        self.img(page_url, path)  ##调用img函数\n</code></pre><p>上面的html方法中的后半截是执行了步骤3中的后半部分，也就是遍历了套图中其他图片所在的网页，相应的img方法如下</p>\n<pre><code>def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n    img_html = self.request(page_url)\n    helo = BeautifulSoup(img_html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;main-image&apos;)\n    if helo is not None:\n        helo1 = helo.find(&apos;img&apos;)\n        if helo1 is not None:\n            # do some thing you need\n            img_url = helo1[&apos;src&apos;]\n            self.saveImg(img_url, path)\n\ndef saveImg(self, url, path):\n    getHeaders = {\n        &apos;Host&apos;: &apos;i.meizitu.net&apos;,\n        &apos;Connection&apos;: &apos;Keep-Alive&apos;,\n        &apos;Accept&apos;: &apos;image/webp,image/apng,image/*,*/*;q=0.8&apos;,\n        &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,\n        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;,\n        &apos;Referer&apos;: &apos;http://www.mzitu.com/&apos;,\n        &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,\n        &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9&apos;\n    }\n    response = requests.get(url, headers=getHeaders)\n\n    if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n        response = requests.get(url, headers=getHeaders, allow_redirects=False)\n        if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n            name = url[-9:-4]\n            redirectUrl = response.headers[&apos;location&apos;]  # 因此需在响应头文件中获取重定向后地址\n            response = requests.get(redirectUrl)\n            fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n            fp.write(response.content)\n            fp.close()\n    else:\n        os.chdir(path)\n        name = url[-9:-4]\n        fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n        fp.write(response.content)\n        fp.close()\n        self.picNum = self.picNum + 1\n        print(self.picNum)\n</code></pre><p>方法saveImg执行了步骤4，也就是将图片保存在了本地。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本片文字是在之前微信上看到的一篇文章改写的，当时照着那篇文字将代码写了一遍之后发现，保存在本地的图片都被篡改了，也就是被防盗链了，而后就只能修改request中的一些参数来确保准确性。在上面这些完成后，发现对爬虫有了一点的了解之后想着是不是可以使用多线程的方式来爬去，就又看了多线程的写法，下面贴出多线程的代码，这里使用的线程池。</p>\n<p><strong>多线程代码</strong></p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport os\nimport threading\nimport threadpool\n\n\nclass mzitu():\n    num = 0\n    picNum = 0\n\n    def all_url(self, url):\n        self.cv = threading.Condition()\n        html = self.request(url)  ##调用request函数把套图地址传进去会返回给我们一个response\n        all_a = BeautifulSoup(html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;all&apos;).find_all(&apos;a&apos;)\n\n        task_pool = threadpool.ThreadPool(50)\n        requests = threadpool.makeRequests(self.nice, all_a)\n        for req in requests:\n            task_pool.putRequest(req)\n        task_pool.wait()\n\n    def nice(self, a):\n        title = a.get_text()\n        path = str(title).replace(&quot;?&quot;, &apos;_&apos;)  ##我注意到有个标题带有 ？  这个符号Windows系统是不能创建文件夹的所以要替换掉\n        if self.mkdir(path):  ##调用mkdir函数创建文件夹！这儿path代表的是标题title哦！！！！！不要糊涂了哦！\n            os.chdir(&quot;e:\\\\pic\\\\&quot; + path)  ##切换到目录\n            href = a[&apos;href&apos;]\n            self.html(href, &quot;e:\\\\pic\\\\&quot; + path)  ##调用html函数把href参数传递过去！href是啥还记的吧？ 就是套图的地址哦！！不要迷糊了哦！\n\n    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n        html = self.request(href)\n        helo = BeautifulSoup(html.text, &apos;lxml&apos;).find_all(&apos;span&apos;)\n        if len(helo) &lt; 10:\n            return\n        max_span = helo[10].get_text()\n        for page in range(1, int(max_span) + 1):\n            page_url = href + &apos;/&apos; + str(page)\n            self.img(page_url, path)  ##调用img函数\n\n    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n        img_html = self.request(page_url)\n        helo = BeautifulSoup(img_html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;main-image&apos;)\n        if helo is not None:\n            helo1 = helo.find(&apos;img&apos;)\n            if helo1 is not None:\n                # do some thing you need\n                img_url = helo1[&apos;src&apos;]\n                self.saveImg(img_url, path)\n\n    def mkdir(self, path):  ##这个函数创建文件夹\n        path = path.strip()\n        if path.__contains__(&quot;妲己&quot;):\n            return False\n        isExists = os.path.exists(os.path.join(&quot;e:\\\\pic\\\\&quot;, path))\n        if not isExists:\n            os.makedirs(os.path.join(&quot;e:\\\\pic\\\\&quot;, path))\n            return True\n        else:\n            return False\n\n    def request(self, url):  ##这个函数获取网页的response 然后返回\n        headers = {\n            &apos;User-Agent&apos;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}\n        content = requests.get(url, headers=headers)\n\n        return content\n\n    def saveImg(self, url, path):\n        getHeaders = {\n            &apos;Host&apos;: &apos;i.meizitu.net&apos;,\n            &apos;Connection&apos;: &apos;Keep-Alive&apos;,\n            &apos;Accept&apos;: &apos;image/webp,image/apng,image/*,*/*;q=0.8&apos;,\n            &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,\n            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;,\n            &apos;Referer&apos;: &apos;http://www.mzitu.com/&apos;,\n            &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,\n            &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9&apos;\n        }\n\n        response = requests.get(url, headers=getHeaders)\n        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n                name = url[-9:-4]\n                redirectUrl = response.headers[&apos;location&apos;]  # 因此需在响应头文件中获取重定向后地址\n                response = requests.get(redirectUrl)\n                fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n                fp.write(response.content)\n                fp.close()\n        else:\n            os.chdir(path)\n            name = url[-9:-4]\n            fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n            fp.write(response.content)\n            fp.close()\n            self.picNum = self.picNum + 1\n            print(self.picNum)\n\nMzitu = mzitu()  ##实例化\nMzitu.all_url(&apos;http://www.mzitu.com/all&apos;)  ##给函数all_url传入参数  你可以当作启动爬虫（就是入口）\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/helo004.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"文章简介\"><a href=\"#文章简介\" class=\"headerlink\" title=\"文章简介\"></a>文章简介</h3><p><strong>本文将介绍如何使用python对www.mzitu.com中所有的图片的爬取以及存储到本地最后我们会得到如下图1所示</strong></p>\n<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206142745.png\" alt=\"enter image description here\"></p>\n<p>是不是很心动，接下来就让我们开始python爬虫之旅，本期内容将会从单线程使用到多线程，从自己写python到使用scrapy包，以及分布式redis的使用，当然这些都是后话了，当前我们的目标是要爬去这个网站上的美图。</p>\n<h3 id=\"环境介绍\"><a href=\"#环境介绍\" class=\"headerlink\" title=\"环境介绍\"></a>环境介绍</h3><p>废话少说接下来就是我们的基础环境部分<br><strong>1.Python – 3.6.1</strong>（这个版本其实要区别的就是python2和python3啦，我使用的python3）</p>\n<p><strong>2.Requests</strong> （看名字就知道这个是用来进行网络请求用的，这里的request是rllib包中的，之后我们要学的scrapy中也有自己想要的request，到时候两个不要搞混了）</p>\n<p><strong>3.beautifulsoup</strong> （当然数据获取到了之后，我们要对数据进行提取，解析就是通过beautifulsoup来进行，当然我们自己也可通过正则表达式来对数据进行过滤，如果你的正则水平不错的情况下） </p>\n<p><strong>4.LXML</strong> 一个HTML解析包 用于辅助beautifulsoup解析网页  </p>\n<hr>\n<p><strong>上面的模块需要 单独安装，下面几个就不用啦。</strong></p>\n<hr>\n<p><strong>5.OS 系统内置模块</strong> （这个玩意是系统内置的，在本文中我们通过它来将图片存储在本地）</p>\n<p><strong>6.PyCharm</strong>   一个草鸡好用的PythonIDE工具 、真滴。</p>\n<h3 id=\"模块的安装\"><a href=\"#模块的安装\" class=\"headerlink\" title=\"模块的安装\"></a>模块的安装</h3><p>再使用pip指令之前我们需要安装python。（如果我们安装python时选择<strong>不将</strong>python写入环境变量的话，那么我们还需要将“文件夹\\python36”和“文件夹\\python36\\Scripts”写入path中，这样我们才能在控制台中使用python和pip指令）</p>\n<p><strong>接下来就用指令安装模块</strong></p>\n<pre><code>pip install requests   \npip install beautifulsoup4  \npip install lxml\n</code></pre><p>大致结果就如下图所示<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206150606.png\" alt=\"enter image description here\"></p>\n<p>当python + 3个模块 + PyCharm安装完成之后我们就可以开始我们本次抓取的代码编写了。</p>\n<h3 id=\"爬虫编写\"><a href=\"#爬虫编写\" class=\"headerlink\" title=\"爬虫编写\"></a>爬虫编写</h3><p><strong>首先我们先整理一下爬图片的步骤：</strong></p>\n<p>1.我们需要一个目标网站（www.mzitu.com）<br>2.我们需要从一个网页中找出接下来要去的网页的链接地址，通过beautifulsoup来获取<br>3.获取网页中的图片地址<br>4.下载图片到本地</p>\n<p><strong>步骤1：</strong><br>www.mzitu.com网站的截图如下，这里选择了www.mzitu.com/all作为起始网页，因为在该网页中包含了网站中所有图片组图的链接链接地址<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160047.png\" alt=\"enter image description here\"></p>\n<p><strong>步骤2：</strong><br>推荐使用chrome浏览器来进行网页源码的查看<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206160522.png\" alt=\"enter image description here\"></p>\n<p>通过观察我们可以发现接下来的链接地址在所在的<strong>href</strong>是被<strong>div class=all</strong>所包含着的，所有我们可以使用这一点来找到所有的url地址</p>\n<p><strong>步骤3：</strong><br>接下来我们就进入到某个链接里面去看图了<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161232.png\" alt=\"enter image description here\"><br>相应图片的地址被包含在<strong>div class=’main-image’</strong>中</p>\n<p>注意着个有一套图（一般她们拍写真都有很多张的），所以呢我们就看下接下来的这张图<br><img src=\"http://op0dvu7tu.bkt.clouddn.com/%E4%BA%91%E4%B9%8B%E5%AE%B6%E5%9B%BE%E7%89%8720180206161358.png\" alt=\"enter image description here\"><br>着张图里的<strong>href</strong>就是套图里其他图片所在网页的地址了，有了这个我们就可以获取接下来的图片了，其中通过观察可以发现<strong>href</strong>被包在<strong>div class=‘pagenavi’</strong>中</p>\n<p><strong>步骤4：</strong><br><strong>开始代码编写</strong></p>\n<p>我们需要在代码中引入相应的模块</p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport os\n</code></pre><p>获取起始网页内容</p>\n<pre><code>html = self.request(url)\n</code></pre><p>这里的request是下面的这个方法</p>\n<pre><code>def request(self, url):  ##这个函数获取网页的response 然后返回\n    headers = {\n    &apos;User-Agent&apos;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}\n    content = requests.get(url, headers=headers)\n\n    return content\n</code></pre><p>获取步骤1中内容（也就是所有套图的地址），并进一步发送请求获取到套图首张图片所在网页</p>\n<pre><code>all_a = BeautifulSoup(html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;all&apos;).find_all(&apos;a&apos;)\nfor a in all_a:       \n    title = a.get_text() #取出a标签的文本       \n    href = a[&apos;href&apos;] #取出a标签的href 属性，也就是套图地址\n    self.html(href, &quot;e:\\\\pic\\\\&quot; + path)\n</code></pre><p>相应的html方法</p>\n<pre><code>def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n    html = self.request(href)\n    helo = BeautifulSoup(html.text, &apos;lxml&apos;).find_all(&apos;span&apos;)\n    if len(helo) &lt; 10:\n        return\n    max_span = helo[10].get_text()\n    for page in range(1, int(max_span) + 1):\n        page_url = href + &apos;/&apos; + str(page)\n        self.img(page_url, path)  ##调用img函数\n</code></pre><p>上面的html方法中的后半截是执行了步骤3中的后半部分，也就是遍历了套图中其他图片所在的网页，相应的img方法如下</p>\n<pre><code>def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n    img_html = self.request(page_url)\n    helo = BeautifulSoup(img_html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;main-image&apos;)\n    if helo is not None:\n        helo1 = helo.find(&apos;img&apos;)\n        if helo1 is not None:\n            # do some thing you need\n            img_url = helo1[&apos;src&apos;]\n            self.saveImg(img_url, path)\n\ndef saveImg(self, url, path):\n    getHeaders = {\n        &apos;Host&apos;: &apos;i.meizitu.net&apos;,\n        &apos;Connection&apos;: &apos;Keep-Alive&apos;,\n        &apos;Accept&apos;: &apos;image/webp,image/apng,image/*,*/*;q=0.8&apos;,\n        &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,\n        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;,\n        &apos;Referer&apos;: &apos;http://www.mzitu.com/&apos;,\n        &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,\n        &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9&apos;\n    }\n    response = requests.get(url, headers=getHeaders)\n\n    if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n        response = requests.get(url, headers=getHeaders, allow_redirects=False)\n        if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n            name = url[-9:-4]\n            redirectUrl = response.headers[&apos;location&apos;]  # 因此需在响应头文件中获取重定向后地址\n            response = requests.get(redirectUrl)\n            fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n            fp.write(response.content)\n            fp.close()\n    else:\n        os.chdir(path)\n        name = url[-9:-4]\n        fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n        fp.write(response.content)\n        fp.close()\n        self.picNum = self.picNum + 1\n        print(self.picNum)\n</code></pre><p>方法saveImg执行了步骤4，也就是将图片保存在了本地。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本片文字是在之前微信上看到的一篇文章改写的，当时照着那篇文字将代码写了一遍之后发现，保存在本地的图片都被篡改了，也就是被防盗链了，而后就只能修改request中的一些参数来确保准确性。在上面这些完成后，发现对爬虫有了一点的了解之后想着是不是可以使用多线程的方式来爬去，就又看了多线程的写法，下面贴出多线程的代码，这里使用的线程池。</p>\n<p><strong>多线程代码</strong></p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport os\nimport threading\nimport threadpool\n\n\nclass mzitu():\n    num = 0\n    picNum = 0\n\n    def all_url(self, url):\n        self.cv = threading.Condition()\n        html = self.request(url)  ##调用request函数把套图地址传进去会返回给我们一个response\n        all_a = BeautifulSoup(html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;all&apos;).find_all(&apos;a&apos;)\n\n        task_pool = threadpool.ThreadPool(50)\n        requests = threadpool.makeRequests(self.nice, all_a)\n        for req in requests:\n            task_pool.putRequest(req)\n        task_pool.wait()\n\n    def nice(self, a):\n        title = a.get_text()\n        path = str(title).replace(&quot;?&quot;, &apos;_&apos;)  ##我注意到有个标题带有 ？  这个符号Windows系统是不能创建文件夹的所以要替换掉\n        if self.mkdir(path):  ##调用mkdir函数创建文件夹！这儿path代表的是标题title哦！！！！！不要糊涂了哦！\n            os.chdir(&quot;e:\\\\pic\\\\&quot; + path)  ##切换到目录\n            href = a[&apos;href&apos;]\n            self.html(href, &quot;e:\\\\pic\\\\&quot; + path)  ##调用html函数把href参数传递过去！href是啥还记的吧？ 就是套图的地址哦！！不要迷糊了哦！\n\n    def html(self, href, path):  ##这个函数是处理套图地址获得图片的页面地址\n        html = self.request(href)\n        helo = BeautifulSoup(html.text, &apos;lxml&apos;).find_all(&apos;span&apos;)\n        if len(helo) &lt; 10:\n            return\n        max_span = helo[10].get_text()\n        for page in range(1, int(max_span) + 1):\n            page_url = href + &apos;/&apos; + str(page)\n            self.img(page_url, path)  ##调用img函数\n\n    def img(self, page_url, path):  ##这个函数处理图片页面地址获得图片的实际地址\n        img_html = self.request(page_url)\n        helo = BeautifulSoup(img_html.text, &apos;lxml&apos;).find(&apos;div&apos;, class_=&apos;main-image&apos;)\n        if helo is not None:\n            helo1 = helo.find(&apos;img&apos;)\n            if helo1 is not None:\n                # do some thing you need\n                img_url = helo1[&apos;src&apos;]\n                self.saveImg(img_url, path)\n\n    def mkdir(self, path):  ##这个函数创建文件夹\n        path = path.strip()\n        if path.__contains__(&quot;妲己&quot;):\n            return False\n        isExists = os.path.exists(os.path.join(&quot;e:\\\\pic\\\\&quot;, path))\n        if not isExists:\n            os.makedirs(os.path.join(&quot;e:\\\\pic\\\\&quot;, path))\n            return True\n        else:\n            return False\n\n    def request(self, url):  ##这个函数获取网页的response 然后返回\n        headers = {\n            &apos;User-Agent&apos;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;}\n        content = requests.get(url, headers=headers)\n\n        return content\n\n    def saveImg(self, url, path):\n        getHeaders = {\n            &apos;Host&apos;: &apos;i.meizitu.net&apos;,\n            &apos;Connection&apos;: &apos;Keep-Alive&apos;,\n            &apos;Accept&apos;: &apos;image/webp,image/apng,image/*,*/*;q=0.8&apos;,\n            &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,\n            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;,\n            &apos;Referer&apos;: &apos;http://www.mzitu.com/&apos;,\n            &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;,\n            &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.9&apos;\n        }\n\n        response = requests.get(url, headers=getHeaders)\n        if (response.status_code == 404):  # 若404错误，递归get，尝试非重定向方式获取\n            response = requests.get(url, headers=getHeaders, allow_redirects=False)\n            if (response.status_code == 302):  # 302表示访问对象已被移动到新位置，但仍按照原地址进行访问（造成404错误）。\n                name = url[-9:-4]\n                redirectUrl = response.headers[&apos;location&apos;]  # 因此需在响应头文件中获取重定向后地址\n                response = requests.get(redirectUrl)\n                fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n                fp.write(response.content)\n                fp.close()\n        else:\n            os.chdir(path)\n            name = url[-9:-4]\n            fp = open(name + &quot;.jpg&quot;, &apos;ab&apos;)\n            fp.write(response.content)\n            fp.close()\n            self.picNum = self.picNum + 1\n            print(self.picNum)\n\nMzitu = mzitu()  ##实例化\nMzitu.all_url(&apos;http://www.mzitu.com/all&apos;)  ##给函数all_url传入参数  你可以当作启动爬虫（就是入口）\n</code></pre>"},{"_content":"1.String、StringBuffer、StringBuilder\n\tStringBuffer的方法都是synchronized，并且是通过 value = Arrays.copyOf(value, newCapacity);扩大数组的容量的\n\n2.Hnadler\n\t它在使用的过程中主要与Messgae、MessageQueue、和Looper这三个对象关联密切，Handler机制的实现原理依赖于这三者。\n\n\t首先来看看Handler的几个常见的构造方法，分别是：\n\n\t\tHandler() 默认构造方法，与当前线程及其Looper实例绑定。如在主线程中执行new Handler()，那么该handler实例所绑定的便是 UI 线程和 UI 线程绑定的Looper实例。\n\n\t\tHandler(Handler.Callback callback) 与当前线程及其Looper实例绑定，同时调用一个callback接口（用于实现消息处理——即在callback中重写handleMessage()方法）\n\n\t\tHandler(Looper looper) 将该新建的handler实例与指定的looper对象绑定。\n\n\t\tpublic Handler(Looper looper, Callback callback, boolean async)\n\n\t接下来我们来看看Handler的作用，它允许我们将Message或Runnable对象发送到当前线程绑定的MessageQueue中，并通过Looper对象不断循环地从队列中获取Message或Runnable对象进行处理。因此，Handler有两个主要的用途:\n\n\t\t定时执行messages 和 runnables；\n\n\t\t在将一个action入队并在其他线程中执行；\n\n\t虽然Message的构造方法是public的，但实例化Message的最好方法是调用Message.obtain() 或 Handler.obtainMessage() ，因为这两个方法是从一个可回收利用的message对象回收池中获取Message实例。该回收池用于将每次交给handler处理的message对象进行回收。 \n\n\t同时，message并不是直接加入到MessageQueue中的, 而是通过与Looper对象相关联的MessageQueue.IdleHandler 对象来完成的。我们可以通过Looper.myQueue() 方法来获得当前线程的MessageQueue。 \n\n\tMessageQueue的中文翻译是消息队列，顾名思义，它的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。\n\n\tLooper是线程用来运行消息循环(message loop)的类。默认情况下，线程并没有与之关联的Looper，可以通过在线程中调用Looper.prepare() 方法来获取，并通过Looper.loop() 无限循环地获取并分发MessageQueue中的消息，直到所有消息全部处理。\n\n\tclass LooperThread extends Thread {\n      \tpublic Handler mHandler;\n\n      \tpublic void run() {\n\t        Looper.prepare();\n\n\t        mHandler = new Handler() {\n\t            public void handleMessage(Message msg) {\n\t                // process incoming messages here\n\t            }\n\t        };\n\n\t        Looper.loop();\n      \t}\n  \t}\n\n  \t在Handler的构造方法中使用：\n\t\tmLooper = Looper.myLooper();//获取当前线程中的looper\n\t\tif (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread that has not called Looper.prepare()\");\n        }\n\n    首先是Looper.prepare()方法：\n    \tsThreadLocal.set(new Looper(quitAllowed))//sThreadLocal是一个本地线程存储类，所有线程共享这个对象，但是这个对象对每一个线程而言却具有不同的值，且每个线程对这个对象的访问或修改都不会影响到\n    \t\t\t\t\t\t\t\t\t\t\t\t其他线程，即它的值对于每个线程来说都是独立的。 \n    Looper构造方法：\t\t\t\t\t\t\t\t\t\t\t\n\t    private Looper(boolean quitAllowed) {\n\t\t    mQueue = new MessageQueue(quitAllowed);\n\t\t    mThread = Thread.currentThread();\n\t\t}\n\n\t在handler的构造方法中使用，获取当前线程的looper\n\t    public static Looper myLooper() {\n\t        return sThreadLocal.get();\n\t    }\n\n\t使用Looper.loop()方法开启一个死循环，不断地调用queue.next()从消息队列中获取消息\n\n\n\t不断地调用queue.next()从消息队列中获取消息：\n\n\t\t其实就是取出单链表（我们前面已说过，MessageQueue其实是一个单链表结构）中的头结点，然后修改对应指针，再返回取到的头结点而已。因为这里采用的是无限循环，所以可能会有个疑问：该循环会不会特别消耗CPU资源？其实并不会，如果messageQueue有消息，自然是继续取消息；如果已经没有消息了，此时该线程便会阻塞在该next()方法的nativePollOnce() 方法中，主线程便会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生时，才通过往pipe管道写端写入数据来唤醒主线程工作。这里涉及到的是Linux的pipe/epoll机制，epoll机制是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。\n\n\n\t获取到待处理的message后通过msg.target.dispatchMessage(msg)进行消息分发，直到队列为空。这里的msg.target指的就是该Looper绑定的Handler实例，而在dispatchMessage(msg)方法中涉及到三个方法，如下：\n\n\t\tpublic void More dispatchMessage(Message msg) {\n\t        if (msg.callback != null) {\n\t            handleCallback(msg);\n\t        } else {\n\t            if (mCallback != null) {\n\t                if (mCallback.handleMessage(msg)) {\n\t                    return;\n\t                }\n\t            }\n\t            handleMessage(msg);\n\t        }\n\t    }\n","source":"_posts/面试题5.md","raw":"1.String、StringBuffer、StringBuilder\n\tStringBuffer的方法都是synchronized，并且是通过 value = Arrays.copyOf(value, newCapacity);扩大数组的容量的\n\n2.Hnadler\n\t它在使用的过程中主要与Messgae、MessageQueue、和Looper这三个对象关联密切，Handler机制的实现原理依赖于这三者。\n\n\t首先来看看Handler的几个常见的构造方法，分别是：\n\n\t\tHandler() 默认构造方法，与当前线程及其Looper实例绑定。如在主线程中执行new Handler()，那么该handler实例所绑定的便是 UI 线程和 UI 线程绑定的Looper实例。\n\n\t\tHandler(Handler.Callback callback) 与当前线程及其Looper实例绑定，同时调用一个callback接口（用于实现消息处理——即在callback中重写handleMessage()方法）\n\n\t\tHandler(Looper looper) 将该新建的handler实例与指定的looper对象绑定。\n\n\t\tpublic Handler(Looper looper, Callback callback, boolean async)\n\n\t接下来我们来看看Handler的作用，它允许我们将Message或Runnable对象发送到当前线程绑定的MessageQueue中，并通过Looper对象不断循环地从队列中获取Message或Runnable对象进行处理。因此，Handler有两个主要的用途:\n\n\t\t定时执行messages 和 runnables；\n\n\t\t在将一个action入队并在其他线程中执行；\n\n\t虽然Message的构造方法是public的，但实例化Message的最好方法是调用Message.obtain() 或 Handler.obtainMessage() ，因为这两个方法是从一个可回收利用的message对象回收池中获取Message实例。该回收池用于将每次交给handler处理的message对象进行回收。 \n\n\t同时，message并不是直接加入到MessageQueue中的, 而是通过与Looper对象相关联的MessageQueue.IdleHandler 对象来完成的。我们可以通过Looper.myQueue() 方法来获得当前线程的MessageQueue。 \n\n\tMessageQueue的中文翻译是消息队列，顾名思义，它的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。\n\n\tLooper是线程用来运行消息循环(message loop)的类。默认情况下，线程并没有与之关联的Looper，可以通过在线程中调用Looper.prepare() 方法来获取，并通过Looper.loop() 无限循环地获取并分发MessageQueue中的消息，直到所有消息全部处理。\n\n\tclass LooperThread extends Thread {\n      \tpublic Handler mHandler;\n\n      \tpublic void run() {\n\t        Looper.prepare();\n\n\t        mHandler = new Handler() {\n\t            public void handleMessage(Message msg) {\n\t                // process incoming messages here\n\t            }\n\t        };\n\n\t        Looper.loop();\n      \t}\n  \t}\n\n  \t在Handler的构造方法中使用：\n\t\tmLooper = Looper.myLooper();//获取当前线程中的looper\n\t\tif (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread that has not called Looper.prepare()\");\n        }\n\n    首先是Looper.prepare()方法：\n    \tsThreadLocal.set(new Looper(quitAllowed))//sThreadLocal是一个本地线程存储类，所有线程共享这个对象，但是这个对象对每一个线程而言却具有不同的值，且每个线程对这个对象的访问或修改都不会影响到\n    \t\t\t\t\t\t\t\t\t\t\t\t其他线程，即它的值对于每个线程来说都是独立的。 \n    Looper构造方法：\t\t\t\t\t\t\t\t\t\t\t\n\t    private Looper(boolean quitAllowed) {\n\t\t    mQueue = new MessageQueue(quitAllowed);\n\t\t    mThread = Thread.currentThread();\n\t\t}\n\n\t在handler的构造方法中使用，获取当前线程的looper\n\t    public static Looper myLooper() {\n\t        return sThreadLocal.get();\n\t    }\n\n\t使用Looper.loop()方法开启一个死循环，不断地调用queue.next()从消息队列中获取消息\n\n\n\t不断地调用queue.next()从消息队列中获取消息：\n\n\t\t其实就是取出单链表（我们前面已说过，MessageQueue其实是一个单链表结构）中的头结点，然后修改对应指针，再返回取到的头结点而已。因为这里采用的是无限循环，所以可能会有个疑问：该循环会不会特别消耗CPU资源？其实并不会，如果messageQueue有消息，自然是继续取消息；如果已经没有消息了，此时该线程便会阻塞在该next()方法的nativePollOnce() 方法中，主线程便会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生时，才通过往pipe管道写端写入数据来唤醒主线程工作。这里涉及到的是Linux的pipe/epoll机制，epoll机制是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。\n\n\n\t获取到待处理的message后通过msg.target.dispatchMessage(msg)进行消息分发，直到队列为空。这里的msg.target指的就是该Looper绑定的Handler实例，而在dispatchMessage(msg)方法中涉及到三个方法，如下：\n\n\t\tpublic void More dispatchMessage(Message msg) {\n\t        if (msg.callback != null) {\n\t            handleCallback(msg);\n\t        } else {\n\t            if (mCallback != null) {\n\t                if (mCallback.handleMessage(msg)) {\n\t                    return;\n\t                }\n\t            }\n\t            handleMessage(msg);\n\t        }\n\t    }\n","slug":"面试题5","published":1,"date":"2018-02-28T10:18:46.309Z","updated":"2018-02-28T03:28:05.913Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cje6xi68u00002wieee9bcgpi","content":"<p>1.String、StringBuffer、StringBuilder<br>    StringBuffer的方法都是synchronized，并且是通过 value = Arrays.copyOf(value, newCapacity);扩大数组的容量的</p>\n<p>2.Hnadler<br>    它在使用的过程中主要与Messgae、MessageQueue、和Looper这三个对象关联密切，Handler机制的实现原理依赖于这三者。</p>\n<pre><code>首先来看看Handler的几个常见的构造方法，分别是：\n\n    Handler() 默认构造方法，与当前线程及其Looper实例绑定。如在主线程中执行new Handler()，那么该handler实例所绑定的便是 UI 线程和 UI 线程绑定的Looper实例。\n\n    Handler(Handler.Callback callback) 与当前线程及其Looper实例绑定，同时调用一个callback接口（用于实现消息处理——即在callback中重写handleMessage()方法）\n\n    Handler(Looper looper) 将该新建的handler实例与指定的looper对象绑定。\n\n    public Handler(Looper looper, Callback callback, boolean async)\n\n接下来我们来看看Handler的作用，它允许我们将Message或Runnable对象发送到当前线程绑定的MessageQueue中，并通过Looper对象不断循环地从队列中获取Message或Runnable对象进行处理。因此，Handler有两个主要的用途:\n\n    定时执行messages 和 runnables；\n\n    在将一个action入队并在其他线程中执行；\n\n虽然Message的构造方法是public的，但实例化Message的最好方法是调用Message.obtain() 或 Handler.obtainMessage() ，因为这两个方法是从一个可回收利用的message对象回收池中获取Message实例。该回收池用于将每次交给handler处理的message对象进行回收。 \n\n同时，message并不是直接加入到MessageQueue中的, 而是通过与Looper对象相关联的MessageQueue.IdleHandler 对象来完成的。我们可以通过Looper.myQueue() 方法来获得当前线程的MessageQueue。 \n\nMessageQueue的中文翻译是消息队列，顾名思义，它的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。\n\nLooper是线程用来运行消息循环(message loop)的类。默认情况下，线程并没有与之关联的Looper，可以通过在线程中调用Looper.prepare() 方法来获取，并通过Looper.loop() 无限循环地获取并分发MessageQueue中的消息，直到所有消息全部处理。\n\nclass LooperThread extends Thread {\n      public Handler mHandler;\n\n      public void run() {\n        Looper.prepare();\n\n        mHandler = new Handler() {\n            public void handleMessage(Message msg) {\n                // process incoming messages here\n            }\n        };\n\n        Looper.loop();\n      }\n  }\n\n  在Handler的构造方法中使用：\n    mLooper = Looper.myLooper();//获取当前线程中的looper\n    if (mLooper == null) {\n        throw new RuntimeException(\n            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);\n    }\n\n首先是Looper.prepare()方法：\n    sThreadLocal.set(new Looper(quitAllowed))//sThreadLocal是一个本地线程存储类，所有线程共享这个对象，但是这个对象对每一个线程而言却具有不同的值，且每个线程对这个对象的访问或修改都不会影响到\n                                                其他线程，即它的值对于每个线程来说都是独立的。 \nLooper构造方法：                                            \n    private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n\n在handler的构造方法中使用，获取当前线程的looper\n    public static Looper myLooper() {\n        return sThreadLocal.get();\n    }\n\n使用Looper.loop()方法开启一个死循环，不断地调用queue.next()从消息队列中获取消息\n\n\n不断地调用queue.next()从消息队列中获取消息：\n\n    其实就是取出单链表（我们前面已说过，MessageQueue其实是一个单链表结构）中的头结点，然后修改对应指针，再返回取到的头结点而已。因为这里采用的是无限循环，所以可能会有个疑问：该循环会不会特别消耗CPU资源？其实并不会，如果messageQueue有消息，自然是继续取消息；如果已经没有消息了，此时该线程便会阻塞在该next()方法的nativePollOnce() 方法中，主线程便会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生时，才通过往pipe管道写端写入数据来唤醒主线程工作。这里涉及到的是Linux的pipe/epoll机制，epoll机制是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。\n\n\n获取到待处理的message后通过msg.target.dispatchMessage(msg)进行消息分发，直到队列为空。这里的msg.target指的就是该Looper绑定的Handler实例，而在dispatchMessage(msg)方法中涉及到三个方法，如下：\n\n    public void More dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>1.String、StringBuffer、StringBuilder<br>    StringBuffer的方法都是synchronized，并且是通过 value = Arrays.copyOf(value, newCapacity);扩大数组的容量的</p>\n<p>2.Hnadler<br>    它在使用的过程中主要与Messgae、MessageQueue、和Looper这三个对象关联密切，Handler机制的实现原理依赖于这三者。</p>\n<pre><code>首先来看看Handler的几个常见的构造方法，分别是：\n\n    Handler() 默认构造方法，与当前线程及其Looper实例绑定。如在主线程中执行new Handler()，那么该handler实例所绑定的便是 UI 线程和 UI 线程绑定的Looper实例。\n\n    Handler(Handler.Callback callback) 与当前线程及其Looper实例绑定，同时调用一个callback接口（用于实现消息处理——即在callback中重写handleMessage()方法）\n\n    Handler(Looper looper) 将该新建的handler实例与指定的looper对象绑定。\n\n    public Handler(Looper looper, Callback callback, boolean async)\n\n接下来我们来看看Handler的作用，它允许我们将Message或Runnable对象发送到当前线程绑定的MessageQueue中，并通过Looper对象不断循环地从队列中获取Message或Runnable对象进行处理。因此，Handler有两个主要的用途:\n\n    定时执行messages 和 runnables；\n\n    在将一个action入队并在其他线程中执行；\n\n虽然Message的构造方法是public的，但实例化Message的最好方法是调用Message.obtain() 或 Handler.obtainMessage() ，因为这两个方法是从一个可回收利用的message对象回收池中获取Message实例。该回收池用于将每次交给handler处理的message对象进行回收。 \n\n同时，message并不是直接加入到MessageQueue中的, 而是通过与Looper对象相关联的MessageQueue.IdleHandler 对象来完成的。我们可以通过Looper.myQueue() 方法来获得当前线程的MessageQueue。 \n\nMessageQueue的中文翻译是消息队列，顾名思义，它的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。\n\nLooper是线程用来运行消息循环(message loop)的类。默认情况下，线程并没有与之关联的Looper，可以通过在线程中调用Looper.prepare() 方法来获取，并通过Looper.loop() 无限循环地获取并分发MessageQueue中的消息，直到所有消息全部处理。\n\nclass LooperThread extends Thread {\n      public Handler mHandler;\n\n      public void run() {\n        Looper.prepare();\n\n        mHandler = new Handler() {\n            public void handleMessage(Message msg) {\n                // process incoming messages here\n            }\n        };\n\n        Looper.loop();\n      }\n  }\n\n  在Handler的构造方法中使用：\n    mLooper = Looper.myLooper();//获取当前线程中的looper\n    if (mLooper == null) {\n        throw new RuntimeException(\n            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);\n    }\n\n首先是Looper.prepare()方法：\n    sThreadLocal.set(new Looper(quitAllowed))//sThreadLocal是一个本地线程存储类，所有线程共享这个对象，但是这个对象对每一个线程而言却具有不同的值，且每个线程对这个对象的访问或修改都不会影响到\n                                                其他线程，即它的值对于每个线程来说都是独立的。 \nLooper构造方法：                                            \n    private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n\n在handler的构造方法中使用，获取当前线程的looper\n    public static Looper myLooper() {\n        return sThreadLocal.get();\n    }\n\n使用Looper.loop()方法开启一个死循环，不断地调用queue.next()从消息队列中获取消息\n\n\n不断地调用queue.next()从消息队列中获取消息：\n\n    其实就是取出单链表（我们前面已说过，MessageQueue其实是一个单链表结构）中的头结点，然后修改对应指针，再返回取到的头结点而已。因为这里采用的是无限循环，所以可能会有个疑问：该循环会不会特别消耗CPU资源？其实并不会，如果messageQueue有消息，自然是继续取消息；如果已经没有消息了，此时该线程便会阻塞在该next()方法的nativePollOnce() 方法中，主线程便会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生时，才通过往pipe管道写端写入数据来唤醒主线程工作。这里涉及到的是Linux的pipe/epoll机制，epoll机制是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。\n\n\n获取到待处理的message后通过msg.target.dispatchMessage(msg)进行消息分发，直到队列为空。这里的msg.target指的就是该Looper绑定的Handler实例，而在dispatchMessage(msg)方法中涉及到三个方法，如下：\n\n    public void More dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n</code></pre>"},{"_content":"1.高效加载大图片\n\n\tBitmapFactory.Options options = new BitmapFactory.Options();  \n\toptions.inJustDecodeBounds = true;  \n\tBitmapFactory.decodeResource(getResources(), R.id.myimage, options);  \n\tint imageHeight = options.outHeight;  \n\tint imageWidth = options.outWidth;  \n\tString imageType = options.outMimeType;  \n\n\t那我们怎样才能对图片进行压缩呢？通过设置BitmapFactory.Options中inSampleSize的值就可以实现。\n\n\tpublic static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,  \n        int reqWidth, int reqHeight) {  \n\t    // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小  \n\t    final BitmapFactory.Options options = new BitmapFactory.Options();  \n\t    options.inJustDecodeBounds = true;  \n\t    BitmapFactory.decodeResource(res, resId, options);  \n\t    // 调用上面定义的方法计算inSampleSize值  \n\t    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);  \n\t    // 使用获取到的inSampleSize值再次解析图片  \n\t    options.inJustDecodeBounds = false;  \n\t    return BitmapFactory.decodeResource(res, resId, options);  \n\t}  \n\n\n2.map的内部实现\n\tSet<Map.Entry<K, V>> entrySet();\n\tIterator<Entry<K,V>> i = entrySet().iterator();\n\n\n3.Android 中Serializable与Parcelable区别？\n\t两种都是用于支持序列化、反序列化话操作，两者最大的区别在于存储媒介的不同，Serializable使用IO读写存储在硬盘上，而Parcelable是直接在内存中读写，很明显内存的读写速度通常大于IO读写，所以在Android中通常优先选择Parcelable。\n\n\t1.       整个读写全是在内存中进行，主要是通过malloc()、realloc()、memcpy()等内存操作进行，所以效率比JAVA序列化中使用外部存储器会高很多；\n\n\t2.       读写时是4字节对齐的，可以看到#define PAD_SIZE(s) (((s)+3)&~3)这句宏定义就是在做这件事情；\n\n\t3.       如果预分配的空间不够时newSize = ((mDataSize+len)*3)/2;会一次多分配50%；\n\n\t4.       对于普通数据，使用的是mData内存地址，对于IBinder类型的数据以及FileDescriptor使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder()\n\t\t\t 实现的，目的是反序列化时读出的对象就是原对象而不用重新new一个新对象。\n\n\n    public static final Parcelable.Creator<MyColor> CREATOR  \n        = new Parcelable.Creator<MyColor>() {  \n        public MyColor createFromParcel(Parcel in) {  \n            return new MyColor(in);  \n        }  \n          \n        public MyColor[] newArray(int size) {  \n            return new MyColor[size];  \n        }  \n    };  \n\n\n    MyColor(Parcel in){  \n        color=in.readInt();  \n    }  \n\n\n    @Override  \n    public void writeToParcel(Parcel dest, int flags) {  \n        dest.writeInt(color);  \n    }  \n\n\n4.Binder也与Parcel相关，都是使用的Parcel的write_和read_方法\n\n\thttp://www.cnblogs.com/zhangxinyan/p/3487909.html\n\n\t客户端获取到的是proxy，服务端返回的是stub，这两者之间通过binder驱动来对应的\n\n\tublic static com.example.laozhu.aidl.Helo asInterface(proxy){\n\t\treturn new com.example.laozhu.aidl.Helo.Stub.Proxy(obj);\n\t}\n\n\t其实Binder驱动会在内核为process创建一個binder_proc 结构提，在binder_proc中保存着四个RB Tree。\n\t其中三个tree就是保存binder_ref和binder_node的。就是传递来传递去的代理对象和实体对象。\n\n\t一个tree保存binder_node；另外两个tree保存binder_ref,这两个tree的内容其实都一样，只是为了便于搜索，就建了两个不同key的tree。\n\n\t这三个tree都具体存写什么东西？\n\t\t-->这样说，一个process里有个实体对象，就有多少个binder_node；一个process有多少个代理对象指向远端，就有多少个binder_ref.\n\n\tProcessA向binder驱动传入一个handle，binder驱动就会根据handle在tree中找到对应的binder_ref。 binder_ref里面有一个node变量， 它就是对应的实体对象的node的地址，靠它找到对应的binder_node。然后在binder_node里面，也有一个变量：cookie，它就是BBinder的地址。找到BBinder就OK了。\n\n\t<img src=\"https://images0.cnblogs.com/blog/575077/201401/02143950-a36c34c4f1aa402cb41624c7d6956877.png\" alt=\"\">\n\n\n\n\tthis.attachInterface(this, DESCRIPTOR);\n\n\t而在onServiceConnected中的调用为：\n\n\tmService = IBookManager.Stub.asInterface(service);\n\n\t注意sercice为IBookManager.Stub，从而我们可以知道，\n\n\t我们即可以得出结论：同进程时，在onServiceConnection中获取到的是stub，而在不同进程中获取到的是binderProxy，该对象是在binder驱动中进行映射后的对象。\n\n\t共享内存块","source":"_posts/面试题6.md","raw":"1.高效加载大图片\n\n\tBitmapFactory.Options options = new BitmapFactory.Options();  \n\toptions.inJustDecodeBounds = true;  \n\tBitmapFactory.decodeResource(getResources(), R.id.myimage, options);  \n\tint imageHeight = options.outHeight;  \n\tint imageWidth = options.outWidth;  \n\tString imageType = options.outMimeType;  \n\n\t那我们怎样才能对图片进行压缩呢？通过设置BitmapFactory.Options中inSampleSize的值就可以实现。\n\n\tpublic static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,  \n        int reqWidth, int reqHeight) {  \n\t    // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小  \n\t    final BitmapFactory.Options options = new BitmapFactory.Options();  \n\t    options.inJustDecodeBounds = true;  \n\t    BitmapFactory.decodeResource(res, resId, options);  \n\t    // 调用上面定义的方法计算inSampleSize值  \n\t    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);  \n\t    // 使用获取到的inSampleSize值再次解析图片  \n\t    options.inJustDecodeBounds = false;  \n\t    return BitmapFactory.decodeResource(res, resId, options);  \n\t}  \n\n\n2.map的内部实现\n\tSet<Map.Entry<K, V>> entrySet();\n\tIterator<Entry<K,V>> i = entrySet().iterator();\n\n\n3.Android 中Serializable与Parcelable区别？\n\t两种都是用于支持序列化、反序列化话操作，两者最大的区别在于存储媒介的不同，Serializable使用IO读写存储在硬盘上，而Parcelable是直接在内存中读写，很明显内存的读写速度通常大于IO读写，所以在Android中通常优先选择Parcelable。\n\n\t1.       整个读写全是在内存中进行，主要是通过malloc()、realloc()、memcpy()等内存操作进行，所以效率比JAVA序列化中使用外部存储器会高很多；\n\n\t2.       读写时是4字节对齐的，可以看到#define PAD_SIZE(s) (((s)+3)&~3)这句宏定义就是在做这件事情；\n\n\t3.       如果预分配的空间不够时newSize = ((mDataSize+len)*3)/2;会一次多分配50%；\n\n\t4.       对于普通数据，使用的是mData内存地址，对于IBinder类型的数据以及FileDescriptor使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder()\n\t\t\t 实现的，目的是反序列化时读出的对象就是原对象而不用重新new一个新对象。\n\n\n    public static final Parcelable.Creator<MyColor> CREATOR  \n        = new Parcelable.Creator<MyColor>() {  \n        public MyColor createFromParcel(Parcel in) {  \n            return new MyColor(in);  \n        }  \n          \n        public MyColor[] newArray(int size) {  \n            return new MyColor[size];  \n        }  \n    };  \n\n\n    MyColor(Parcel in){  \n        color=in.readInt();  \n    }  \n\n\n    @Override  \n    public void writeToParcel(Parcel dest, int flags) {  \n        dest.writeInt(color);  \n    }  \n\n\n4.Binder也与Parcel相关，都是使用的Parcel的write_和read_方法\n\n\thttp://www.cnblogs.com/zhangxinyan/p/3487909.html\n\n\t客户端获取到的是proxy，服务端返回的是stub，这两者之间通过binder驱动来对应的\n\n\tublic static com.example.laozhu.aidl.Helo asInterface(proxy){\n\t\treturn new com.example.laozhu.aidl.Helo.Stub.Proxy(obj);\n\t}\n\n\t其实Binder驱动会在内核为process创建一個binder_proc 结构提，在binder_proc中保存着四个RB Tree。\n\t其中三个tree就是保存binder_ref和binder_node的。就是传递来传递去的代理对象和实体对象。\n\n\t一个tree保存binder_node；另外两个tree保存binder_ref,这两个tree的内容其实都一样，只是为了便于搜索，就建了两个不同key的tree。\n\n\t这三个tree都具体存写什么东西？\n\t\t-->这样说，一个process里有个实体对象，就有多少个binder_node；一个process有多少个代理对象指向远端，就有多少个binder_ref.\n\n\tProcessA向binder驱动传入一个handle，binder驱动就会根据handle在tree中找到对应的binder_ref。 binder_ref里面有一个node变量， 它就是对应的实体对象的node的地址，靠它找到对应的binder_node。然后在binder_node里面，也有一个变量：cookie，它就是BBinder的地址。找到BBinder就OK了。\n\n\t<img src=\"https://images0.cnblogs.com/blog/575077/201401/02143950-a36c34c4f1aa402cb41624c7d6956877.png\" alt=\"\">\n\n\n\n\tthis.attachInterface(this, DESCRIPTOR);\n\n\t而在onServiceConnected中的调用为：\n\n\tmService = IBookManager.Stub.asInterface(service);\n\n\t注意sercice为IBookManager.Stub，从而我们可以知道，\n\n\t我们即可以得出结论：同进程时，在onServiceConnection中获取到的是stub，而在不同进程中获取到的是binderProxy，该对象是在binder驱动中进行映射后的对象。\n\n\t共享内存块","slug":"面试题6","published":1,"date":"2018-02-28T10:18:46.315Z","updated":"2018-02-28T10:17:45.933Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cje6xi68z00012wiev2ionw81","content":"<p>1.高效加载大图片</p>\n<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();  \noptions.inJustDecodeBounds = true;  \nBitmapFactory.decodeResource(getResources(), R.id.myimage, options);  \nint imageHeight = options.outHeight;  \nint imageWidth = options.outWidth;  \nString imageType = options.outMimeType;  \n\n那我们怎样才能对图片进行压缩呢？通过设置BitmapFactory.Options中inSampleSize的值就可以实现。\n\npublic static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,  \n    int reqWidth, int reqHeight) {  \n    // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小  \n    final BitmapFactory.Options options = new BitmapFactory.Options();  \n    options.inJustDecodeBounds = true;  \n    BitmapFactory.decodeResource(res, resId, options);  \n    // 调用上面定义的方法计算inSampleSize值  \n    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);  \n    // 使用获取到的inSampleSize值再次解析图片  \n    options.inJustDecodeBounds = false;  \n    return BitmapFactory.decodeResource(res, resId, options);  \n}  \n</code></pre><p>2.map的内部实现<br>    Set&lt;Map.Entry<k, v=\"\">&gt; entrySet();<br>    Iterator&lt;Entry<k,v>&gt; i = entrySet().iterator();</k,v></k,></p>\n<p>3.Android 中Serializable与Parcelable区别？<br>    两种都是用于支持序列化、反序列化话操作，两者最大的区别在于存储媒介的不同，Serializable使用IO读写存储在硬盘上，而Parcelable是直接在内存中读写，很明显内存的读写速度通常大于IO读写，所以在Android中通常优先选择Parcelable。</p>\n<pre><code>1.       整个读写全是在内存中进行，主要是通过malloc()、realloc()、memcpy()等内存操作进行，所以效率比JAVA序列化中使用外部存储器会高很多；\n\n2.       读写时是4字节对齐的，可以看到#define PAD_SIZE(s) (((s)+3)&amp;~3)这句宏定义就是在做这件事情；\n\n3.       如果预分配的空间不够时newSize = ((mDataSize+len)*3)/2;会一次多分配50%；\n\n4.       对于普通数据，使用的是mData内存地址，对于IBinder类型的数据以及FileDescriptor使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder()\n         实现的，目的是反序列化时读出的对象就是原对象而不用重新new一个新对象。\n\n\npublic static final Parcelable.Creator&lt;MyColor&gt; CREATOR  \n    = new Parcelable.Creator&lt;MyColor&gt;() {  \n    public MyColor createFromParcel(Parcel in) {  \n        return new MyColor(in);  \n    }  \n\n    public MyColor[] newArray(int size) {  \n        return new MyColor[size];  \n    }  \n};  \n\n\nMyColor(Parcel in){  \n    color=in.readInt();  \n}  \n\n\n@Override  \npublic void writeToParcel(Parcel dest, int flags) {  \n    dest.writeInt(color);  \n}  \n</code></pre><p>4.Binder也与Parcel相关，都是使用的Parcel的write<em>和read</em>方法</p>\n<pre><code>http://www.cnblogs.com/zhangxinyan/p/3487909.html\n\n客户端获取到的是proxy，服务端返回的是stub，这两者之间通过binder驱动来对应的\n\nublic static com.example.laozhu.aidl.Helo asInterface(proxy){\n    return new com.example.laozhu.aidl.Helo.Stub.Proxy(obj);\n}\n\n其实Binder驱动会在内核为process创建一個binder_proc 结构提，在binder_proc中保存着四个RB Tree。\n其中三个tree就是保存binder_ref和binder_node的。就是传递来传递去的代理对象和实体对象。\n\n一个tree保存binder_node；另外两个tree保存binder_ref,这两个tree的内容其实都一样，只是为了便于搜索，就建了两个不同key的tree。\n\n这三个tree都具体存写什么东西？\n    --&gt;这样说，一个process里有个实体对象，就有多少个binder_node；一个process有多少个代理对象指向远端，就有多少个binder_ref.\n\nProcessA向binder驱动传入一个handle，binder驱动就会根据handle在tree中找到对应的binder_ref。 binder_ref里面有一个node变量， 它就是对应的实体对象的node的地址，靠它找到对应的binder_node。然后在binder_node里面，也有一个变量：cookie，它就是BBinder的地址。找到BBinder就OK了。\n\n&lt;img src=&quot;https://images0.cnblogs.com/blog/575077/201401/02143950-a36c34c4f1aa402cb41624c7d6956877.png&quot; alt=&quot;&quot;&gt;\n\n\n\nthis.attachInterface(this, DESCRIPTOR);\n\n而在onServiceConnected中的调用为：\n\nmService = IBookManager.Stub.asInterface(service);\n\n注意sercice为IBookManager.Stub，从而我们可以知道，\n\n我们即可以得出结论：同进程时，在onServiceConnection中获取到的是stub，而在不同进程中获取到的是binderProxy，该对象是在binder驱动中进行映射后的对象。\n\n共享内存块\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>1.高效加载大图片</p>\n<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();  \noptions.inJustDecodeBounds = true;  \nBitmapFactory.decodeResource(getResources(), R.id.myimage, options);  \nint imageHeight = options.outHeight;  \nint imageWidth = options.outWidth;  \nString imageType = options.outMimeType;  \n\n那我们怎样才能对图片进行压缩呢？通过设置BitmapFactory.Options中inSampleSize的值就可以实现。\n\npublic static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,  \n    int reqWidth, int reqHeight) {  \n    // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小  \n    final BitmapFactory.Options options = new BitmapFactory.Options();  \n    options.inJustDecodeBounds = true;  \n    BitmapFactory.decodeResource(res, resId, options);  \n    // 调用上面定义的方法计算inSampleSize值  \n    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);  \n    // 使用获取到的inSampleSize值再次解析图片  \n    options.inJustDecodeBounds = false;  \n    return BitmapFactory.decodeResource(res, resId, options);  \n}  \n</code></pre><p>2.map的内部实现<br>    Set&lt;Map.Entry<k, v=\"\">&gt; entrySet();<br>    Iterator&lt;Entry<k,v>&gt; i = entrySet().iterator();</k,v></k,></p>\n<p>3.Android 中Serializable与Parcelable区别？<br>    两种都是用于支持序列化、反序列化话操作，两者最大的区别在于存储媒介的不同，Serializable使用IO读写存储在硬盘上，而Parcelable是直接在内存中读写，很明显内存的读写速度通常大于IO读写，所以在Android中通常优先选择Parcelable。</p>\n<pre><code>1.       整个读写全是在内存中进行，主要是通过malloc()、realloc()、memcpy()等内存操作进行，所以效率比JAVA序列化中使用外部存储器会高很多；\n\n2.       读写时是4字节对齐的，可以看到#define PAD_SIZE(s) (((s)+3)&amp;~3)这句宏定义就是在做这件事情；\n\n3.       如果预分配的空间不够时newSize = ((mDataSize+len)*3)/2;会一次多分配50%；\n\n4.       对于普通数据，使用的是mData内存地址，对于IBinder类型的数据以及FileDescriptor使用的是mObjects内存地址。后者是通过flatten_binder()和unflatten_binder()\n         实现的，目的是反序列化时读出的对象就是原对象而不用重新new一个新对象。\n\n\npublic static final Parcelable.Creator&lt;MyColor&gt; CREATOR  \n    = new Parcelable.Creator&lt;MyColor&gt;() {  \n    public MyColor createFromParcel(Parcel in) {  \n        return new MyColor(in);  \n    }  \n\n    public MyColor[] newArray(int size) {  \n        return new MyColor[size];  \n    }  \n};  \n\n\nMyColor(Parcel in){  \n    color=in.readInt();  \n}  \n\n\n@Override  \npublic void writeToParcel(Parcel dest, int flags) {  \n    dest.writeInt(color);  \n}  \n</code></pre><p>4.Binder也与Parcel相关，都是使用的Parcel的write<em>和read</em>方法</p>\n<pre><code>http://www.cnblogs.com/zhangxinyan/p/3487909.html\n\n客户端获取到的是proxy，服务端返回的是stub，这两者之间通过binder驱动来对应的\n\nublic static com.example.laozhu.aidl.Helo asInterface(proxy){\n    return new com.example.laozhu.aidl.Helo.Stub.Proxy(obj);\n}\n\n其实Binder驱动会在内核为process创建一個binder_proc 结构提，在binder_proc中保存着四个RB Tree。\n其中三个tree就是保存binder_ref和binder_node的。就是传递来传递去的代理对象和实体对象。\n\n一个tree保存binder_node；另外两个tree保存binder_ref,这两个tree的内容其实都一样，只是为了便于搜索，就建了两个不同key的tree。\n\n这三个tree都具体存写什么东西？\n    --&gt;这样说，一个process里有个实体对象，就有多少个binder_node；一个process有多少个代理对象指向远端，就有多少个binder_ref.\n\nProcessA向binder驱动传入一个handle，binder驱动就会根据handle在tree中找到对应的binder_ref。 binder_ref里面有一个node变量， 它就是对应的实体对象的node的地址，靠它找到对应的binder_node。然后在binder_node里面，也有一个变量：cookie，它就是BBinder的地址。找到BBinder就OK了。\n\n&lt;img src=&quot;https://images0.cnblogs.com/blog/575077/201401/02143950-a36c34c4f1aa402cb41624c7d6956877.png&quot; alt=&quot;&quot;&gt;\n\n\n\nthis.attachInterface(this, DESCRIPTOR);\n\n而在onServiceConnected中的调用为：\n\nmService = IBookManager.Stub.asInterface(service);\n\n注意sercice为IBookManager.Stub，从而我们可以知道，\n\n我们即可以得出结论：同进程时，在onServiceConnection中获取到的是stub，而在不同进程中获取到的是binderProxy，该对象是在binder驱动中进行映射后的对象。\n\n共享内存块\n</code></pre>"}],"PostAsset":[],"PostCategory":[{"post_id":"cje5iguwz00028giea4rawu2f","category_id":"cje5igux300048gie159j4x4k","_id":"cje5iguxe000e8gieyhrn4grl"},{"post_id":"cje5igux700088gieb58p22qv","category_id":"cje5igux300048gie159j4x4k","_id":"cje5iguxg000i8gieaqcxjxnd"},{"post_id":"cje5igux100038giej7apd2do","category_id":"cje5igux300048gie159j4x4k","_id":"cje5iguxg000j8gie8vclu2e6"},{"post_id":"cje5iguxa000b8gieovnvej7b","category_id":"cje5iguxe000g8gieg9njy156","_id":"cje5iguxj000p8gieqz6mfkp4"},{"post_id":"cje5iguxc000d8giegz6bajps","category_id":"cje5iguxi000l8gie2thkvamo","_id":"cje5iguxk000t8giegrbmkjlr"},{"post_id":"cje5iguxf000h8gietolj48bm","category_id":"cje5iguxe000g8gieg9njy156","_id":"cje5iguxl000v8gie7rhr070r"}],"PostTag":[{"post_id":"cje5igux700088gieb58p22qv","tag_id":"cje5igux500058giedo995tog","_id":"cje5iguxc000c8giegigwujep"},{"post_id":"cje5iguwz00028giea4rawu2f","tag_id":"cje5igux500058giedo995tog","_id":"cje5iguxi000m8gieap3u00s4"},{"post_id":"cje5iguwz00028giea4rawu2f","tag_id":"cje5igux8000a8gieyh2pqgmx","_id":"cje5iguxi000n8giex6chkp2b"},{"post_id":"cje5iguwz00028giea4rawu2f","tag_id":"cje5iguxe000f8gieh3am544o","_id":"cje5iguxj000r8gie5337pr3u"},{"post_id":"cje5igux100038giej7apd2do","tag_id":"cje5igux500058giedo995tog","_id":"cje5iguxl000w8gie5zolhunr"},{"post_id":"cje5igux100038giej7apd2do","tag_id":"cje5iguxj000o8giexulunp8d","_id":"cje5iguxl000x8gie0kqcjdfe"},{"post_id":"cje5igux100038giej7apd2do","tag_id":"cje5iguxe000f8gieh3am544o","_id":"cje5iguxl000z8gieah7tf2br"},{"post_id":"cje5iguxa000b8gieovnvej7b","tag_id":"cje5iguxk000u8gieo5ut01wy","_id":"cje5iguxm00128gieq0ujth9r"},{"post_id":"cje5iguxa000b8gieovnvej7b","tag_id":"cje5iguxl000y8giesy8bibbo","_id":"cje5iguxn00138gie15x5hw6k"},{"post_id":"cje5iguxa000b8gieovnvej7b","tag_id":"cje5iguxe000f8gieh3am544o","_id":"cje5iguxn00158giea70jubjz"},{"post_id":"cje5iguxc000d8giegz6bajps","tag_id":"cje5iguxm00118gieovctafht","_id":"cje5iguxo00188giedxidc38d"},{"post_id":"cje5iguxc000d8giegz6bajps","tag_id":"cje5iguxn00148gieuwiblwdp","_id":"cje5iguxo00198gie0bcqvpo2"},{"post_id":"cje5iguxc000d8giegz6bajps","tag_id":"cje5iguxe000f8gieh3am544o","_id":"cje5iguxp001b8gie5olb2cim"},{"post_id":"cje5iguxf000h8gietolj48bm","tag_id":"cje5iguxk000u8gieo5ut01wy","_id":"cje5iguxp001c8gienmeq5vra"},{"post_id":"cje5iguxf000h8gietolj48bm","tag_id":"cje5iguxl000y8giesy8bibbo","_id":"cje5iguxp001d8giem0nag8cm"},{"post_id":"cje5iguxf000h8gietolj48bm","tag_id":"cje5iguxe000f8gieh3am544o","_id":"cje5iguxp001e8giepqwhf7p3"}],"Tag":[{"name":"Android","_id":"cje5igux500058giedo995tog"},{"name":"测试","_id":"cje5igux8000a8gieyh2pqgmx"},{"name":"技术","_id":"cje5iguxe000f8gieh3am544o"},{"name":"三方框架","_id":"cje5iguxj000o8giexulunp8d"},{"name":"python","_id":"cje5iguxk000u8gieo5ut01wy"},{"name":"爬虫","_id":"cje5iguxl000y8giesy8bibbo"},{"name":"android","_id":"cje5iguxm00118gieovctafht"},{"name":"源码","_id":"cje5iguxn00148gieuwiblwdp"}]}}