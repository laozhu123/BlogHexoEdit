{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/LICENSE","hash":"4c3927c82d0aa4fac5cdf945e07afe5e24335891","modified":1517882480948},{"_id":"themes/BlueLake/README.en.md","hash":"6cc6e346635bf26dd71030b9c3c6443507cd4108","modified":1517882480948},{"_id":"themes/BlueLake/README.md","hash":"66c3ef7a779b6d65bad90daa2e03bcb7a1bb742f","modified":1517882480949},{"_id":"themes/BlueLake/_config.yml","hash":"5baf7e3dcf77588223fcbe662b07ad62023b43bf","modified":1517886451414},{"_id":"themes/BlueLake/package.json","hash":"cdef382c442618b24305fd3e38ac7a3accf87aa9","modified":1517882480956},{"_id":"source/_posts/Dagger2.md","hash":"8c80251aa30a26d45f38c7cb9529cc205e70bdd1","modified":1517887091223},{"_id":"source/_posts/Android自动化测试.md","hash":"c470bb1400eaf243979082cb2723918a4260e1ec","modified":1517887124962},{"_id":"themes/BlueLake/.git/config","hash":"05165d804714e9c1a0e5d4a99a95a77f34d4fac6","modified":1517882480943},{"_id":"themes/BlueLake/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1517882480940},{"_id":"themes/BlueLake/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1517882477479},{"_id":"themes/BlueLake/.git/index","hash":"fe3d8040723435f9b49be2f5605e66ddce03c3e7","modified":1517886833431},{"_id":"themes/BlueLake/.git/packed-refs","hash":"842a64dcd40e108353d1da6314a0c447e35b921d","modified":1517882480937},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"d7f5842295509746f878e627c4c7e298f3f1613a","modified":1517884275631},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"baa68725feeec6643f875a532a9d55ba8aacdb2c","modified":1517882480950},{"_id":"themes/BlueLake/languages/en.yml","hash":"95bac2c366505d016b5defc47370679b9f5f3c4b","modified":1517882480949},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"bd97d5e4b39d30da1644b90256dfc4e6b1d76988","modified":1517882480950},{"_id":"themes/BlueLake/languages/ko.yml","hash":"fc8826724f570136d9a2d3ec2705b7b7000e0f14","modified":1517882480950},{"_id":"themes/BlueLake/languages/tr.yml","hash":"5f13d55fdd5bdd1115075736e3e26a1ea1dd1dea","modified":1517882480950},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"d7f5842295509746f878e627c4c7e298f3f1613a","modified":1517882480950},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"d4d587ba81864910715c0c3879605cc6a9362e09","modified":1517882480951},{"_id":"themes/BlueLake/layout/archive.jade","hash":"98d9fb812edbc180878fdadb65bc38499eef2cc4","modified":1517882480955},{"_id":"themes/BlueLake/layout/base.jade","hash":"ee19d63543f898336dee846ed45d932239c40fe0","modified":1517882480955},{"_id":"themes/BlueLake/layout/category.jade","hash":"9f3a9f1d6f0bbad258b308ad8d49128c05b422cf","modified":1517882480955},{"_id":"themes/BlueLake/layout/index.jade","hash":"dd81d9f7a6b388de2ab731b17b3ba55f70df4a5f","modified":1517882480955},{"_id":"themes/BlueLake/layout/post.jade","hash":"0305258c33e4d02f977ee1aaf7f2429b993fda17","modified":1517882480956},{"_id":"themes/BlueLake/layout/page.jade","hash":"415404398931d98db28bff723886b07dcb8bbbc3","modified":1517882480955},{"_id":"themes/BlueLake/layout/tag.jade","hash":"50c7af7565751db5d7672beb434768885fb224cb","modified":1517882480956},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1517882480956},{"_id":"themes/BlueLake/source/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1517882480957},{"_id":"themes/BlueLake/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1517882477480},{"_id":"themes/BlueLake/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1517882477480},{"_id":"themes/BlueLake/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1517882477481},{"_id":"themes/BlueLake/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1517882477481},{"_id":"themes/BlueLake/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1517882477482},{"_id":"themes/BlueLake/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1517882477482},{"_id":"themes/BlueLake/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1517882477482},{"_id":"themes/BlueLake/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1517882477483},{"_id":"themes/BlueLake/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1517882477483},{"_id":"themes/BlueLake/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1517882477484},{"_id":"themes/BlueLake/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1517882477484},{"_id":"themes/BlueLake/.git/logs/HEAD","hash":"2f7a0fbd99e0608fd3683ee2a67d30c4c23e234e","modified":1517882480941},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"3f11d2b5a4c647bf2b37c4d00bdc250cda80b770","modified":1517882480951},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"21d05990aa5a19632f9ed51085ef7727adeea17a","modified":1517882480951},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"c1f1955d12aee22a931a3f4ad9d0e9a408e80f3c","modified":1517882480951},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"d970c81b5cdbd7c0348ee28e93bcbb006d613b6d","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"e0aa5d7adc1218a324a484abe3513e9545f89067","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/mathjax.jade","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/mathjax2.jade","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1517882480952},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1517882480953},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"4f2fba7fcb39a6bf70ff04dad9a3dab2563b21e7","modified":1517882480953},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"ba0839518db2cb9dafee67ca5e471219bfba2e90","modified":1517882480953},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1517882480953},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"c632919f04194dcf6e0e8ccc572554a859aa922b","modified":1517882480953},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"6e587b7d254d0d92b959ba58262f5e81b618eba2","modified":1517882480953},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"0107affa0c6b22e09546fcf82a6f71ba2dd1e315","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"9af40206a525db1cb9761fa6facb36332057acf3","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"164a83faaf92ec19d268fd303bf6e30348ddef5c","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"c6f778d5d2f13bacbd83a56a9e9faaeac0dda0ed","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"c75308c2b72456cfb98cb80f280c66e58f171705","modified":1517882480954},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"4e90378aa88c5694126dc8ea5bed3bb2f8642e53","modified":1517882480954},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"92b5c306f276f8ea6a134e303b1b63612d25ecfe","modified":1517882480957},{"_id":"themes/BlueLake/source/css/style.styl","hash":"45776bc176bc8ed0d664e953e23d6a0a9a030929","modified":1517882480957},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1517882480958},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1517882480959},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1517882480958},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1517882480959},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"7ce826f7b678ff3c524fce8bbd480c188e50c7ee","modified":1517882480960},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"9e68d688f2f12ec193ce9496beb0fd42e1de2288","modified":1517882480960},{"_id":"themes/BlueLake/source/js/totop.js","hash":"d9367c6fa3e973bc5f32ce38d951858455726a02","modified":1517882480961},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1517882480960},{"_id":"themes/BlueLake/.git/objects/pack/pack-3960201a6b68eb8fa7ccb74fce2c388277a0b0ef.idx","hash":"72b864447dcf0acf0212056587453d6cbed114af","modified":1517882480900},{"_id":"themes/BlueLake/.git/refs/heads/master","hash":"c292cfc66fa6a171bcb9e25157b4ee8f09da6755","modified":1517882480941},{"_id":"themes/BlueLake/.git/logs/refs/heads/master","hash":"2f7a0fbd99e0608fd3683ee2a67d30c4c23e234e","modified":1517882480942},{"_id":"themes/BlueLake/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1517882480939},{"_id":"themes/BlueLake/.git/logs/refs/remotes/origin/HEAD","hash":"2f7a0fbd99e0608fd3683ee2a67d30c4c23e234e","modified":1517882480939},{"_id":"themes/BlueLake/.git/objects/pack/pack-3960201a6b68eb8fa7ccb74fce2c388277a0b0ef.pack","hash":"dba040ba1c38e38283e16f9ff438852ac811a55a","modified":1517882480903},{"_id":"public/archives/index.html","hash":"8b557396416c9f7324c837b96d09e91570354c90","modified":1517887148342},{"_id":"public/archives/2016/index.html","hash":"8b557396416c9f7324c837b96d09e91570354c90","modified":1517887148342},{"_id":"public/archives/2016/06/index.html","hash":"8b557396416c9f7324c837b96d09e91570354c90","modified":1517887148342},{"_id":"public/index.html","hash":"ac195d45ff9bc11daf78fc1de988eee2c1b46e00","modified":1517887148343},{"_id":"public/tags/Android/index.html","hash":"61c5c77ac19d0f2f14074c728e061886b42e25e8","modified":1517887148343},{"_id":"public/tags/三方框架/index.html","hash":"23c0cce3ed6cf6dfcf9f3294432258ec86c351d3","modified":1517887148343},{"_id":"public/tags/技术/index.html","hash":"1e41eda6b06708cc82bcbd4fd7a817f132000009","modified":1517887148343},{"_id":"public/2016/06/01/Dagger2/index.html","hash":"23331e0d80c4723cc34c9969a66749d4a90f071d","modified":1517887148343},{"_id":"public/categories/Android基础学习/index.html","hash":"658871c243c6cb0cd4237a30ebd7ae536a86fa58","modified":1517887148345},{"_id":"public/tags/测试/index.html","hash":"7479a77bc9c4db1bca1b36de298af1b9e7380071","modified":1517887148345},{"_id":"public/2016/06/01/Android自动化测试/index.html","hash":"44b3672d8ad1b2601d8bd6f5be31a33e1b256668","modified":1517887148345},{"_id":"public/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1517887148346},{"_id":"public/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1517887148346},{"_id":"public/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1517887148346},{"_id":"public/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1517887148346},{"_id":"public/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1517887148346},{"_id":"public/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1517887148346},{"_id":"public/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1517887148592},{"_id":"public/css/highlight.css","hash":"fb0403feb34cc8bb8b1f28f238540d36588b86df","modified":1517887148596},{"_id":"public/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1517887148596},{"_id":"public/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1517887148597},{"_id":"public/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1517887148597},{"_id":"public/css/style.css","hash":"0b87f0674cad37ed4006f989cca7e1cd9f9568a3","modified":1517887148597}],"Category":[{"name":"Android基础学习","_id":"cjdb2tf5k0002o4ieeo371txw"}],"Data":[],"Page":[],"Post":[{"title":"Dagger2全面解析","date":"2016-06-01T15:47:44.000Z","_content":"\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/timg.jpg)\n\n### Dagger2的好处\n\n- 依赖的注入和配置独立于组件之外。\n- 因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。\n- 依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。\n\n\n### 相关标签\n\n **@Inject、@Module、@Provide、@Component**\n\n- @Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。\n\n- @Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。\n\n- @Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。\n\n- @Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。\n\n\n### 标签使用方式\n\n**1.@Inject**  \n\n    public class User {  \n  \n\t    ....  \n\t    ....  \n\t    //在被依赖类中使用@Inject标记该类的构造方法\n\t    @Inject  \n\t    public User() {  \n\t    }  \n\t  \n\t    ....  \n\t    ....    \n\t}  \n\n--------------\n\n    public class MainActivity extends AppCompatActivity {  \n\t\t  \n\t    //在依赖类中使用@Inject来注入被依赖类实例\n\t    @Inject  \n\t    User user;  \n\t    @Inject  \n\t    User user2;  \n\t    private TextView tv;  \n\t    private TextView tv2;  \n\t  \n\t    @Override  \n\t    protected void onCreate(Bundle savedInstanceState) {  \n\t        super.onCreate(savedInstanceState);  \n\t        setContentView(R.layout.activity_main);  \n\t        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n\t        DaggerActivityComponent.builder().build().inject(this);  \n\t        tv = ((TextView) findViewById(R.id.tv));  \n\t        tv2 = ((TextView) findViewById(R.id.tv2));  \n\t        tv.setText(user.toString());  \n\t        tv2.setText(user2.toString());  \n\t    }  \n\t} \n\n**2.@Component**\n\t\t\n    @Component  \n\tpublic interface ActivityComponent {  \n\t    void inject(MainActivity activity);  \n\t}  \n\n**3.@Provider & @Module**\n\n    @Module  \n\tpublic class UserModule {  \n\t    @Provides\n\t    User providesUser() {  \n\t        return new User();  \n\t    }  \n\t}  \n\n\n\n### 注入方式\n- 构造方法注入：在类的构造方法前面注释@Inject\n- 成员变量注入：在类的成员变量（非私有）前面注释@Inject\n- 函数方法注入：在函数前面注释@Inject\n\n\n### 不同类的关系\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png)\n\n\n### 编译后的生成文件与原文件及关系图\n\n**原文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png)\n\n**生成文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png)\n\n**各文件对应关系**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png)\n\n\n###  注入路径\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png)\n\n\n\n### @Scope（用于划分作用域）\n\n**javax包中自带的@Singleton,其class如下：**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png)\n\n**用户自己写的**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png)\n\n***可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别***\n\n#### 各标签的意义\n\n**@Retention**\n\nRetention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:\n1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略\n2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略\n3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.\n\n**@Documented**\n\nDocumented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 \n\n\n**@Scope**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png)\n\n\n\n### @Singleton的单例模式是如何起作用的（我只是个栗子）\n\n该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png)\n\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png)\n\n\n### @Qualifier的巧用（指哪打哪）\n\n@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。\n\n两个@Qualifier\n\n    @Qualifier\n\tpublic @interface ThemeNight {\n\t\n\t}\n\t\n\t@Qualifier\n\tpublic @interface ThemeDay {\n\t}\n\n-----------------------\n\n    @Module\n\tpublic class ThemeModule {\n\t    @Provides\n\t    @ThemeDay\n\t    Theme provideDayTheme() {\n\t        return new Theme(\"day\");\n\t    }\n\n\t    @Provides\n\t    @ThemeNight\n\t    Theme provideNightTheme() {\n\t        return new Theme(\"night\");\n\t    }\n\t}\n\n------------------\n\n    @Component\n    public interface ThemeComponent{\n\t    void inject(ThemeTest themeTest);\n    }\n    \n\n--------------------\n\n    public class ThemeTest {\n\t    @Inject\n\t    @ThemeDay\n\t    Theme dayTheme;\n\t    @Inject\n\t    @ThemeNight\n\t    Theme nightTheme;\n\n\t    public static void main(String[] arg) {\n\t        ThemeTest themeTest = new ThemeTest();\n\t        DaggerThemeComponent.create().inject(themeTest);\n\t        System.out.println(themeTest.dayTheme.themeName);\n\t        System.out.println(themeTest.nightTheme.themeName);\n\t    }\n\t}\n\n\n\n","source":"_posts/Dagger2.md","raw":"---\ntitle: Dagger2全面解析\ndate: 2016-06-01 23:47:44\ncategories: \"Android基础学习\"\ntags:\n     - Android\n     - 三方框架\n     - 技术\n---\n\n![enter image description here](http://op0dvu7tu.bkt.clouddn.com/timg.jpg)\n\n### Dagger2的好处\n\n- 依赖的注入和配置独立于组件之外。\n- 因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。\n- 依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。\n\n\n### 相关标签\n\n **@Inject、@Module、@Provide、@Component**\n\n- @Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。\n\n- @Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。\n\n- @Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。\n\n- @Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。\n\n\n### 标签使用方式\n\n**1.@Inject**  \n\n    public class User {  \n  \n\t    ....  \n\t    ....  \n\t    //在被依赖类中使用@Inject标记该类的构造方法\n\t    @Inject  \n\t    public User() {  \n\t    }  \n\t  \n\t    ....  \n\t    ....    \n\t}  \n\n--------------\n\n    public class MainActivity extends AppCompatActivity {  \n\t\t  \n\t    //在依赖类中使用@Inject来注入被依赖类实例\n\t    @Inject  \n\t    User user;  \n\t    @Inject  \n\t    User user2;  \n\t    private TextView tv;  \n\t    private TextView tv2;  \n\t  \n\t    @Override  \n\t    protected void onCreate(Bundle savedInstanceState) {  \n\t        super.onCreate(savedInstanceState);  \n\t        setContentView(R.layout.activity_main);  \n\t        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n\t        DaggerActivityComponent.builder().build().inject(this);  \n\t        tv = ((TextView) findViewById(R.id.tv));  \n\t        tv2 = ((TextView) findViewById(R.id.tv2));  \n\t        tv.setText(user.toString());  \n\t        tv2.setText(user2.toString());  \n\t    }  \n\t} \n\n**2.@Component**\n\t\t\n    @Component  \n\tpublic interface ActivityComponent {  \n\t    void inject(MainActivity activity);  \n\t}  \n\n**3.@Provider & @Module**\n\n    @Module  \n\tpublic class UserModule {  \n\t    @Provides\n\t    User providesUser() {  \n\t        return new User();  \n\t    }  \n\t}  \n\n\n\n### 注入方式\n- 构造方法注入：在类的构造方法前面注释@Inject\n- 成员变量注入：在类的成员变量（非私有）前面注释@Inject\n- 函数方法注入：在函数前面注释@Inject\n\n\n### 不同类的关系\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png)\n\n\n### 编译后的生成文件与原文件及关系图\n\n**原文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png)\n\n**生成文件**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png)\n\n**各文件对应关系**\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png)\n\n\n###  注入路径\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png)\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png)\n\n\n\n### @Scope（用于划分作用域）\n\n**javax包中自带的@Singleton,其class如下：**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png)\n\n**用户自己写的**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png)\n\n***可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别***\n\n#### 各标签的意义\n\n**@Retention**\n\nRetention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:\n1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略\n2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略\n3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.\n\n**@Documented**\n\nDocumented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 \n\n\n**@Scope**\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png)\n\n\n\n### @Singleton的单例模式是如何起作用的（我只是个栗子）\n\n该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png)\n\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png)\n\n\n### @Qualifier的巧用（指哪打哪）\n\n@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。\n\n两个@Qualifier\n\n    @Qualifier\n\tpublic @interface ThemeNight {\n\t\n\t}\n\t\n\t@Qualifier\n\tpublic @interface ThemeDay {\n\t}\n\n-----------------------\n\n    @Module\n\tpublic class ThemeModule {\n\t    @Provides\n\t    @ThemeDay\n\t    Theme provideDayTheme() {\n\t        return new Theme(\"day\");\n\t    }\n\n\t    @Provides\n\t    @ThemeNight\n\t    Theme provideNightTheme() {\n\t        return new Theme(\"night\");\n\t    }\n\t}\n\n------------------\n\n    @Component\n    public interface ThemeComponent{\n\t    void inject(ThemeTest themeTest);\n    }\n    \n\n--------------------\n\n    public class ThemeTest {\n\t    @Inject\n\t    @ThemeDay\n\t    Theme dayTheme;\n\t    @Inject\n\t    @ThemeNight\n\t    Theme nightTheme;\n\n\t    public static void main(String[] arg) {\n\t        ThemeTest themeTest = new ThemeTest();\n\t        DaggerThemeComponent.create().inject(themeTest);\n\t        System.out.println(themeTest.dayTheme.themeName);\n\t        System.out.println(themeTest.nightTheme.themeName);\n\t    }\n\t}\n\n\n\n","slug":"Dagger2","published":1,"updated":"2018-02-06T03:24:54.935Z","_id":"cjdb2tf5c0000o4iexv20wral","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/timg.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"Dagger2的好处\"><a href=\"#Dagger2的好处\" class=\"headerlink\" title=\"Dagger2的好处\"></a>Dagger2的好处</h3><ul>\n<li>依赖的注入和配置独立于组件之外。</li>\n<li>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</li>\n<li>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</li>\n</ul>\n<h3 id=\"相关标签\"><a href=\"#相关标签\" class=\"headerlink\" title=\"相关标签\"></a>相关标签</h3><p> <strong>@Inject、@Module、@Provide、@Component</strong></p>\n<ul>\n<li><p>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</p>\n</li>\n<li><p>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</p>\n</li>\n<li><p>@Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</p>\n</li>\n<li><p>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。</p>\n</li>\n</ul>\n<h3 id=\"标签使用方式\"><a href=\"#标签使用方式\" class=\"headerlink\" title=\"标签使用方式\"></a>标签使用方式</h3><p><strong>1.@Inject</strong>  </p>\n<pre><code>public class User {  \n\n    ....  \n    ....  \n    //在被依赖类中使用@Inject标记该类的构造方法\n    @Inject  \n    public User() {  \n    }  \n\n    ....  \n    ....    \n}  \n</code></pre><hr>\n<pre><code>public class MainActivity extends AppCompatActivity {  \n\n    //在依赖类中使用@Inject来注入被依赖类实例\n    @Inject  \n    User user;  \n    @Inject  \n    User user2;  \n    private TextView tv;  \n    private TextView tv2;  \n\n    @Override  \n    protected void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.activity_main);  \n        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n        DaggerActivityComponent.builder().build().inject(this);  \n        tv = ((TextView) findViewById(R.id.tv));  \n        tv2 = ((TextView) findViewById(R.id.tv2));  \n        tv.setText(user.toString());  \n        tv2.setText(user2.toString());  \n    }  \n} \n</code></pre><p><strong>2.@Component</strong></p>\n<pre><code>@Component  \npublic interface ActivityComponent {  \n    void inject(MainActivity activity);  \n}  \n</code></pre><p><strong>3.@Provider &amp; @Module</strong></p>\n<pre><code>@Module  \npublic class UserModule {  \n    @Provides\n    User providesUser() {  \n        return new User();  \n    }  \n}  \n</code></pre><h3 id=\"注入方式\"><a href=\"#注入方式\" class=\"headerlink\" title=\"注入方式\"></a>注入方式</h3><ul>\n<li>构造方法注入：在类的构造方法前面注释@Inject</li>\n<li>成员变量注入：在类的成员变量（非私有）前面注释@Inject</li>\n<li>函数方法注入：在函数前面注释@Inject</li>\n</ul>\n<h3 id=\"不同类的关系\"><a href=\"#不同类的关系\" class=\"headerlink\" title=\"不同类的关系\"></a>不同类的关系</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png\" alt=\"enter image description here\"></p>\n<h3 id=\"编译后的生成文件与原文件及关系图\"><a href=\"#编译后的生成文件与原文件及关系图\" class=\"headerlink\" title=\"编译后的生成文件与原文件及关系图\"></a>编译后的生成文件与原文件及关系图</h3><p><strong>原文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png\" alt=\"enter image description here\"></p>\n<p><strong>生成文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png\" alt=\"enter image description here\"></p>\n<p><strong>各文件对应关系</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png\" alt=\"enter image description here\"></p>\n<h3 id=\"注入路径\"><a href=\"#注入路径\" class=\"headerlink\" title=\"注入路径\"></a>注入路径</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Scope（用于划分作用域）\"><a href=\"#Scope（用于划分作用域）\" class=\"headerlink\" title=\"@Scope（用于划分作用域）\"></a>@Scope（用于划分作用域）</h3><p><strong>javax包中自带的@Singleton,其class如下：</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png\" alt=\"enter image description here\"></p>\n<p><strong>用户自己写的</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png\" alt=\"enter image description here\"></p>\n<p><strong><em>可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别</em></strong></p>\n<h4 id=\"各标签的意义\"><a href=\"#各标签的意义\" class=\"headerlink\" title=\"各标签的意义\"></a>各标签的意义</h4><p><strong>@Retention</strong></p>\n<p>Retention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:<br>1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略<br>2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略<br>3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.</p>\n<p><strong>@Documented</strong></p>\n<p>Documented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 </p>\n<p><strong>@Scope</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Singleton的单例模式是如何起作用的（我只是个栗子）\"><a href=\"#Singleton的单例模式是如何起作用的（我只是个栗子）\" class=\"headerlink\" title=\"@Singleton的单例模式是如何起作用的（我只是个栗子）\"></a>@Singleton的单例模式是如何起作用的（我只是个栗子）</h3><p>该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Qualifier的巧用（指哪打哪）\"><a href=\"#Qualifier的巧用（指哪打哪）\" class=\"headerlink\" title=\"@Qualifier的巧用（指哪打哪）\"></a>@Qualifier的巧用（指哪打哪）</h3><p>@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。</p>\n<p>两个@Qualifier</p>\n<pre><code>@Qualifier\npublic @interface ThemeNight {\n\n}\n\n@Qualifier\npublic @interface ThemeDay {\n}\n</code></pre><hr>\n<pre><code>@Module\npublic class ThemeModule {\n    @Provides\n    @ThemeDay\n    Theme provideDayTheme() {\n        return new Theme(&quot;day&quot;);\n    }\n\n    @Provides\n    @ThemeNight\n    Theme provideNightTheme() {\n        return new Theme(&quot;night&quot;);\n    }\n}\n</code></pre><hr>\n<pre><code>@Component\npublic interface ThemeComponent{\n    void inject(ThemeTest themeTest);\n}\n</code></pre><hr>\n<pre><code>public class ThemeTest {\n    @Inject\n    @ThemeDay\n    Theme dayTheme;\n    @Inject\n    @ThemeNight\n    Theme nightTheme;\n\n    public static void main(String[] arg) {\n        ThemeTest themeTest = new ThemeTest();\n        DaggerThemeComponent.create().inject(themeTest);\n        System.out.println(themeTest.dayTheme.themeName);\n        System.out.println(themeTest.nightTheme.themeName);\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://op0dvu7tu.bkt.clouddn.com/timg.jpg\" alt=\"enter image description here\"></p>\n<h3 id=\"Dagger2的好处\"><a href=\"#Dagger2的好处\" class=\"headerlink\" title=\"Dagger2的好处\"></a>Dagger2的好处</h3><ul>\n<li>依赖的注入和配置独立于组件之外。</li>\n<li>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</li>\n<li>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</li>\n</ul>\n<h3 id=\"相关标签\"><a href=\"#相关标签\" class=\"headerlink\" title=\"相关标签\"></a>相关标签</h3><p> <strong>@Inject、@Module、@Provide、@Component</strong></p>\n<ul>\n<li><p>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</p>\n</li>\n<li><p>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</p>\n</li>\n<li><p>@Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</p>\n</li>\n<li><p>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。</p>\n</li>\n</ul>\n<h3 id=\"标签使用方式\"><a href=\"#标签使用方式\" class=\"headerlink\" title=\"标签使用方式\"></a>标签使用方式</h3><p><strong>1.@Inject</strong>  </p>\n<pre><code>public class User {  \n\n    ....  \n    ....  \n    //在被依赖类中使用@Inject标记该类的构造方法\n    @Inject  \n    public User() {  \n    }  \n\n    ....  \n    ....    \n}  \n</code></pre><hr>\n<pre><code>public class MainActivity extends AppCompatActivity {  \n\n    //在依赖类中使用@Inject来注入被依赖类实例\n    @Inject  \n    User user;  \n    @Inject  \n    User user2;  \n    private TextView tv;  \n    private TextView tv2;  \n\n    @Override  \n    protected void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.activity_main);  \n        //实例component，并通过其inject（）方法来对成员变量（通过@Inject进行表述的）进行赋值\n        DaggerActivityComponent.builder().build().inject(this);  \n        tv = ((TextView) findViewById(R.id.tv));  \n        tv2 = ((TextView) findViewById(R.id.tv2));  \n        tv.setText(user.toString());  \n        tv2.setText(user2.toString());  \n    }  \n} \n</code></pre><p><strong>2.@Component</strong></p>\n<pre><code>@Component  \npublic interface ActivityComponent {  \n    void inject(MainActivity activity);  \n}  \n</code></pre><p><strong>3.@Provider &amp; @Module</strong></p>\n<pre><code>@Module  \npublic class UserModule {  \n    @Provides\n    User providesUser() {  \n        return new User();  \n    }  \n}  \n</code></pre><h3 id=\"注入方式\"><a href=\"#注入方式\" class=\"headerlink\" title=\"注入方式\"></a>注入方式</h3><ul>\n<li>构造方法注入：在类的构造方法前面注释@Inject</li>\n<li>成员变量注入：在类的成员变量（非私有）前面注释@Inject</li>\n<li>函数方法注入：在函数前面注释@Inject</li>\n</ul>\n<h3 id=\"不同类的关系\"><a href=\"#不同类的关系\" class=\"headerlink\" title=\"不同类的关系\"></a>不同类的关系</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E6%9C%AA%E6%A0%87%E9%A2%98-2-%E6%81%A2%E5%A4%8D%E7%9A%84.png\" alt=\"enter image description here\"></p>\n<h3 id=\"编译后的生成文件与原文件及关系图\"><a href=\"#编译后的生成文件与原文件及关系图\" class=\"headerlink\" title=\"编译后的生成文件与原文件及关系图\"></a>编译后的生成文件与原文件及关系图</h3><p><strong>原文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105449.png\" alt=\"enter image description here\"></p>\n<p><strong>生成文件</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818105426.png\" alt=\"enter image description here\"></p>\n<p><strong>各文件对应关系</strong><br><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E5%90%8E%E5%85%B3%E7%B3%BB%E5%9B%BE.png\" alt=\"enter image description here\"></p>\n<h3 id=\"注入路径\"><a href=\"#注入路径\" class=\"headerlink\" title=\"注入路径\"></a>注入路径</h3><p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112230.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818111938.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818112629.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Scope（用于划分作用域）\"><a href=\"#Scope（用于划分作用域）\" class=\"headerlink\" title=\"@Scope（用于划分作用域）\"></a>@Scope（用于划分作用域）</h3><p><strong>javax包中自带的@Singleton,其class如下：</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818113850.png\" alt=\"enter image description here\"></p>\n<p><strong>用户自己写的</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114133.png\" alt=\"enter image description here\"></p>\n<p><strong><em>可以看出除了少了@Documented标签外，用户自己写的Scope标签和@Singleton并没有本质的区别</em></strong></p>\n<h4 id=\"各标签的意义\"><a href=\"#各标签的意义\" class=\"headerlink\" title=\"各标签的意义\"></a>各标签的意义</h4><p><strong>@Retention</strong></p>\n<p>Retention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:<br>1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略<br>2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略<br>3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.</p>\n<p><strong>@Documented</strong></p>\n<p>Documented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. 示例6进一步演示了使用 </p>\n<p><strong>@Scope</strong></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818114808.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Singleton的单例模式是如何起作用的（我只是个栗子）\"><a href=\"#Singleton的单例模式是如何起作用的（我只是个栗子）\" class=\"headerlink\" title=\"@Singleton的单例模式是如何起作用的（我只是个栗子）\"></a>@Singleton的单例模式是如何起作用的（我只是个栗子）</h3><p>该单例模式的前提是所使用的Component实例是同一个的情况下，而且任何自定义的Scope标签都有相同功能，具体实现如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818141827.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170818142004.png\" alt=\"enter image description here\"></p>\n<h3 id=\"Qualifier的巧用（指哪打哪）\"><a href=\"#Qualifier的巧用（指哪打哪）\" class=\"headerlink\" title=\"@Qualifier的巧用（指哪打哪）\"></a>@Qualifier的巧用（指哪打哪）</h3><p>@Qualifier是用来给注解做注解的。它告诉Dagger依赖需求方 创建数据的时候使用哪个依赖提供方。</p>\n<p>两个@Qualifier</p>\n<pre><code>@Qualifier\npublic @interface ThemeNight {\n\n}\n\n@Qualifier\npublic @interface ThemeDay {\n}\n</code></pre><hr>\n<pre><code>@Module\npublic class ThemeModule {\n    @Provides\n    @ThemeDay\n    Theme provideDayTheme() {\n        return new Theme(&quot;day&quot;);\n    }\n\n    @Provides\n    @ThemeNight\n    Theme provideNightTheme() {\n        return new Theme(&quot;night&quot;);\n    }\n}\n</code></pre><hr>\n<pre><code>@Component\npublic interface ThemeComponent{\n    void inject(ThemeTest themeTest);\n}\n</code></pre><hr>\n<pre><code>public class ThemeTest {\n    @Inject\n    @ThemeDay\n    Theme dayTheme;\n    @Inject\n    @ThemeNight\n    Theme nightTheme;\n\n    public static void main(String[] arg) {\n        ThemeTest themeTest = new ThemeTest();\n        DaggerThemeComponent.create().inject(themeTest);\n        System.out.println(themeTest.dayTheme.themeName);\n        System.out.println(themeTest.nightTheme.themeName);\n    }\n}\n</code></pre>"},{"title":"Android自动化测试","date":"2016-06-01T15:47:44.000Z","_content":"\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg)\n\n\n\n-----------------\n\n    \n[TOC]\n\n### 摘要\n    Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n\n### Monkey测试\n\n#### 简介\n\tMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n\n#### 使用方式\n\t（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n\t（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n\t（3）Monkey 命令启动方式：  \n\t  \n\t    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n\t    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n\t    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n\t\n#### 效果展示\n部分输出数据如下所示：\n![输出数据](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png)\n\n#### 更多参数介绍\n[点击查看](http://blog.csdn.net/linghu_java/article/details/6732895)\n\t\t\n#### 可能会遇到的问题\n\t（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n[点击查看解决方案](http://www.cnblogs.com/dwf07223/p/3228047.html)\n\n\n### 单元测试\n\t\n#### 简介\n\t单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n\n#### 使用方式\n\t首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\t\n\tdependencies {\n\t    testCompile 'junit:junit:4.12'\n    }\n\n而后在test文件下写单元测试类\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png)\n\n被测试类如下\n\n\tpublic class Calculator {\n\t    public static int add(int a, int b) {\n\t        return a + b;\n\t    }\n\t}\n\n单元测试类如下\n\n\tpublic class ExampleUnitTest {\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        assertEquals(4, Calculator.add(2,2));\n\t    }\n\t}\n\n最后运行单元测试类，结果如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png)\n\t\n#### Junit标签解析\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n\t@Test： 将方法（函数）标记为测试用例\n\t@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n\t@After： 每一个使用@Test标记的方法运行之后都要运行一次\n\t@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n\t@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n\n以如下代码为例：\n\t\n\tpublic class ExampleUnitTest {\n\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t\n\t    @Test\n\t    public void addition_isErr() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t    @Before\n\t    public void before() throws Exception {\n\t        System.out.println(\"@Before\");\n\t    }\n\t\n\t    @After\n\t    public void after() throws Exception {\n\t        System.out.println(\"@After\");\n\t    }\n\t\n\t\n\t    @AfterClass\n\t    public static void afterClass() throws Exception {\n\t        System.out.println(\"@AfterClass\");\n\t    }\n\t\n\t    @BeforeClass\n\t    public static void beforeClass() throws Exception {\n\t        System.out.println(\"@BeforeClass\");\n\t    }\n\t}\n\t\n相应的执行顺序如下：\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png)\n\n#### Mockito使用方式\n\n简介：\n\t\t\n\tMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n\n**先体验以下Mockito的使用：**\n\n1.添加依赖\n\n\ttestCompile 'org.mockito:mockito-core:2.8.47'\n\n2.被依赖类\n\t\n\tpublic interface IMathUtils {\n\t    public int abs(int num); // 求绝对值\n\t}\n\t\n3.依赖类\n\n\t@RunWith(MockitoJUnitRunner.class)\n\tpublic class MockTest {\n\t    @Mock\n\t    IMathUtils mathUtils;\n\t\n\t    @Test\n\t    public void mockTest() {\n\t\n\t        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n\t    }\n\t}\n\n可以发现**IMathUtils**是一个接口，根本就没有实现，用**Mockito**框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！**Mockito代理了IMathUtils.abs(num)的行为**，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法**when...thenReturn...**相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\n\tpublic class MockTest {\n\n        @Mock\n        IMathUtils iMathUtils ; \n\n        @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n        @Test\n        public void mockTest()  {\n            when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n        }\n\t}\n\n其中**@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();** 用于初始化Mock对象，效果与在类前添加**@RunWith(MockitoJUnitRunner.class)**标签类似\n\n**Mock配置**\n\nMock有多种配置方式，如下所示：\n\t\t\n\t@Test\n\tpublic void test1()  {\n\t        //  创建 mock\n\t        MyClass test = Mockito.mock(MyClass.class);\n\n        // 自定义 getUniqueId() 的返回值\n        when(test.getUniqueId()).thenReturn(43);\n\n        // 在测试中使用mock对象\n        assertEquals(test.getUniqueId(), 43);\n\t}\n\t\n\t// 返回多个值\n\t@Test\n\tpublic void testMoreThanOneReturnValue()  {\n\t        Iterator i= mock(Iterator.class);\n\t        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n\t        String result=i.next()+\" \"+i.next();\n\t        // 断言\n\t        assertEquals(\"Mockito rocks\", result);\n\t}\n\t\n\t// 如何根据输入来返回值\n\t@Test\n\tpublic void testReturnValueDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(\"Mockito\")).thenReturn(1);\n\t        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n\t        // 断言\n\t        assertEquals(1,c.compareTo(\"Mockito\"));\n\t}\n\t\n\t// 如何让返回值不依赖于输入\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(anyInt())).thenReturn(-1);\n\t        // 断言\n\t        assertEquals(-1 ,c.compareTo(9));\n\t}\n\t\n\t// 根据参数类型来返回值\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n\t        // 断言\n\t        Todo todo = new Todo(5);\n\t        assertEquals(todo ,c.compareTo(new Todo(1)));\n\t}\n\t\n更多配置可以看下这个网站  [点击链接](http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html)\n\n\n### UI测试\n\n#### 简介\n\tUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n\n#### 使用方式\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\n\ttestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\n\ttestCompile 'com.android.support.test:runner:0.4.1'\n\n2.在androidTest目录下创建测试类\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png)\n\n3.被测试类（即activity之类的展示界面）\nMainActivity.class\n\t\n\tpublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n\t    private EditText mEt;\n\t    private TextView mTv;\n\t    private Button mBtn;\n\t\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t\n\t        mEt = (EditText) findViewById(R.id.et);\n\t        mTv = (TextView) findViewById(R.id.tv);\n\t        mBtn = (Button) findViewById(R.id.btn);\n\t\n\t        mBtn.setOnClickListener(this);\n\t    }\n\t\n\t    @Override\n\t    public void onClick(View v) {\n\t        mTv.setText(mEt.getText().toString());\n\t    }\n\t}\n\nactivity_main.xml\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n\t    xmlns:tools=\"http://schemas.android.com/tools\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n    <TextView\n        android:id=\"@+id/tv\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"15dp\"\n        android:padding=\"10dp\"\n        android:text=\"helo\" />\n\n    <EditText\n        android:id=\"@+id/et\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"40dp\"\n        android:layout_alignParentLeft=\"true\"\n        android:layout_alignParentStart=\"true\"\n        android:layout_alignParentTop=\"true\"\n        android:layout_marginTop=\"75dp\" />\n\n    <Button\n        android:id=\"@+id/btn\"\n        android:layout_width=\"80dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/et\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginTop=\"49dp\"\n        android:text=\"sure\" />\n\t</RelativeLayout>\n\n测试类\nExampleInstrumentedTest.class\n\n\t@RunWith(AndroidJUnit4.class)\n\tpublic class ExampleInstrumentedTest {\n\t    @Rule\n\t    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n\t            MainActivity.class);\n\n\t    @Test\n\t    public void useAppContext() throws Exception {\n\t        // Context of the app under test.\n\t        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n\t                closeSoftKeyboard());\n\t        onView(withId(R.id.btn)).perform(click());\n\t    }\n\t}\n其中**onView(withId(R.id.et)).perform(typeText(\"helo world\"), closeSoftKeyboard());**选择界面中的输入框，并输入“helo world”，**onView(withId(R.id.btn)).perform(click());**选择界面中的按钮并点击。\n\n[更多操作方式-1](https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md)        \n[更多操作方式-2](http://blog.csdn.net/eclipsexys/article/details/45622813)\n\n#### 标签解析\n\n\t@Rule: 应用于成员变量\n\t@ClassRule: 应用于测试类中的静态变量\n\t两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\t\t\n\t@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n\n\n### 总结\n\t总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\nAndroid自动化测试\n\nenter image description here\n\nAndroid自动化测试\n摘要\nMonkey测试\n简介\n使用方式\n效果展示\n更多参数介绍\n可能会遇到的问题\n单元测试\n简介\n使用方式\nJunit标签解析\nMockito使用方式\nUI测试\n简介\n使用方式\n标签解析\n总结\n摘要\n\nAndroid自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\nMonkey测试\n\n简介\n\nMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n使用方式\n\n（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n效果展示\n\n部分输出数据如下所示：\n\n输出数据\n\n更多参数介绍\n\n点击查看\n\n可能会遇到的问题\n\n（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n点击查看解决方案\n\n单元测试\n\n简介\n\n单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n使用方式\n\n首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile 'junit:junit:4.12'\n}\n而后在test文件下写单元测试类\n\nenter image description here\n\n被测试类如下\n\npublic class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n单元测试类如下\n\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n最后运行单元测试类，结果如下：\n\nenter image description here\n\nJunit标签解析\n\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n以如下代码为例：\n\npublic class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(\"@Before\");\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(\"@After\");\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(\"@AfterClass\");\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(\"@BeforeClass\");\n    }\n}\n相应的执行顺序如下：\n\nenter image description here\n\nMockito使用方式\n\n简介：\n\nMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n先体验以下Mockito的使用：\n\n1.添加依赖\n\ntestCompile 'org.mockito:mockito-core:2.8.47'\n2.被依赖类\n\npublic interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n3.依赖类\n\n@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\npublic class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似\n\nMock配置\n\nMock有多种配置方式，如下所示：\n\n@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n        String result=i.next()+\" \"+i.next();\n        // 断言\n        assertEquals(\"Mockito rocks\", result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(\"Mockito\")).thenReturn(1);\n        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(\"Mockito\"));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n更多配置可以看下这个网站 点击链接\n\nUI测试\n\n简介\n\nUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n使用方式\n\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\ntestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\ntestCompile 'com.android.support.test:runner:0.4.1'\n2.在androidTest目录下创建测试类\n\nenter image description here\n\n3.被测试类（即activity之类的展示界面） \nMainActivity.class\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\nactivity_main.xml\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<TextView\n    android:id=\"@+id/tv\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_marginTop=\"15dp\"\n    android:padding=\"10dp\"\n    android:text=\"helo\" />\n\n<EditText\n    android:id=\"@+id/et\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"40dp\"\n    android:layout_alignParentLeft=\"true\"\n    android:layout_alignParentStart=\"true\"\n    android:layout_alignParentTop=\"true\"\n    android:layout_marginTop=\"75dp\" />\n\n<Button\n    android:id=\"@+id/btn\"\n    android:layout_width=\"80dp\"\n    android:layout_height=\"wrap_content\"\n    android:layout_below=\"@+id/et\"\n    android:layout_centerHorizontal=\"true\"\n    android:layout_marginTop=\"49dp\"\n    android:text=\"sure\" />\n</RelativeLayout>\n测试类 \nExampleInstrumentedTest.class\n\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。\n\n更多操作方式-1 \n更多操作方式-2\n\n标签解析\n\n@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n总结\n\n总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n     7539 \nqqq2830\n 退出账号\n当前文档\n 恢复至上次同步状态\n 删除文档\n 导出...\n 预览文档\n 分享链接\n系统\n 设置\n 使用说明\n 快捷帮助\n 常见问题\n 关于\n\n搜索文件\n杂物 Android自动化测试 \n杂物 SwipeToLoadLayout \n检查Evernote中的笔记版本\n\n","source":"_posts/Android自动化测试.md","raw":"---\ntitle: Android自动化测试\ndate: 2016-06-01 23:47:44\ncategories: \"Android基础学习\"\ntags:\n     - Android\n     - 测试\n     - 技术\n---\n\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg)\n\n\n\n-----------------\n\n    \n[TOC]\n\n### 摘要\n    Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n\n### Monkey测试\n\n#### 简介\n\tMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n\n#### 使用方式\n\t（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n\t（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n\t（3）Monkey 命令启动方式：  \n\t  \n\t    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n\t    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n\t    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n\t\n#### 效果展示\n部分输出数据如下所示：\n![输出数据](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png)\n\n#### 更多参数介绍\n[点击查看](http://blog.csdn.net/linghu_java/article/details/6732895)\n\t\t\n#### 可能会遇到的问题\n\t（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n[点击查看解决方案](http://www.cnblogs.com/dwf07223/p/3228047.html)\n\n\n### 单元测试\n\t\n#### 简介\n\t单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n\n#### 使用方式\n\t首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\t\n\tdependencies {\n\t    testCompile 'junit:junit:4.12'\n    }\n\n而后在test文件下写单元测试类\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png)\n\n被测试类如下\n\n\tpublic class Calculator {\n\t    public static int add(int a, int b) {\n\t        return a + b;\n\t    }\n\t}\n\n单元测试类如下\n\n\tpublic class ExampleUnitTest {\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        assertEquals(4, Calculator.add(2,2));\n\t    }\n\t}\n\n最后运行单元测试类，结果如下：\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png)\n\t\n#### Junit标签解析\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n\t@Test： 将方法（函数）标记为测试用例\n\t@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n\t@After： 每一个使用@Test标记的方法运行之后都要运行一次\n\t@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n\t@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n\n以如下代码为例：\n\t\n\tpublic class ExampleUnitTest {\n\n\t    @Test\n\t    public void addition_isCorrect() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t\n\t    @Test\n\t    public void addition_isErr() throws Exception {\n\t        System.out.println(\"@Test\");\n\t    }\n\t\n\t    @Before\n\t    public void before() throws Exception {\n\t        System.out.println(\"@Before\");\n\t    }\n\t\n\t    @After\n\t    public void after() throws Exception {\n\t        System.out.println(\"@After\");\n\t    }\n\t\n\t\n\t    @AfterClass\n\t    public static void afterClass() throws Exception {\n\t        System.out.println(\"@AfterClass\");\n\t    }\n\t\n\t    @BeforeClass\n\t    public static void beforeClass() throws Exception {\n\t        System.out.println(\"@BeforeClass\");\n\t    }\n\t}\n\t\n相应的执行顺序如下：\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png)\n\n#### Mockito使用方式\n\n简介：\n\t\t\n\tMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n\n**先体验以下Mockito的使用：**\n\n1.添加依赖\n\n\ttestCompile 'org.mockito:mockito-core:2.8.47'\n\n2.被依赖类\n\t\n\tpublic interface IMathUtils {\n\t    public int abs(int num); // 求绝对值\n\t}\n\t\n3.依赖类\n\n\t@RunWith(MockitoJUnitRunner.class)\n\tpublic class MockTest {\n\t    @Mock\n\t    IMathUtils mathUtils;\n\t\n\t    @Test\n\t    public void mockTest() {\n\t\n\t        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n\t    }\n\t}\n\n可以发现**IMathUtils**是一个接口，根本就没有实现，用**Mockito**框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！**Mockito代理了IMathUtils.abs(num)的行为**，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法**when...thenReturn...**相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\n\tpublic class MockTest {\n\n        @Mock\n        IMathUtils iMathUtils ; \n\n        @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n        @Test\n        public void mockTest()  {\n            when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\t\n\t        int abs = mathUtils.abs(-1); // 输出结果 1\n\t\n\t        Assert.assertEquals(abs, 1);// 测试通过\n        }\n\t}\n\n其中**@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();** 用于初始化Mock对象，效果与在类前添加**@RunWith(MockitoJUnitRunner.class)**标签类似\n\n**Mock配置**\n\nMock有多种配置方式，如下所示：\n\t\t\n\t@Test\n\tpublic void test1()  {\n\t        //  创建 mock\n\t        MyClass test = Mockito.mock(MyClass.class);\n\n        // 自定义 getUniqueId() 的返回值\n        when(test.getUniqueId()).thenReturn(43);\n\n        // 在测试中使用mock对象\n        assertEquals(test.getUniqueId(), 43);\n\t}\n\t\n\t// 返回多个值\n\t@Test\n\tpublic void testMoreThanOneReturnValue()  {\n\t        Iterator i= mock(Iterator.class);\n\t        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n\t        String result=i.next()+\" \"+i.next();\n\t        // 断言\n\t        assertEquals(\"Mockito rocks\", result);\n\t}\n\t\n\t// 如何根据输入来返回值\n\t@Test\n\tpublic void testReturnValueDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(\"Mockito\")).thenReturn(1);\n\t        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n\t        // 断言\n\t        assertEquals(1,c.compareTo(\"Mockito\"));\n\t}\n\t\n\t// 如何让返回值不依赖于输入\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(anyInt())).thenReturn(-1);\n\t        // 断言\n\t        assertEquals(-1 ,c.compareTo(9));\n\t}\n\t\n\t// 根据参数类型来返回值\n\t@Test\n\tpublic void testReturnValueInDependentOnMethodParameter()  {\n\t        Comparable c= mock(Comparable.class);\n\t        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n\t        // 断言\n\t        Todo todo = new Todo(5);\n\t        assertEquals(todo ,c.compareTo(new Todo(1)));\n\t}\n\t\n更多配置可以看下这个网站  [点击链接](http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html)\n\n\n### UI测试\n\n#### 简介\n\tUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n\n#### 使用方式\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\n\ttestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\n\ttestCompile 'com.android.support.test:runner:0.4.1'\n\n2.在androidTest目录下创建测试类\n\n![enter image description here](http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png)\n\n3.被测试类（即activity之类的展示界面）\nMainActivity.class\n\t\n\tpublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n\t    private EditText mEt;\n\t    private TextView mTv;\n\t    private Button mBtn;\n\t\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t\n\t        mEt = (EditText) findViewById(R.id.et);\n\t        mTv = (TextView) findViewById(R.id.tv);\n\t        mBtn = (Button) findViewById(R.id.btn);\n\t\n\t        mBtn.setOnClickListener(this);\n\t    }\n\t\n\t    @Override\n\t    public void onClick(View v) {\n\t        mTv.setText(mEt.getText().toString());\n\t    }\n\t}\n\nactivity_main.xml\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n\t    xmlns:tools=\"http://schemas.android.com/tools\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\"\n\t    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n    <TextView\n        android:id=\"@+id/tv\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"15dp\"\n        android:padding=\"10dp\"\n        android:text=\"helo\" />\n\n    <EditText\n        android:id=\"@+id/et\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"40dp\"\n        android:layout_alignParentLeft=\"true\"\n        android:layout_alignParentStart=\"true\"\n        android:layout_alignParentTop=\"true\"\n        android:layout_marginTop=\"75dp\" />\n\n    <Button\n        android:id=\"@+id/btn\"\n        android:layout_width=\"80dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/et\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginTop=\"49dp\"\n        android:text=\"sure\" />\n\t</RelativeLayout>\n\n测试类\nExampleInstrumentedTest.class\n\n\t@RunWith(AndroidJUnit4.class)\n\tpublic class ExampleInstrumentedTest {\n\t    @Rule\n\t    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n\t            MainActivity.class);\n\n\t    @Test\n\t    public void useAppContext() throws Exception {\n\t        // Context of the app under test.\n\t        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n\t                closeSoftKeyboard());\n\t        onView(withId(R.id.btn)).perform(click());\n\t    }\n\t}\n其中**onView(withId(R.id.et)).perform(typeText(\"helo world\"), closeSoftKeyboard());**选择界面中的输入框，并输入“helo world”，**onView(withId(R.id.btn)).perform(click());**选择界面中的按钮并点击。\n\n[更多操作方式-1](https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md)        \n[更多操作方式-2](http://blog.csdn.net/eclipsexys/article/details/45622813)\n\n#### 标签解析\n\n\t@Rule: 应用于成员变量\n\t@ClassRule: 应用于测试类中的静态变量\n\t两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\t\t\n\t@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n\n\n### 总结\n\t总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\nAndroid自动化测试\n\nenter image description here\n\nAndroid自动化测试\n摘要\nMonkey测试\n简介\n使用方式\n效果展示\n更多参数介绍\n可能会遇到的问题\n单元测试\n简介\n使用方式\nJunit标签解析\nMockito使用方式\nUI测试\n简介\n使用方式\n标签解析\n总结\n摘要\n\nAndroid自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\nMonkey测试\n\n简介\n\nMonkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n使用方式\n\n（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n效果展示\n\n部分输出数据如下所示：\n\n输出数据\n\n更多参数介绍\n\n点击查看\n\n可能会遇到的问题\n\n（1）“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n点击查看解决方案\n\n单元测试\n\n简介\n\n单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit & Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n使用方式\n\n首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile 'junit:junit:4.12'\n}\n而后在test文件下写单元测试类\n\nenter image description here\n\n被测试类如下\n\npublic class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n单元测试类如下\n\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n最后运行单元测试类，结果如下：\n\nenter image description here\n\nJunit标签解析\n\n在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：\n\n@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n以如下代码为例：\n\npublic class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(\"@Test\");\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(\"@Before\");\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(\"@After\");\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(\"@AfterClass\");\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(\"@BeforeClass\");\n    }\n}\n相应的执行顺序如下：\n\nenter image description here\n\nMockito使用方式\n\n简介：\n\nMockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n先体验以下Mockito的使用：\n\n1.添加依赖\n\ntestCompile 'org.mockito:mockito-core:2.8.47'\n2.被依赖类\n\npublic interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n3.依赖类\n\n@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。\n\nMockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。\n\n上述的依赖类也可以使用如下方式来写：\n\npublic class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似\n\nMock配置\n\nMock有多种配置方式，如下所示：\n\n@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(\"Mockito\").thenReturn(\"rocks\");\n        String result=i.next()+\" \"+i.next();\n        // 断言\n        assertEquals(\"Mockito rocks\", result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(\"Mockito\")).thenReturn(1);\n        when(c.compareTo(\"Eclipse\")).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(\"Mockito\"));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n更多配置可以看下这个网站 点击链接\n\nUI测试\n\n简介\n\nUI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n使用方式\n\n1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。\n\ntestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\ntestCompile 'com.android.support.test:runner:0.4.1'\n2.在androidTest目录下创建测试类\n\nenter image description here\n\n3.被测试类（即activity之类的展示界面） \nMainActivity.class\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\nactivity_main.xml\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<TextView\n    android:id=\"@+id/tv\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:layout_marginTop=\"15dp\"\n    android:padding=\"10dp\"\n    android:text=\"helo\" />\n\n<EditText\n    android:id=\"@+id/et\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"40dp\"\n    android:layout_alignParentLeft=\"true\"\n    android:layout_alignParentStart=\"true\"\n    android:layout_alignParentTop=\"true\"\n    android:layout_marginTop=\"75dp\" />\n\n<Button\n    android:id=\"@+id/btn\"\n    android:layout_width=\"80dp\"\n    android:layout_height=\"wrap_content\"\n    android:layout_below=\"@+id/et\"\n    android:layout_centerHorizontal=\"true\"\n    android:layout_marginTop=\"49dp\"\n    android:text=\"sure\" />\n</RelativeLayout>\n测试类 \nExampleInstrumentedTest.class\n\n@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule<MainActivity> mActivityRule = new ActivityTestRule<>(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(\"helo world\"),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。\n\n更多操作方式-1 \n更多操作方式-2\n\n标签解析\n\n@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n总结\n\n总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n     7539 \nqqq2830\n 退出账号\n当前文档\n 恢复至上次同步状态\n 删除文档\n 导出...\n 预览文档\n 分享链接\n系统\n 设置\n 使用说明\n 快捷帮助\n 常见问题\n 关于\n\n搜索文件\n杂物 Android自动化测试 \n杂物 SwipeToLoadLayout \n检查Evernote中的笔记版本\n\n","slug":"Android自动化测试","published":1,"updated":"2018-02-06T03:18:44.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdb2tf5h0001o4ie4imxixfu","content":"<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg\" alt=\"enter image description here\"></p>\n<hr>\n<p>[TOC]</p>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><pre><code>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n</code></pre><h3 id=\"Monkey测试\"><a href=\"#Monkey测试\" class=\"headerlink\" title=\"Monkey测试\"></a>Monkey测试</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n</code></pre><h4 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><h4 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h4><p>部分输出数据如下所示：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png\" alt=\"输出数据\"></p>\n<h4 id=\"更多参数介绍\"><a href=\"#更多参数介绍\" class=\"headerlink\" title=\"更多参数介绍\"></a>更多参数介绍</h4><p><a href=\"http://blog.csdn.net/linghu_java/article/details/6732895\" target=\"_blank\" rel=\"noopener\">点击查看</a></p>\n<h4 id=\"可能会遇到的问题\"><a href=\"#可能会遇到的问题\" class=\"headerlink\" title=\"可能会遇到的问题\"></a>可能会遇到的问题</h4><pre><code>（1）“&apos;adb&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n</code></pre><p><a href=\"http://www.cnblogs.com/dwf07223/p/3228047.html\" target=\"_blank\" rel=\"noopener\">点击查看解决方案</a></p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n</code></pre><h4 id=\"使用方式-1\"><a href=\"#使用方式-1\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile &apos;junit:junit:4.12&apos;\n}\n</code></pre><p>而后在test文件下写单元测试类<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png\" alt=\"enter image description here\"></p>\n<p>被测试类如下</p>\n<pre><code>public class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n</code></pre><p>单元测试类如下</p>\n<pre><code>public class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n</code></pre><p>最后运行单元测试类，结果如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Junit标签解析\"><a href=\"#Junit标签解析\" class=\"headerlink\" title=\"Junit标签解析\"></a>Junit标签解析</h4><p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<pre><code>@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n</code></pre><p>以如下代码为例：</p>\n<pre><code>public class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(&quot;@Before&quot;);\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(&quot;@After&quot;);\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(&quot;@AfterClass&quot;);\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(&quot;@BeforeClass&quot;);\n    }\n}\n</code></pre><p>相应的执行顺序如下：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Mockito使用方式\"><a href=\"#Mockito使用方式\" class=\"headerlink\" title=\"Mockito使用方式\"></a>Mockito使用方式</h4><p>简介：</p>\n<pre><code>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n</code></pre><p><strong>先体验以下Mockito的使用：</strong></p>\n<p>1.添加依赖</p>\n<pre><code>testCompile &apos;org.mockito:mockito-core:2.8.47&apos;\n</code></pre><p>2.被依赖类</p>\n<pre><code>public interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n</code></pre><p>3.依赖类</p>\n<pre><code>@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>可以发现<strong>IMathUtils</strong>是一个接口，根本就没有实现，用<strong>Mockito</strong>框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！<strong>Mockito代理了IMathUtils.abs(num)的行为</strong>，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法<strong>when…thenReturn…</strong>相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<pre><code>public class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>其中<strong>@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();</strong> 用于初始化Mock对象，效果与在类前添加<strong>@RunWith(MockitoJUnitRunner.class)</strong>标签类似</p>\n<p><strong>Mock配置</strong></p>\n<p>Mock有多种配置方式，如下所示：</p>\n<pre><code>@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);\n        String result=i.next()+&quot; &quot;+i.next();\n        // 断言\n        assertEquals(&quot;Mockito rocks&quot;, result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);\n        when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(&quot;Mockito&quot;));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n</code></pre><p>更多配置可以看下这个网站  <a href=\"http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html\" target=\"_blank\" rel=\"noopener\">点击链接</a></p>\n<h3 id=\"UI测试\"><a href=\"#UI测试\" class=\"headerlink\" title=\"UI测试\"></a>UI测试</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n</code></pre><h4 id=\"使用方式-2\"><a href=\"#使用方式-2\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<pre><code>testCompile &apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;\ntestCompile &apos;com.android.support.test:runner:0.4.1&apos;\n</code></pre><p>2.在androidTest目录下创建测试类</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png\" alt=\"enter image description here\"></p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\n</code></pre><p>activity_main.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    tools:context=&quot;xgn.com.androidautotest.MainActivity&quot;&gt;\n\n&lt;TextView\n    android:id=&quot;@+id/tv&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_marginTop=&quot;15dp&quot;\n    android:padding=&quot;10dp&quot;\n    android:text=&quot;helo&quot; /&gt;\n\n&lt;EditText\n    android:id=&quot;@+id/et&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;40dp&quot;\n    android:layout_alignParentLeft=&quot;true&quot;\n    android:layout_alignParentStart=&quot;true&quot;\n    android:layout_alignParentTop=&quot;true&quot;\n    android:layout_marginTop=&quot;75dp&quot; /&gt;\n\n&lt;Button\n    android:id=&quot;@+id/btn&quot;\n    android:layout_width=&quot;80dp&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_below=&quot;@+id/et&quot;\n    android:layout_centerHorizontal=&quot;true&quot;\n    android:layout_marginTop=&quot;49dp&quot;\n    android:text=&quot;sure&quot; /&gt;\n&lt;/RelativeLayout&gt;\n</code></pre><p>测试类<br>ExampleInstrumentedTest.class</p>\n<pre><code>@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n</code></pre><p>其中<strong>onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());</strong>选择界面中的输入框，并输入“helo world”，<strong>onView(withId(R.id.btn)).perform(click());</strong>选择界面中的按钮并点击。</p>\n<p><a href=\"https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md\" target=\"_blank\" rel=\"noopener\">更多操作方式-1</a><br><a href=\"http://blog.csdn.net/eclipsexys/article/details/45622813\" target=\"_blank\" rel=\"noopener\">更多操作方式-2</a></p>\n<h4 id=\"标签解析\"><a href=\"#标签解析\" class=\"headerlink\" title=\"标签解析\"></a>标签解析</h4><pre><code>@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n</code></pre><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n</code></pre><p>Android自动化测试</p>\n<p>enter image description here</p>\n<p>Android自动化测试<br>摘要<br>Monkey测试<br>简介<br>使用方式<br>效果展示<br>更多参数介绍<br>可能会遇到的问题<br>单元测试<br>简介<br>使用方式<br>Junit标签解析<br>Mockito使用方式<br>UI测试<br>简介<br>使用方式<br>标签解析<br>总结<br>摘要</p>\n<p>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。<br>Monkey测试</p>\n<p>简介</p>\n<p>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。<br>使用方式</p>\n<p>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；<br>（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；<br>（3）Monkey 命令启动方式：  </p>\n<pre><code>- 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n- 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n- 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><p>效果展示</p>\n<p>部分输出数据如下所示：</p>\n<p>输出数据</p>\n<p>更多参数介绍</p>\n<p>点击查看</p>\n<p>可能会遇到的问题</p>\n<p>（1）“’adb’ 不是内部或外部命令，也不是可运行的程序或批处理文件。”<br>点击查看解决方案</p>\n<p>单元测试</p>\n<p>简介</p>\n<p>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。<br>使用方式</p>\n<p>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：</p>\n<p>dependencies {<br>    testCompile ‘junit:junit:4.12’<br>}<br>而后在test文件下写单元测试类</p>\n<p>enter image description here</p>\n<p>被测试类如下</p>\n<p>public class Calculator {<br>    public static int add(int a, int b) {<br>        return a + b;<br>    }<br>}<br>单元测试类如下</p>\n<p>public class ExampleUnitTest {<br>    @Test<br>    public void addition_isCorrect() throws Exception {<br>        assertEquals(4, Calculator.add(2,2));<br>    }<br>}<br>最后运行单元测试类，结果如下：</p>\n<p>enter image description here</p>\n<p>Junit标签解析</p>\n<p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<p>@Test： 将方法（函数）标记为测试用例<br>@Before： 每一个使用@Test标记的方法运行之前都要运行一次<br>@After： 每一个使用@Test标记的方法运行之后都要运行一次<br>@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次<br>@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次<br>以如下代码为例：</p>\n<p>public class ExampleUnitTest {</p>\n<pre><code>@Test\npublic void addition_isCorrect() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n\n@Test\npublic void addition_isErr() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n@Before\npublic void before() throws Exception {\n    System.out.println(&quot;@Before&quot;);\n}\n\n@After\npublic void after() throws Exception {\n    System.out.println(&quot;@After&quot;);\n}\n\n\n@AfterClass\npublic static void afterClass() throws Exception {\n    System.out.println(&quot;@AfterClass&quot;);\n}\n\n@BeforeClass\npublic static void beforeClass() throws Exception {\n    System.out.println(&quot;@BeforeClass&quot;);\n}\n</code></pre><p>}<br>相应的执行顺序如下：</p>\n<p>enter image description here</p>\n<p>Mockito使用方式</p>\n<p>简介：</p>\n<p>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。<br>先体验以下Mockito的使用：</p>\n<p>1.添加依赖</p>\n<p>testCompile ‘org.mockito:mockito-core:2.8.47’<br>2.被依赖类</p>\n<p>public interface IMathUtils {<br>    public int abs(int num); // 求绝对值<br>}<br>3.依赖类</p>\n<p>@RunWith(MockitoJUnitRunner.class)<br>public class MockTest {<br>    @Mock<br>    IMathUtils mathUtils;</p>\n<pre><code>@Test\npublic void mockTest() {\n\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<p>public class MockTest {</p>\n<pre><code>@Mock\nIMathUtils iMathUtils ; \n\n@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n@Test\npublic void mockTest()  {\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似</p>\n<p>Mock配置</p>\n<p>Mock有多种配置方式，如下所示：</p>\n<p>@Test<br>public void test1()  {<br>        //  创建 mock<br>        MyClass test = Mockito.mock(MyClass.class);</p>\n<pre><code>// 自定义 getUniqueId() 的返回值\nwhen(test.getUniqueId()).thenReturn(43);\n\n// 在测试中使用mock对象\nassertEquals(test.getUniqueId(), 43);\n</code></pre><p>}</p>\n<p>// 返回多个值<br>@Test<br>public void testMoreThanOneReturnValue()  {<br>        Iterator i= mock(Iterator.class);<br>        when(i.next()).thenReturn(“Mockito”).thenReturn(“rocks”);<br>        String result=i.next()+” “+i.next();<br>        // 断言<br>        assertEquals(“Mockito rocks”, result);<br>}</p>\n<p>// 如何根据输入来返回值<br>@Test<br>public void testReturnValueDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(“Mockito”)).thenReturn(1);<br>        when(c.compareTo(“Eclipse”)).thenReturn(2);<br>        // 断言<br>        assertEquals(1,c.compareTo(“Mockito”));<br>}</p>\n<p>// 如何让返回值不依赖于输入<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(anyInt())).thenReturn(-1);<br>        // 断言<br>        assertEquals(-1 ,c.compareTo(9));<br>}</p>\n<p>// 根据参数类型来返回值<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(isA(Todo.class))).thenReturn(0);<br>        // 断言<br>        Todo todo = new Todo(5);<br>        assertEquals(todo ,c.compareTo(new Todo(1)));<br>}<br>更多配置可以看下这个网站 点击链接</p>\n<p>UI测试</p>\n<p>简介</p>\n<p>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。<br>使用方式</p>\n<p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<p>testCompile ‘com.android.support.test.espresso:espresso-core:2.2.2’<br>testCompile ‘com.android.support.test:runner:0.4.1’<br>2.在androidTest目录下创建测试类</p>\n<p>enter image description here</p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<p>public class MainActivity extends AppCompatActivity implements View.OnClickListener{</p>\n<pre><code>private EditText mEt;\nprivate TextView mTv;\nprivate Button mBtn;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    mEt = (EditText) findViewById(R.id.et);\n    mTv = (TextView) findViewById(R.id.tv);\n    mBtn = (Button) findViewById(R.id.btn);\n\n    mBtn.setOnClickListener(this);\n}\n\n@Override\npublic void onClick(View v) {\n    mTv.setText(mEt.getText().toString());\n}\n</code></pre><p>}<br>activity_main.xml</p>\n<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>\n<relativelayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<textview android:id=\"@+id/tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margintop=\"15dp\" android:padding=\"10dp\" android:text=\"helo\">\n\n<edittext android:id=\"@+id/et\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:layout_alignparentleft=\"true\" android:layout_alignparentstart=\"true\" android:layout_alignparenttop=\"true\" android:layout_margintop=\"75dp\">\n\n<p><button android:id=\"@+id/btn\" android:layout_width=\"80dp\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/et\" android:layout_centerhorizontal=\"true\" android:layout_margintop=\"49dp\" android:text=\"sure\"><br></button></p></edittext></textview></relativelayout><br>测试类<br>ExampleInstrumentedTest.class<p></p>\n<p>@RunWith(AndroidJUnit4.class)<br>public class ExampleInstrumentedTest {<br>    @Rule<br>    public ActivityTestRule<mainactivity> mActivityRule = new ActivityTestRule&lt;&gt;(<br>            MainActivity.class);</mainactivity></p>\n<pre><code>@Test\npublic void useAppContext() throws Exception {\n    // Context of the app under test.\n    onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n            closeSoftKeyboard());\n    onView(withId(R.id.btn)).perform(click());\n}\n</code></pre><p>}<br>其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。</p>\n<p>更多操作方式-1<br>更多操作方式-2</p>\n<p>标签解析</p>\n<p>@Rule: 应用于成员变量<br>@ClassRule: 应用于测试类中的静态变量<br>两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。</p>\n<p>@RunWith（AndroidJUnit4.class）：  用于修改测试运行器<br>总结</p>\n<p>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。<br>     7539<br>qqq2830<br> 退出账号<br>当前文档<br> 恢复至上次同步状态<br> 删除文档<br> 导出…<br> 预览文档<br> 分享链接<br>系统<br> 设置<br> 使用说明<br> 快捷帮助<br> 常见问题<br> 关于</p>\n<p>搜索文件<br>杂物 Android自动化测试<br>杂物 SwipeToLoadLayout<br>检查Evernote中的笔记版本</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/3-141209112525.jpg\" alt=\"enter image description here\"></p>\n<hr>\n<p>[TOC]</p>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><pre><code>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。\n</code></pre><h3 id=\"Monkey测试\"><a href=\"#Monkey测试\" class=\"headerlink\" title=\"Monkey测试\"></a>Monkey测试</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。  \n</code></pre><h4 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；   \n（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；  \n（3）Monkey 命令启动方式：  \n\n    - 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n    - 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n    - 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><h4 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h4><p>部分输出数据如下所示：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629170549.png\" alt=\"输出数据\"></p>\n<h4 id=\"更多参数介绍\"><a href=\"#更多参数介绍\" class=\"headerlink\" title=\"更多参数介绍\"></a>更多参数介绍</h4><p><a href=\"http://blog.csdn.net/linghu_java/article/details/6732895\" target=\"_blank\" rel=\"noopener\">点击查看</a></p>\n<h4 id=\"可能会遇到的问题\"><a href=\"#可能会遇到的问题\" class=\"headerlink\" title=\"可能会遇到的问题\"></a>可能会遇到的问题</h4><pre><code>（1）“&apos;adb&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。”  \n</code></pre><p><a href=\"http://www.cnblogs.com/dwf07223/p/3228047.html\" target=\"_blank\" rel=\"noopener\">点击查看解决方案</a></p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。\n</code></pre><h4 id=\"使用方式-1\"><a href=\"#使用方式-1\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><pre><code>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：\n\ndependencies {\n    testCompile &apos;junit:junit:4.12&apos;\n}\n</code></pre><p>而后在test文件下写单元测试类<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629180104.png\" alt=\"enter image description here\"></p>\n<p>被测试类如下</p>\n<pre><code>public class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n</code></pre><p>单元测试类如下</p>\n<pre><code>public class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, Calculator.add(2,2));\n    }\n}\n</code></pre><p>最后运行单元测试类，结果如下：</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629181932.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Junit标签解析\"><a href=\"#Junit标签解析\" class=\"headerlink\" title=\"Junit标签解析\"></a>Junit标签解析</h4><p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<pre><code>@Test： 将方法（函数）标记为测试用例\n@Before： 每一个使用@Test标记的方法运行之前都要运行一次\n@After： 每一个使用@Test标记的方法运行之后都要运行一次\n@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次\n@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次\n</code></pre><p>以如下代码为例：</p>\n<pre><code>public class ExampleUnitTest {\n\n    @Test\n    public void addition_isCorrect() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n\n    @Test\n    public void addition_isErr() throws Exception {\n        System.out.println(&quot;@Test&quot;);\n    }\n\n    @Before\n    public void before() throws Exception {\n        System.out.println(&quot;@Before&quot;);\n    }\n\n    @After\n    public void after() throws Exception {\n        System.out.println(&quot;@After&quot;);\n    }\n\n\n    @AfterClass\n    public static void afterClass() throws Exception {\n        System.out.println(&quot;@AfterClass&quot;);\n    }\n\n    @BeforeClass\n    public static void beforeClass() throws Exception {\n        System.out.println(&quot;@BeforeClass&quot;);\n    }\n}\n</code></pre><p>相应的执行顺序如下：<br><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170629184021.png\" alt=\"enter image description here\"></p>\n<h4 id=\"Mockito使用方式\"><a href=\"#Mockito使用方式\" class=\"headerlink\" title=\"Mockito使用方式\"></a>Mockito使用方式</h4><p>简介：</p>\n<pre><code>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。\n</code></pre><p><strong>先体验以下Mockito的使用：</strong></p>\n<p>1.添加依赖</p>\n<pre><code>testCompile &apos;org.mockito:mockito-core:2.8.47&apos;\n</code></pre><p>2.被依赖类</p>\n<pre><code>public interface IMathUtils {\n    public int abs(int num); // 求绝对值\n}\n</code></pre><p>3.依赖类</p>\n<pre><code>@RunWith(MockitoJUnitRunner.class)\npublic class MockTest {\n    @Mock\n    IMathUtils mathUtils;\n\n    @Test\n    public void mockTest() {\n\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>可以发现<strong>IMathUtils</strong>是一个接口，根本就没有实现，用<strong>Mockito</strong>框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！<strong>Mockito代理了IMathUtils.abs(num)的行为</strong>，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法<strong>when…thenReturn…</strong>相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<pre><code>public class MockTest {\n\n    @Mock\n    IMathUtils iMathUtils ; \n\n    @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n    @Test\n    public void mockTest()  {\n        when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n        int abs = mathUtils.abs(-1); // 输出结果 1\n\n        Assert.assertEquals(abs, 1);// 测试通过\n    }\n}\n</code></pre><p>其中<strong>@Rule public MockitoRule mockitoRule = MockitoJUnit.rule();</strong> 用于初始化Mock对象，效果与在类前添加<strong>@RunWith(MockitoJUnitRunner.class)</strong>标签类似</p>\n<p><strong>Mock配置</strong></p>\n<p>Mock有多种配置方式，如下所示：</p>\n<pre><code>@Test\npublic void test1()  {\n        //  创建 mock\n        MyClass test = Mockito.mock(MyClass.class);\n\n    // 自定义 getUniqueId() 的返回值\n    when(test.getUniqueId()).thenReturn(43);\n\n    // 在测试中使用mock对象\n    assertEquals(test.getUniqueId(), 43);\n}\n\n// 返回多个值\n@Test\npublic void testMoreThanOneReturnValue()  {\n        Iterator i= mock(Iterator.class);\n        when(i.next()).thenReturn(&quot;Mockito&quot;).thenReturn(&quot;rocks&quot;);\n        String result=i.next()+&quot; &quot;+i.next();\n        // 断言\n        assertEquals(&quot;Mockito rocks&quot;, result);\n}\n\n// 如何根据输入来返回值\n@Test\npublic void testReturnValueDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(&quot;Mockito&quot;)).thenReturn(1);\n        when(c.compareTo(&quot;Eclipse&quot;)).thenReturn(2);\n        // 断言\n        assertEquals(1,c.compareTo(&quot;Mockito&quot;));\n}\n\n// 如何让返回值不依赖于输入\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(anyInt())).thenReturn(-1);\n        // 断言\n        assertEquals(-1 ,c.compareTo(9));\n}\n\n// 根据参数类型来返回值\n@Test\npublic void testReturnValueInDependentOnMethodParameter()  {\n        Comparable c= mock(Comparable.class);\n        when(c.compareTo(isA(Todo.class))).thenReturn(0);\n        // 断言\n        Todo todo = new Todo(5);\n        assertEquals(todo ,c.compareTo(new Todo(1)));\n}\n</code></pre><p>更多配置可以看下这个网站  <a href=\"http://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html\" target=\"_blank\" rel=\"noopener\">点击链接</a></p>\n<h3 id=\"UI测试\"><a href=\"#UI测试\" class=\"headerlink\" title=\"UI测试\"></a>UI测试</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><pre><code>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。\n</code></pre><h4 id=\"使用方式-2\"><a href=\"#使用方式-2\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h4><p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<pre><code>testCompile &apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;\ntestCompile &apos;com.android.support.test:runner:0.4.1&apos;\n</code></pre><p>2.在androidTest目录下创建测试类</p>\n<p><img src=\"http://or9mw8j7a.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170630135600.png\" alt=\"enter image description here\"></p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    private EditText mEt;\n    private TextView mTv;\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mEt = (EditText) findViewById(R.id.et);\n        mTv = (TextView) findViewById(R.id.tv);\n        mBtn = (Button) findViewById(R.id.btn);\n\n        mBtn.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        mTv.setText(mEt.getText().toString());\n    }\n}\n</code></pre><p>activity_main.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    tools:context=&quot;xgn.com.androidautotest.MainActivity&quot;&gt;\n\n&lt;TextView\n    android:id=&quot;@+id/tv&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_marginTop=&quot;15dp&quot;\n    android:padding=&quot;10dp&quot;\n    android:text=&quot;helo&quot; /&gt;\n\n&lt;EditText\n    android:id=&quot;@+id/et&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;40dp&quot;\n    android:layout_alignParentLeft=&quot;true&quot;\n    android:layout_alignParentStart=&quot;true&quot;\n    android:layout_alignParentTop=&quot;true&quot;\n    android:layout_marginTop=&quot;75dp&quot; /&gt;\n\n&lt;Button\n    android:id=&quot;@+id/btn&quot;\n    android:layout_width=&quot;80dp&quot;\n    android:layout_height=&quot;wrap_content&quot;\n    android:layout_below=&quot;@+id/et&quot;\n    android:layout_centerHorizontal=&quot;true&quot;\n    android:layout_marginTop=&quot;49dp&quot;\n    android:text=&quot;sure&quot; /&gt;\n&lt;/RelativeLayout&gt;\n</code></pre><p>测试类<br>ExampleInstrumentedTest.class</p>\n<pre><code>@RunWith(AndroidJUnit4.class)\npublic class ExampleInstrumentedTest {\n    @Rule\n    public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(\n            MainActivity.class);\n\n    @Test\n    public void useAppContext() throws Exception {\n        // Context of the app under test.\n        onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n                closeSoftKeyboard());\n        onView(withId(R.id.btn)).perform(click());\n    }\n}\n</code></pre><p>其中<strong>onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());</strong>选择界面中的输入框，并输入“helo world”，<strong>onView(withId(R.id.btn)).perform(click());</strong>选择界面中的按钮并点击。</p>\n<p><a href=\"https://github.com/hehonghui/android-tech-frontier/blob/master/issue-11/Android-Espresso%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md\" target=\"_blank\" rel=\"noopener\">更多操作方式-1</a><br><a href=\"http://blog.csdn.net/eclipsexys/article/details/45622813\" target=\"_blank\" rel=\"noopener\">更多操作方式-2</a></p>\n<h4 id=\"标签解析\"><a href=\"#标签解析\" class=\"headerlink\" title=\"标签解析\"></a>标签解析</h4><pre><code>@Rule: 应用于成员变量\n@ClassRule: 应用于测试类中的静态变量\n两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。\n\n@RunWith（AndroidJUnit4.class）：  用于修改测试运行器\n</code></pre><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。\n</code></pre><p>Android自动化测试</p>\n<p>enter image description here</p>\n<p>Android自动化测试<br>摘要<br>Monkey测试<br>简介<br>使用方式<br>效果展示<br>更多参数介绍<br>可能会遇到的问题<br>单元测试<br>简介<br>使用方式<br>Junit标签解析<br>Mockito使用方式<br>UI测试<br>简介<br>使用方式<br>标签解析<br>总结<br>摘要</p>\n<p>Android自带了很多方便的测试工具和方法，包括我们常用的单元测试、UI测试、Monkey测试、Robotium测试、MonkeyRunner测试、senevent模拟等。这些API对于我们编写高质量的APP十分有用。一方面可以发现一些隐藏问题，另一方面可以使测试过程规范化。综合以上原因，本文将分别针对Monkey测试、单元测试以及UI测试进行介绍。<br>Monkey测试</p>\n<p>简介</p>\n<p>Monkey是Android SDK提供的一个命令行工具，可以简单、方便地运行在任何版本的Android模拟器和实体设备上。 Monkey会发送伪随机的用户事件流（如：点击、滑动、按键等，事件类别随机，就和一只猴子在试用你的APP一样，目的只为玩坏它），主要应用于APP的压力和可靠性测试。<br>使用方式</p>\n<p>（1） Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar；<br>（2） Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey；<br>（3）Monkey 命令启动方式：  </p>\n<pre><code>- 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试  \n- 或在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器  \n- 一般使用如下命令：adb shell -p xxx.xxx.com -v 1000 进行测试，其中xxx.xxx.com是要测试的APP的包名         \n</code></pre><p>效果展示</p>\n<p>部分输出数据如下所示：</p>\n<p>输出数据</p>\n<p>更多参数介绍</p>\n<p>点击查看</p>\n<p>可能会遇到的问题</p>\n<p>（1）“’adb’ 不是内部或外部命令，也不是可运行的程序或批处理文件。”<br>点击查看解决方案</p>\n<p>单元测试</p>\n<p>简介</p>\n<p>单元测试是为了测试某一个代码单元而写的测试代码。“一个代码单元”一般就是一个方法（函数）。总结一下，我们可以这样理解：单元测试，是为了测试某一个类的某一个方法能否正常工作，而写的测试代码。Java单元测试框架：Junit、Mockito、Powermockito等,最开始建议先学习Junit &amp; Mockito。这两款框架是java领域应用非常普及，使用简单，网上文章非常多，官网的说明也很清晰。junit运行在jvm上，所以只能测试纯java，若要测试依赖android库的代码，可以用mockito隔离依赖（下面会谈及）。<br>使用方式</p>\n<p>首先我们的项目要依赖于junit库，Android studio创建项目时会自动引入该库，即在app的build.gradle中的如下语句：</p>\n<p>dependencies {<br>    testCompile ‘junit:junit:4.12’<br>}<br>而后在test文件下写单元测试类</p>\n<p>enter image description here</p>\n<p>被测试类如下</p>\n<p>public class Calculator {<br>    public static int add(int a, int b) {<br>        return a + b;<br>    }<br>}<br>单元测试类如下</p>\n<p>public class ExampleUnitTest {<br>    @Test<br>    public void addition_isCorrect() throws Exception {<br>        assertEquals(4, Calculator.add(2,2));<br>    }<br>}<br>最后运行单元测试类，结果如下：</p>\n<p>enter image description here</p>\n<p>Junit标签解析</p>\n<p>在Junit中有多种标签可供使用，以下是它们的使用时机，以及作用：</p>\n<p>@Test： 将方法（函数）标记为测试用例<br>@Before： 每一个使用@Test标记的方法运行之前都要运行一次<br>@After： 每一个使用@Test标记的方法运行之后都要运行一次<br>@BeforeClass： 整个测试类运行过程中，最先运行，且只运行一次<br>@AfterClass： 整个测试类运行过程中，最后运行，且只运行一次<br>以如下代码为例：</p>\n<p>public class ExampleUnitTest {</p>\n<pre><code>@Test\npublic void addition_isCorrect() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n\n@Test\npublic void addition_isErr() throws Exception {\n    System.out.println(&quot;@Test&quot;);\n}\n\n@Before\npublic void before() throws Exception {\n    System.out.println(&quot;@Before&quot;);\n}\n\n@After\npublic void after() throws Exception {\n    System.out.println(&quot;@After&quot;);\n}\n\n\n@AfterClass\npublic static void afterClass() throws Exception {\n    System.out.println(&quot;@AfterClass&quot;);\n}\n\n@BeforeClass\npublic static void beforeClass() throws Exception {\n    System.out.println(&quot;@BeforeClass&quot;);\n}\n</code></pre><p>}<br>相应的执行顺序如下：</p>\n<p>enter image description here</p>\n<p>Mockito使用方式</p>\n<p>简介：</p>\n<p>Mockito 是一个流行 mock 框架（mock 是指类或者接口的模拟实现，你可以自定义一个对象中某个方法的输出结果），可以和JUnit结合起来使用。Mockito 允许你创建和配置 mock 对象，并且定义它的行为。使用Mockito可以明显的简化对外部依赖的测试类的开发。<br>先体验以下Mockito的使用：</p>\n<p>1.添加依赖</p>\n<p>testCompile ‘org.mockito:mockito-core:2.8.47’<br>2.被依赖类</p>\n<p>public interface IMathUtils {<br>    public int abs(int num); // 求绝对值<br>}<br>3.依赖类</p>\n<p>@RunWith(MockitoJUnitRunner.class)<br>public class MockTest {<br>    @Mock<br>    IMathUtils mathUtils;</p>\n<pre><code>@Test\npublic void mockTest() {\n\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>可以发现IMathUtils是一个接口，根本就没有实现，用Mockito框架mock之后，IMathUtils.abs(-1)就有返回值1了。这就是Mockito神奇的地方！Mockito代理了IMathUtils.abs(num)的行为，只要调用时符合指定参数（代码中指定参数-1），就可以得到映射的返回值。</p>\n<p>Mockito的语法when…thenReturn…相当直观，直观解释就是当调用某个过程时，返回固定的结果。</p>\n<p>上述的依赖类也可以使用如下方式来写：</p>\n<p>public class MockTest {</p>\n<pre><code>@Mock\nIMathUtils iMathUtils ; \n\n@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); \n\n@Test\npublic void mockTest()  {\n    when(mathUtils.abs(-1)).thenReturn(1); // 当调用abs(-1)时，返回1\n\n    int abs = mathUtils.abs(-1); // 输出结果 1\n\n    Assert.assertEquals(abs, 1);// 测试通过\n}\n</code></pre><p>}<br>其中@Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); 用于初始化Mock对象，效果与在类前添加@RunWith(MockitoJUnitRunner.class)标签类似</p>\n<p>Mock配置</p>\n<p>Mock有多种配置方式，如下所示：</p>\n<p>@Test<br>public void test1()  {<br>        //  创建 mock<br>        MyClass test = Mockito.mock(MyClass.class);</p>\n<pre><code>// 自定义 getUniqueId() 的返回值\nwhen(test.getUniqueId()).thenReturn(43);\n\n// 在测试中使用mock对象\nassertEquals(test.getUniqueId(), 43);\n</code></pre><p>}</p>\n<p>// 返回多个值<br>@Test<br>public void testMoreThanOneReturnValue()  {<br>        Iterator i= mock(Iterator.class);<br>        when(i.next()).thenReturn(“Mockito”).thenReturn(“rocks”);<br>        String result=i.next()+” “+i.next();<br>        // 断言<br>        assertEquals(“Mockito rocks”, result);<br>}</p>\n<p>// 如何根据输入来返回值<br>@Test<br>public void testReturnValueDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(“Mockito”)).thenReturn(1);<br>        when(c.compareTo(“Eclipse”)).thenReturn(2);<br>        // 断言<br>        assertEquals(1,c.compareTo(“Mockito”));<br>}</p>\n<p>// 如何让返回值不依赖于输入<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(anyInt())).thenReturn(-1);<br>        // 断言<br>        assertEquals(-1 ,c.compareTo(9));<br>}</p>\n<p>// 根据参数类型来返回值<br>@Test<br>public void testReturnValueInDependentOnMethodParameter()  {<br>        Comparable c= mock(Comparable.class);<br>        when(c.compareTo(isA(Todo.class))).thenReturn(0);<br>        // 断言<br>        Todo todo = new Todo(5);<br>        assertEquals(todo ,c.compareTo(new Todo(1)));<br>}<br>更多配置可以看下这个网站 点击链接</p>\n<p>UI测试</p>\n<p>简介</p>\n<p>UI测试顾名思义就是：开发人员可以对已经安装到手机或模拟器上的APP进行功能性的测试。现在Android studio自带的Espresso就是一个很好的UI测试框架。<br>使用方式</p>\n<p>1.配置Espresso依赖，现在Android Studio都会在项目创建时自动导入。</p>\n<p>testCompile ‘com.android.support.test.espresso:espresso-core:2.2.2’<br>testCompile ‘com.android.support.test:runner:0.4.1’<br>2.在androidTest目录下创建测试类</p>\n<p>enter image description here</p>\n<p>3.被测试类（即activity之类的展示界面）<br>MainActivity.class</p>\n<p>public class MainActivity extends AppCompatActivity implements View.OnClickListener{</p>\n<pre><code>private EditText mEt;\nprivate TextView mTv;\nprivate Button mBtn;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    mEt = (EditText) findViewById(R.id.et);\n    mTv = (TextView) findViewById(R.id.tv);\n    mBtn = (Button) findViewById(R.id.btn);\n\n    mBtn.setOnClickListener(this);\n}\n\n@Override\npublic void onClick(View v) {\n    mTv.setText(mEt.getText().toString());\n}\n</code></pre><p>}<br>activity_main.xml</p>\n<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>\n<relativelayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"xgn.com.androidautotest.MainActivity\">\n\n<textview android:id=\"@+id/tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margintop=\"15dp\" android:padding=\"10dp\" android:text=\"helo\">\n\n<edittext android:id=\"@+id/et\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:layout_alignparentleft=\"true\" android:layout_alignparentstart=\"true\" android:layout_alignparenttop=\"true\" android:layout_margintop=\"75dp\">\n\n<p><button android:id=\"@+id/btn\" android:layout_width=\"80dp\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/et\" android:layout_centerhorizontal=\"true\" android:layout_margintop=\"49dp\" android:text=\"sure\"><br></button></p></edittext></textview></relativelayout><br>测试类<br>ExampleInstrumentedTest.class<p></p>\n<p>@RunWith(AndroidJUnit4.class)<br>public class ExampleInstrumentedTest {<br>    @Rule<br>    public ActivityTestRule<mainactivity> mActivityRule = new ActivityTestRule&lt;&gt;(<br>            MainActivity.class);</mainactivity></p>\n<pre><code>@Test\npublic void useAppContext() throws Exception {\n    // Context of the app under test.\n    onView(withId(R.id.et)).perform(typeText(&quot;helo world&quot;),\n            closeSoftKeyboard());\n    onView(withId(R.id.btn)).perform(click());\n}\n</code></pre><p>}<br>其中onView(withId(R.id.et)).perform(typeText(“helo world”), closeSoftKeyboard());选择界面中的输入框，并输入“helo world”，onView(withId(R.id.btn)).perform(click());选择界面中的按钮并点击。</p>\n<p>更多操作方式-1<br>更多操作方式-2</p>\n<p>标签解析</p>\n<p>@Rule: 应用于成员变量<br>@ClassRule: 应用于测试类中的静态变量<br>两者共同点：这些变量必须是TestRule接口的实例，且访问修饰符必须为public。</p>\n<p>@RunWith（AndroidJUnit4.class）：  用于修改测试运行器<br>总结</p>\n<p>总的来说自动化测试能够很大程度上减少开发者在测试APP上所消耗的事件，一个好的测试用例能够使APP更可靠，也可以使开发者对自己的作品更有信心。各种测试方式能够搭配使用，合理的配合能够使测试的效果达到最大化。<br>     7539<br>qqq2830<br> 退出账号<br>当前文档<br> 恢复至上次同步状态<br> 删除文档<br> 导出…<br> 预览文档<br> 分享链接<br>系统<br> 设置<br> 使用说明<br> 快捷帮助<br> 常见问题<br> 关于</p>\n<p>搜索文件<br>杂物 Android自动化测试<br>杂物 SwipeToLoadLayout<br>检查Evernote中的笔记版本</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjdb2tf5c0000o4iexv20wral","category_id":"cjdb2tf5k0002o4ieeo371txw","_id":"cjdb2tf5p0006o4ievik2jn6u"},{"post_id":"cjdb2tf5h0001o4ie4imxixfu","category_id":"cjdb2tf5k0002o4ieeo371txw","_id":"cjdb2tf5q0008o4iebsc9ci54"}],"PostTag":[{"post_id":"cjdb2tf5c0000o4iexv20wral","tag_id":"cjdb2tf5m0003o4ie7z4cramc","_id":"cjdb2tf5r000ao4ie9mqhro9u"},{"post_id":"cjdb2tf5c0000o4iexv20wral","tag_id":"cjdb2tf5n0005o4iegkw813wr","_id":"cjdb2tf5r000bo4iebfd9zzku"},{"post_id":"cjdb2tf5c0000o4iexv20wral","tag_id":"cjdb2tf5p0007o4ie2iabwrqg","_id":"cjdb2tf5r000do4iezotfitf6"},{"post_id":"cjdb2tf5h0001o4ie4imxixfu","tag_id":"cjdb2tf5m0003o4ie7z4cramc","_id":"cjdb2tf5s000fo4iemp563mt7"},{"post_id":"cjdb2tf5h0001o4ie4imxixfu","tag_id":"cjdb2tf5r000co4ieecusp2wj","_id":"cjdb2tf5s000go4ieyn5nahx4"},{"post_id":"cjdb2tf5h0001o4ie4imxixfu","tag_id":"cjdb2tf5p0007o4ie2iabwrqg","_id":"cjdb2tf5t000ho4ie0ipbydz8"}],"Tag":[{"name":"Android","_id":"cjdb2tf5m0003o4ie7z4cramc"},{"name":"三方框架","_id":"cjdb2tf5n0005o4iegkw813wr"},{"name":"技术","_id":"cjdb2tf5p0007o4ie2iabwrqg"},{"name":"测试","_id":"cjdb2tf5r000co4ieecusp2wj"}]}}